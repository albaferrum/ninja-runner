<!DOCTYPE html>
<html lang="tr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>RPGTurk Ninja Runner v1.0</title>
  
  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/10.7.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.0/firebase-database-compat.js"></script>
  
  <style>
    :root { color-scheme: dark; }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body { 
      height: 100%; 
      background: linear-gradient(135deg, #0a0a12 0%, #1a1a2e 50%, #0f0f1a 100%);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; 
      overflow: hidden;
    }

    /* ===== SCREENS ===== */
    .screen {
      position: fixed;
      inset: 0;
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      padding: 20px;
      padding-top: 40px;
      z-index: 100;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
    }
    .screen.active { display: flex; }

    .screen-title {
      font-size: 42px;
      font-weight: 900;
      color: #fff;
      text-shadow: 0 0 30px rgba(255,100,100,0.5);
      margin-bottom: 10px;
    }
    .screen-subtitle {
      font-size: 16px;
      color: rgba(255,255,255,0.6);
      margin-bottom: 30px;
    }

    /* ===== AUTH SCREEN ===== */
    #authScreen {
      background: radial-gradient(ellipse at center, rgba(80,20,80,0.3) 0%, transparent 70%),
                  linear-gradient(135deg, #0a0a12 0%, #1a1a2e 100%);
    }
    .auth-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      width: min(380px, 90%);
      padding: 30px;
      background: rgba(255,255,255,0.05);
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,0.1);
      margin-bottom: 20px;
    }
    .auth-container.hidden {
      display: none;
    }
    .auth-title {
      font-size: 24px;
      font-weight: 700;
      color: #fff;
      margin-bottom: 20px;
    }
    .auth-input {
      width: 100%;
      padding: 14px 18px;
      font-size: 16px;
      border: 2px solid rgba(255,255,255,0.2);
      border-radius: 10px;
      background: rgba(255,255,255,0.05);
      color: #fff;
      outline: none;
      margin-bottom: 12px;
      box-sizing: border-box;
    }
    .auth-input:focus {
      border-color: rgba(255,100,100,0.6);
      box-shadow: 0 0 15px rgba(255,100,100,0.2);
    }
    .auth-input::placeholder { color: rgba(255,255,255,0.3); }
    .auth-error {
      color: #ff6b6b;
      font-size: 14px;
      margin-top: 10px;
      min-height: 20px;
      text-align: center;
    }
    .auth-switch {
      color: rgba(255,255,255,0.6);
      font-size: 14px;
      margin-top: 15px;
    }
    .auth-switch span {
      color: #ff6b6b;
      cursor: pointer;
      font-weight: 600;
    }
    .auth-switch span:hover {
      text-decoration: underline;
    }

    /* ===== NICKNAME SCREEN ===== */
    #nicknameScreen {
      background: radial-gradient(ellipse at center, rgba(80,20,80,0.3) 0%, transparent 70%),
                  linear-gradient(135deg, #0a0a12 0%, #1a1a2e 100%);
    }
    .nick-input {
      width: min(320px, 90%);
      padding: 16px 20px;
      font-size: 18px;
      border: 2px solid rgba(255,255,255,0.2);
      border-radius: 12px;
      background: rgba(255,255,255,0.05);
      color: #fff;
      text-align: center;
      outline: none;
      margin-bottom: 20px;
    }
    .nick-input:focus {
      border-color: rgba(255,100,100,0.6);
      box-shadow: 0 0 20px rgba(255,100,100,0.2);
    }
    .nick-input::placeholder { color: rgba(255,255,255,0.3); }

    .btn {
      padding: 14px 32px;
      font-size: 16px;
      font-weight: 700;
      color: #fff;
      background: linear-gradient(135deg, #ff6b6b 0%, #c44569 100%);
      border: none;
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.2s;
      touch-action: manipulation;
    }
    .btn:hover { transform: translateY(-2px); box-shadow: 0 8px 25px rgba(255,100,100,0.4); }
    .btn:active { transform: translateY(0); }
    .btn:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }

    /* ===== CHARACTER SELECT SCREEN ===== */
    #charSelectScreen {
      background: radial-gradient(ellipse at center, rgba(20,60,100,0.3) 0%, transparent 70%),
                  linear-gradient(135deg, #0a0a12 0%, #1a1a2e 100%);
      overflow-y: auto;
      justify-content: flex-start;
      padding-top: 40px;
      padding-bottom: 40px;
      padding-right: 180px;
      position: relative;
    }
    .char-select-coins {
      position: absolute;
      top: 20px;
      right: 190px;
      background: rgba(255,180,0,0.2);
      border: 2px solid rgba(255,180,0,0.4);
      padding: 10px 20px;
      border-radius: 20px;
      font-size: 18px;
      font-weight: 700;
      color: #ffd700;
    }
    /* Right side panel for buttons */
    .char-select-sidebar {
      position: fixed;
      right: 20px;
      top: 50%;
      transform: translateY(-50%);
      display: flex;
      flex-direction: column;
      gap: 12px;
      z-index: 100;
    }
    .char-select-sidebar .btn-secondary {
      width: 140px;
      text-align: center;
      padding: 12px 16px;
      font-size: 13px;
    }
    .char-grid {
      display: grid;
      grid-template-columns: repeat(5, 1fr);
      gap: 12px;
      width: min(900px, 95%);
      margin-bottom: 25px;
    }
    .char-card {
      background: rgba(255,255,255,0.05);
      border: 2px solid rgba(255,255,255,0.1);
      border-radius: 16px;
      padding: 20px 12px;
      cursor: pointer;
      transition: all 0.25s;
      text-align: center;
    }
    .char-card:hover {
      background: rgba(255,255,255,0.08);
      transform: translateY(-4px);
    }
    .char-card.selected {
      border-color: #ff6b6b;
      background: rgba(255,100,100,0.15);
      box-shadow: 0 0 30px rgba(255,100,100,0.3);
    }
    .char-avatar {
      width: 70px;
      height: 70px;
      border-radius: 50%;
      margin: 0 auto 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 36px;
      overflow: hidden;
    }
    .char-avatar canvas {
      width: 100%;
      height: 100%;
      border-radius: 50%;
    }
    .char-name {
      font-size: 18px;
      font-weight: 800;
      color: #fff;
      margin-bottom: 6px;
    }
    .char-desc {
      font-size: 11px;
      color: rgba(255,255,255,0.5);
      line-height: 1.4;
    }
    .char-skills {
      margin-top: 10px;
      font-size: 10px;
      color: rgba(255,255,255,0.7);
      text-align: left;
      background: rgba(0,0,0,0.2);
      padding: 8px;
      border-radius: 8px;
    }
    .char-skills b { color: #ff9f43; }

    /* ===== GAME SCREEN ===== */
    #gameScreen { z-index: 1; }

    .game-wrap {
      min-height: 100vh;
      display: grid;
      grid-template-rows: auto 1fr auto auto;
      gap: 10px;
      padding: 12px;
      justify-items: center;
      align-items: start;
      background: linear-gradient(135deg, #0a0a12 0%, #1a1a2e 100%);
    }

    /* Fullscreen mode */
    .game-wrap:fullscreen {
      width: 100vw;
      height: 100vh;
      padding: 20px;
    }
    .game-wrap:fullscreen #game {
      max-height: 80vh;
      width: auto !important;
      height: auto !important;
    }
    .game-wrap:-webkit-full-screen {
      width: 100vw;
      height: 100vh;
      padding: 20px;
    }
    .game-wrap:-webkit-full-screen #game {
      max-height: 80vh;
      width: auto !important;
      height: auto !important;
    }

    .hud {
      width: min(560px, 100%);
      display: flex;
      gap: 10px;
      align-items: center;
      justify-content: space-between;
    }

    .pill {
      padding: 8px 12px;
      border-radius: 999px;
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.08);
      color: rgba(255,255,255,.9);
      font-size: 13px;
      backdrop-filter: blur(8px);
      white-space: nowrap;
      user-select: none;
    }

    canvas {
      width: min(560px, 100%);
      height: auto;
      max-height: 60vh;
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,.08);
      box-shadow: 0 18px 70px rgba(0,0,0,.55);
      background: radial-gradient(900px 700px at 50% 0%, #12162a 0%, #0b0d12 60%, #070910 100%);
      touch-action: none;
    }

    .skill-bar {
      width: min(560px, 100%);
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }
    .skill-btn {
      position: relative;
      padding: 16px 12px;
      font-size: 14px;
      font-weight: 800;
      color: #fff;
      border: 2px solid rgba(255,255,255,0.15);
      border-radius: 14px;
      cursor: pointer;
      overflow: hidden;
      transition: all 0.15s;
      touch-action: manipulation;
    }
    .skill-btn.skill-x {
      background: linear-gradient(135deg, rgba(255,150,50,0.3) 0%, rgba(200,100,50,0.2) 100%);
    }
    .skill-btn.skill-f {
      background: linear-gradient(135deg, rgba(150,50,255,0.3) 0%, rgba(100,50,200,0.2) 100%);
    }
    .skill-btn:active { transform: scale(0.97); }
    .skill-btn.cooldown { opacity: 0.5; }
    .skill-btn .cd-bar {
      position: absolute;
      bottom: 0;
      left: 0;
      height: 4px;
      background: linear-gradient(90deg, #ff9f43, #ffc107);
      transition: width 0.1s linear;
    }
    .skill-btn.skill-f .cd-bar {
      background: linear-gradient(90deg, #a855f7, #7c3aed);
    }
    .skill-btn .cd-text {
      position: absolute;
      top: 4px;
      right: 8px;
      font-size: 11px;
      color: rgba(255,255,255,0.6);
    }

    .controls {
      width: min(560px, 100%);
      display: grid;
      grid-template-columns: repeat(6, 1fr);
      gap: 6px;
      padding-bottom: env(safe-area-inset-bottom);
      margin-top: -5px;
    }

    .ctrlBtn {
      border-radius: 12px;
      padding: 10px 6px;
      font-size: 13px;
      font-weight: 800;
      color: rgba(255,255,255,.92);
      background: rgba(255,255,255,.07);
      border: 1px solid rgba(255,255,255,.10);
      backdrop-filter: blur(8px);
      user-select: none;
      -webkit-user-select: none;
      -webkit-tap-highlight-color: transparent;
      touch-action: none;
      cursor: pointer;
    }
    .ctrlBtn:active { transform: translateY(1px); background: rgba(255,255,255,.11); }

    /* Mobile: Larger, more accessible buttons */
    @media (max-width: 768px) {
      .controls {
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        width: 100%;
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        grid-template-rows: auto auto;
        gap: 8px;
        padding: 12px;
        padding-bottom: calc(12px + env(safe-area-inset-bottom));
        background: linear-gradient(to top, rgba(0,0,0,0.95) 0%, rgba(0,0,0,0.8) 100%);
        z-index: 1000;
        margin: 0;
      }

      .ctrlBtn {
        border-radius: 16px;
        padding: 18px 12px;
        font-size: 16px;
        font-weight: 800;
        background: rgba(255,255,255,.12);
        border: 2px solid rgba(255,255,255,.2);
      }

      /* Zƒ±pla ve Eƒüil butonlarƒ± daha b√ºy√ºk */
      #btnJump, #btnCrouch {
        padding: 22px 12px;
        font-size: 18px;
        background: linear-gradient(135deg, rgba(99,102,241,0.3), rgba(139,92,246,0.3));
        border-color: rgba(139,92,246,0.5);
      }

      .hint {
        display: none; /* Hide hint on mobile to save space */
      }

      .game-wrap {
        padding-bottom: 140px; /* Space for fixed controls */
      }
    }

    /* Very small screens */
    @media (max-width: 400px) {
      .controls {
        grid-template-columns: repeat(3, 1fr);
        gap: 6px;
        padding: 8px;
      }

      .ctrlBtn {
        padding: 14px 8px;
        font-size: 14px;
      }

      #btnJump, #btnCrouch {
        padding: 18px 8px;
        font-size: 16px;
      }
    }

    /* Global Music Button - floating */
    .music-toggle {
      position: fixed;
      top: 15px;
      right: 15px;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      background: rgba(0,0,0,0.7);
      border: 2px solid rgba(255,255,255,0.3);
      color: white;
      font-size: 24px;
      cursor: pointer;
      z-index: 9999;
      display: flex;
      align-items: center;
      justify-content: center;
      backdrop-filter: blur(10px);
      transition: all 0.2s ease;
      box-shadow: 0 4px 15px rgba(0,0,0,0.3);
    }
    .music-toggle:hover {
      background: rgba(0,0,0,0.9);
      transform: scale(1.1);
    }
    .music-toggle:active {
      transform: scale(0.95);
    }

    /* ===== ITEM SHOP OVERLAY ===== */
    .item-shop-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.85);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 200;
    }
    .item-shop-overlay.active {
      display: flex;
    }
    .item-shop {
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      border: 3px solid #ffd700;
      border-radius: 24px;
      padding: 24px;
      max-width: 90%;
      width: 600px;
      max-height: 80vh;
      overflow-y: auto;
    }
    .shop-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }
    .shop-title {
      font-size: 28px;
      font-weight: 900;
      color: #ffd700;
      text-shadow: 0 0 20px rgba(255,215,0,0.5);
    }
    .shop-coins {
      background: rgba(255,215,0,0.2);
      border: 2px solid #ffd700;
      border-radius: 12px;
      padding: 8px 16px;
      color: #ffd700;
      font-weight: 700;
      font-size: 18px;
    }
    .shop-close {
      background: #ef4444;
      border: none;
      color: #fff;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      font-size: 20px;
      cursor: pointer;
      transition: all 0.2s;
    }
    .shop-close:hover {
      background: #dc2626;
      transform: scale(1.1);
    }
    .shop-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 15px;
    }
    .shop-item {
      background: rgba(255,255,255,0.05);
      border: 2px solid rgba(255,255,255,0.1);
      border-radius: 16px;
      padding: 16px;
      transition: all 0.2s;
    }
    .shop-item:hover {
      background: rgba(255,255,255,0.1);
      transform: translateY(-3px);
    }
    .shop-item.owned {
      border-color: #22c55e;
      background: rgba(34,197,94,0.1);
    }
    .item-icon {
      font-size: 36px;
      margin-bottom: 8px;
    }
    .item-name {
      font-size: 16px;
      font-weight: 700;
      color: #fff;
      margin-bottom: 4px;
    }
    .item-desc {
      font-size: 12px;
      color: rgba(255,255,255,0.6);
      margin-bottom: 10px;
      line-height: 1.4;
    }
    .item-price {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .price-tag {
      color: #ffd700;
      font-weight: 700;
      font-size: 14px;
    }
    .buy-btn {
      background: linear-gradient(135deg, #ffd700, #f59e0b);
      border: none;
      color: #000;
      font-weight: 700;
      padding: 8px 16px;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s;
    }
    .buy-btn:hover {
      transform: scale(1.05);
    }
    .buy-btn:disabled {
      background: #666;
      color: #999;
      cursor: not-allowed;
    }

    /* ===== ITEM BAR (bottom of game) ===== */
    .item-bar {
      position: absolute;
      bottom: 160px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 8px;
      background: rgba(0,0,0,0.7);
      padding: 8px 12px;
      border-radius: 12px;
      border: 2px solid rgba(255,255,255,0.2);
      z-index: 50;
    }
    .item-slot {
      width: 50px;
      height: 50px;
      background: rgba(255,255,255,0.05);
      border: 2px solid rgba(255,255,255,0.2);
      border-radius: 10px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.2s;
      position: relative;
    }
    .item-slot:hover {
      background: rgba(255,255,255,0.1);
      border-color: rgba(255,255,255,0.4);
    }
    .item-slot.empty {
      opacity: 0.5;
    }
    .item-slot.active {
      border-color: #22c55e;
      box-shadow: 0 0 15px rgba(34,197,94,0.5);
    }
    .item-slot.cooldown {
      border-color: #ef4444;
    }
    .item-slot .slot-icon {
      font-size: 20px;
    }
    .item-slot .slot-key {
      font-size: 10px;
      color: rgba(255,255,255,0.6);
      position: absolute;
      bottom: 2px;
    }
    .item-slot .cooldown-overlay {
      position: absolute;
      inset: 0;
      background: rgba(0,0,0,0.7);
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #fff;
      font-weight: 700;
      font-size: 12px;
    }

    /* Shop button in game */
    .shop-btn {
      background: linear-gradient(135deg, #ffd700, #f59e0b);
      border: none;
      color: #000;
      font-weight: 700;
      padding: 6px 12px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 14px;
    }

    .hint {
      width: min(560px, 100%);
      text-align: center;
      color: rgba(255,255,255,.7);
      font-size: 12px;
      padding: 12px;
      background: rgba(255,255,255,.03);
      border-radius: 10px;
      line-height: 1.4;
    }

    /* Ultimate active effects */
    .ult-active {
      animation: ultPulse 0.5s ease-in-out infinite alternate;
    }
    @keyframes ultPulse {
      from { box-shadow: 0 0 20px rgba(168, 85, 247, 0.4); }
      to { box-shadow: 0 0 40px rgba(168, 85, 247, 0.8); }
    }

    /* ===== DOJO OVERLAY ===== */
    .dojo-overlay {
      display: none;
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.85);
      z-index: 1000;
      justify-content: center;
      align-items: center;
    }
    .dojo-overlay.active { display: flex; }
    .dojo-container {
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      border: 2px solid rgba(255,180,0,0.4);
      border-radius: 20px;
      padding: 30px;
      max-width: 500px;
      width: 90%;
      text-align: center;
    }
    .dojo-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }
    .dojo-title {
      font-size: 24px;
      font-weight: 700;
      color: #ffd700;
    }
    .dojo-coins {
      background: rgba(255,180,0,0.2);
      padding: 8px 16px;
      border-radius: 15px;
      color: #ffd700;
      font-weight: 700;
    }
    .dojo-subtitle {
      color: rgba(255,255,255,0.6);
      font-size: 14px;
      margin-bottom: 25px;
    }
    .dojo-grid {
      display: flex;
      flex-direction: column;
      gap: 15px;
      margin-bottom: 20px;
    }
    .dojo-item {
      background: rgba(255,255,255,0.05);
      border: 2px solid rgba(255,255,255,0.1);
      border-radius: 12px;
      padding: 15px;
      cursor: pointer;
      transition: all 0.2s;
      display: grid;
      grid-template-columns: 50px 1fr auto;
      align-items: center;
      text-align: left;
      gap: 15px;
    }
    .dojo-item:hover {
      background: rgba(255,180,0,0.1);
      border-color: rgba(255,180,0,0.4);
    }
    .dojo-item.owned {
      border-color: rgba(0,255,100,0.4);
      background: rgba(0,255,100,0.1);
    }
    .dojo-item.cant-afford {
      opacity: 0.5;
      cursor: not-allowed;
    }
    .dojo-item-icon {
      font-size: 32px;
    }
    .dojo-item-name {
      font-size: 16px;
      font-weight: 700;
      color: #fff;
    }
    .dojo-item-desc {
      font-size: 12px;
      color: rgba(255,255,255,0.6);
      margin-top: 4px;
    }
    .dojo-item-price {
      font-size: 16px;
      font-weight: 700;
      color: #ffd700;
    }
    .dojo-item-status {
      font-size: 12px;
      color: #4ade80;
      margin-top: 5px;
    }
    .dojo-item-info {
      flex: 1;
    }
    .dojo-item-right {
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 8px;
    }
    .dojo-buy-btn {
      padding: 8px 16px;
      font-size: 14px;
      font-weight: 700;
      color: #fff;
      background: linear-gradient(135deg, #ffd700 0%, #ff8c00 100%);
      border: none;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s;
    }
    .dojo-buy-btn:hover {
      transform: scale(1.05);
      box-shadow: 0 4px 15px rgba(255,180,0,0.4);
    }
    .dojo-buy-btn:disabled {
      opacity: 0.4;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }
    .dojo-buy-btn.owned {
      background: linear-gradient(135deg, #4ade80 0%, #22c55e 100%);
      pointer-events: none;
    }

    /* ===== ARENA OVERLAY ===== */
    .arena-overlay {
      display: none;
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.9);
      z-index: 1000;
      justify-content: center;
      align-items: center;
      flex-direction: column;
    }
    .arena-overlay.active { display: flex; }
    .arena-container {
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      border: 2px solid rgba(255,50,50,0.4);
      border-radius: 20px;
      padding: 30px;
      max-width: 600px;
      width: 90%;
      text-align: center;
    }
    .arena-title {
      font-size: 28px;
      font-weight: 700;
      color: #ff6b6b;
      margin-bottom: 10px;
    }
    .arena-subtitle {
      color: rgba(255,255,255,0.6);
      font-size: 14px;
      margin-bottom: 25px;
    }
    .arena-section {
      margin-bottom: 20px;
    }
    .arena-section-title {
      font-size: 18px;
      font-weight: 600;
      color: #fff;
      margin-bottom: 15px;
    }
    .arena-room-list {
      display: flex;
      flex-direction: column;
      gap: 10px;
      max-height: 200px;
      overflow-y: auto;
      margin-bottom: 15px;
    }
    .arena-room-item {
      background: rgba(255,255,255,0.05);
      border: 2px solid rgba(255,255,255,0.1);
      border-radius: 10px;
      padding: 12px 15px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      cursor: pointer;
      transition: all 0.2s;
    }
    .arena-room-item:hover {
      background: rgba(255,100,100,0.1);
      border-color: rgba(255,100,100,0.4);
    }
    .arena-room-info {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .arena-room-host {
      font-weight: 600;
      color: #fff;
    }
    .arena-room-char {
      font-size: 12px;
      color: rgba(255,255,255,0.6);
    }
    .arena-room-status {
      font-size: 12px;
      padding: 4px 10px;
      border-radius: 12px;
      background: rgba(255,180,0,0.2);
      color: #ffd700;
    }
    .arena-room-status.waiting {
      background: rgba(0,255,100,0.2);
      color: #4ade80;
    }
    .arena-btn {
      padding: 12px 24px;
      font-size: 16px;
      font-weight: 700;
      color: #fff;
      background: linear-gradient(135deg, #ff6b6b 0%, #c44569 100%);
      border: none;
      border-radius: 10px;
      cursor: pointer;
      transition: all 0.2s;
      margin: 5px;
    }
    .arena-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(255,100,100,0.4);
    }
    .arena-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }
    .arena-btn.secondary {
      background: rgba(255,255,255,0.1);
    }
    .arena-no-rooms {
      color: rgba(255,255,255,0.4);
      padding: 20px;
      font-style: italic;
    }

    /* Arena Lobby */
    .arena-lobby {
      display: none;
    }
    .arena-lobby.active {
      display: block;
    }
    .arena-lobby-players {
      display: flex;
      justify-content: center;
      gap: 40px;
      margin: 30px 0;
    }
    .arena-player-slot {
      width: 120px;
      height: 160px;
      background: rgba(255,255,255,0.05);
      border: 2px dashed rgba(255,255,255,0.2);
      border-radius: 15px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: rgba(255,255,255,0.4);
    }
    .arena-player-slot.filled {
      border: 2px solid rgba(255,100,100,0.5);
      background: rgba(255,100,100,0.1);
    }
    .arena-player-slot.ready {
      border-color: #4ade80;
      background: rgba(74,222,128,0.1);
    }
    .arena-player-name {
      font-size: 14px;
      font-weight: 600;
      color: #fff;
      margin-top: 10px;
    }
    .arena-player-char {
      font-size: 12px;
      color: rgba(255,255,255,0.6);
    }
    .arena-vs {
      font-size: 36px;
      font-weight: 900;
      color: #ff6b6b;
      text-shadow: 0 0 20px rgba(255,100,100,0.5);
    }
    .arena-ready-btn {
      padding: 15px 40px;
      font-size: 18px;
      font-weight: 700;
      color: #fff;
      background: linear-gradient(135deg, #4ade80 0%, #22c55e 100%);
      border: none;
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.2s;
    }
    .arena-ready-btn:hover {
      transform: scale(1.05);
      box-shadow: 0 8px 25px rgba(74,222,128,0.4);
    }
    .arena-ready-btn.ready {
      background: linear-gradient(135deg, #ffd700 0%, #ff8c00 100%);
    }
    .arena-countdown {
      font-size: 48px;
      font-weight: 900;
      color: #ff6b6b;
      text-shadow: 0 0 30px rgba(255,100,100,0.6);
      margin: 20px 0;
      display: none;
    }
    .arena-countdown.active {
      display: block;
      animation: countdownPulse 1s infinite;
    }
    @keyframes countdownPulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.1); }
    }

    /* ===== LOCATION SELECT SCREEN ===== */
    #locationSelectScreen {
      background: radial-gradient(ellipse at center, rgba(20,80,60,0.3) 0%, transparent 70%),
                  linear-gradient(135deg, #0a0a12 0%, #1a1a2e 100%);
    }
    .location-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 20px;
      width: min(700px, 95%);
      margin-bottom: 30px;
    }
    .location-card {
      background: rgba(255,255,255,0.05);
      border: 3px solid rgba(255,255,255,0.1);
      border-radius: 20px;
      padding: 15px;
      cursor: pointer;
      transition: all 0.3s;
      text-align: center;
      overflow: hidden;
    }
    .location-card:hover {
      background: rgba(255,255,255,0.1);
      transform: translateY(-6px) scale(1.02);
    }
    .location-card.selected {
      border-color: #2ecc71;
      background: rgba(46,204,113,0.15);
      box-shadow: 0 0 40px rgba(46,204,113,0.4);
    }
    .location-preview {
      width: 100%;
      height: 120px;
      border-radius: 12px;
      margin-bottom: 12px;
      display: flex;
      align-items: flex-end;
      justify-content: center;
      font-size: 50px;
      position: relative;
      overflow: hidden;
    }
    .location-preview.dark {
      background: linear-gradient(180deg, #0b0d12 0%, #12162a 50%, #1a1a2e 100%);
    }
    .location-preview.forest {
      background: linear-gradient(180deg, #87ceeb 0%, #98d8c8 30%, #2d5016 70%, #1a3d0c 100%);
    }
    .location-preview.mountain {
      background: linear-gradient(180deg, #f9a825 0%, #ffcc80 30%, #8d6e63 60%, #5d4037 100%);
    }
    .location-name {
      font-size: 20px;
      font-weight: 800;
      color: #fff;
      margin-bottom: 6px;
    }
    .location-desc {
      font-size: 12px;
      color: rgba(255,255,255,0.6);
      line-height: 1.4;
    }
    @media (max-width: 600px) {
      .location-grid { grid-template-columns: 1fr; gap: 15px; }
      .location-preview { height: 100px; }
    }

    /* Scrollbar styling */
    #charSelectScreen::-webkit-scrollbar {
      width: 8px;
    }
    #charSelectScreen::-webkit-scrollbar-track {
      background: rgba(255,255,255,0.05);
      border-radius: 4px;
    }
    #charSelectScreen::-webkit-scrollbar-thumb {
      background: rgba(255,100,100,0.4);
      border-radius: 4px;
    }
    #charSelectScreen::-webkit-scrollbar-thumb:hover {
      background: rgba(255,100,100,0.6);
    }

    /* ===== LEADERBOARD STYLES ===== */
    #leaderboardScreen {
      background: radial-gradient(ellipse at center, rgba(255,200,50,0.2) 0%, transparent 70%),
                  linear-gradient(135deg, #0a0a12 0%, #1a1a2e 100%);
    }
    .leaderboard-container {
      width: min(500px, 95%);
      max-height: 60vh;
      overflow-y: auto;
      background: rgba(0,0,0,0.3);
      border-radius: 20px;
      padding: 20px;
      margin-bottom: 20px;
    }
    .leaderboard-row {
      display: grid;
      grid-template-columns: 50px 1fr 80px 100px;
      gap: 10px;
      align-items: center;
      padding: 12px 15px;
      background: rgba(255,255,255,0.05);
      border-radius: 12px;
      margin-bottom: 8px;
      transition: all 0.2s;
    }
    .leaderboard-row:hover {
      background: rgba(255,255,255,0.1);
    }
    .leaderboard-row.current-player {
      background: rgba(255,100,100,0.2);
      border: 2px solid rgba(255,100,100,0.5);
    }
    .leaderboard-row.top-1 { background: linear-gradient(90deg, rgba(255,215,0,0.3), transparent); }
    .leaderboard-row.top-2 { background: linear-gradient(90deg, rgba(192,192,192,0.3), transparent); }
    .leaderboard-row.top-3 { background: linear-gradient(90deg, rgba(205,127,50,0.3), transparent); }
    .rank {
      font-size: 18px;
      font-weight: 900;
      color: #ffd700;
      text-align: center;
    }
    .rank.top-1 { color: #ffd700; font-size: 22px; }
    .rank.top-2 { color: #c0c0c0; }
    .rank.top-3 { color: #cd7f32; }
    .player-name {
      font-size: 16px;
      font-weight: 700;
      color: #fff;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .player-char {
      font-size: 13px;
      color: rgba(255,255,255,0.6);
    }
    .player-score {
      font-size: 18px;
      font-weight: 800;
      color: #2ecc71;
      text-align: right;
    }
    .leaderboard-empty {
      text-align: center;
      color: rgba(255,255,255,0.5);
      padding: 40px;
      font-size: 16px;
    }
    .leaderboard-header {
      display: grid;
      grid-template-columns: 50px 1fr 80px 100px;
      gap: 10px;
      padding: 10px 15px;
      color: rgba(255,255,255,0.5);
      font-size: 12px;
      font-weight: 600;
      text-transform: uppercase;
      margin-bottom: 10px;
    }
    .btn-secondary {
      padding: 12px 28px;
      font-size: 14px;
      font-weight: 700;
      color: #fff;
      background: rgba(255,255,255,0.1);
      border: 2px solid rgba(255,255,255,0.2);
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.2s;
      margin: 5px;
    }
    .btn-secondary:hover {
      background: rgba(255,255,255,0.15);
      border-color: rgba(255,255,255,0.3);
    }

    /* Responsive */
    @media (max-width: 700px) {
      .char-grid { grid-template-columns: repeat(3, 1fr); gap: 10px; }
      .char-card { padding: 12px 8px; }
      .char-avatar { width: 50px; height: 50px; font-size: 26px; margin-bottom: 8px; }
      .char-name { font-size: 14px; }
      .char-desc { font-size: 9px; }
      .char-skills { font-size: 8px; padding: 6px; }
      .screen-title { font-size: 32px; }
    }
    @media (max-width: 400px) {
      .char-grid { grid-template-columns: repeat(3, 1fr); gap: 8px; }
      .char-card { padding: 10px 6px; }
      .char-avatar { width: 40px; height: 40px; font-size: 22px; margin-bottom: 6px; }
      .char-name { font-size: 12px; }
      .char-desc { display: none; }
      .char-skills { font-size: 7px; padding: 5px; }
    }
  </style>
</head>

<body>
  <!-- Global Music Toggle Button -->
  <button class="music-toggle" id="globalMusicBtn">üîä</button>

  <!-- ===== AUTH SCREEN (Login/Register) ===== -->
  <div class="screen active" id="authScreen">
    <div class="screen-title">ü•∑ RPGTURK Runner v1.0</div>
    <div class="screen-subtitle">G√∂lgelerde ko≈ü, d√º≈ümanlarƒ± alt et!</div>
    
    <div class="auth-container" id="loginContainer">
      <div class="auth-title">Giri≈ü Yap</div>
      <input type="text" class="auth-input" id="loginUsername" placeholder="Kullanƒ±cƒ± adƒ±" maxlength="16" autocomplete="off" />
      <input type="password" class="auth-input" id="loginPassword" placeholder="≈ûifre" maxlength="32" />
      <button class="btn" id="loginBtn">Giri≈ü Yap</button>
      <div class="auth-error" id="loginError"></div>
      <div class="auth-switch">
        Hesabƒ±n yok mu? <span id="showRegister">Kayƒ±t Ol</span>
      </div>
    </div>

    <div class="auth-container hidden" id="registerContainer">
      <div class="auth-title">Kayƒ±t Ol</div>
      <input type="text" class="auth-input" id="registerUsername" placeholder="Kullanƒ±cƒ± adƒ±" maxlength="16" autocomplete="off" />
      <input type="email" class="auth-input" id="registerEmail" placeholder="E-posta" maxlength="64" autocomplete="off" />
      <input type="password" class="auth-input" id="registerPassword" placeholder="≈ûifre" maxlength="32" />
      <button class="btn" id="registerBtn">Kayƒ±t Ol</button>
      <div class="auth-error" id="registerError"></div>
      <div class="auth-switch">
        Hesabƒ±n var mƒ±? <span id="showLogin">Giri≈ü Yap</span>
      </div>
    </div>

    <button class="btn-secondary" id="authLeaderboardBtn">üèÜ Skor Tablosu</button>
  </div>

  <!-- ===== NICKNAME SCREEN ===== -->
  <div class="screen" id="nicknameScreen">
    <div class="screen-title">ü•∑ RPGTURK Runner v1.0</div>
    <div class="screen-subtitle">G√∂lgelerde ko≈ü, d√º≈ümanlarƒ± alt et!</div>
    <input type="text" class="nick-input" id="nickInput" placeholder="Nickname gir..." maxlength="16" autocomplete="off" />
    <button class="btn" id="nickBtn" disabled>Devam Et ‚Üí</button>
    <button class="btn-secondary" id="nickLeaderboardBtn">üèÜ Skor Tablosu</button>
  </div>

  <!-- ===== CHARACTER SELECT SCREEN ===== -->
  <div class="screen" id="charSelectScreen">
    <!-- Coin display top right -->
    <div class="char-select-coins" id="charSelectCoins">ü™ô 0</div>
    
    <div class="screen-title">Ninja Se√ß</div>
    <div class="screen-subtitle" id="welcomeText">Ho≈ü geldin!</div>
    
    <div class="char-grid">
      <!-- Haru -->
      <div class="char-card" data-char="haru">
        <div class="char-avatar" id="avatar-haru" style="background: linear-gradient(135deg, #e0e0e0, #9e9e9e);"></div>
        <div>
          <div class="char-name">Haru</div>
          <!-- <div class="char-desc">Ay ƒ±≈üƒ±ƒüƒ±nda parlayan afet.<br/>Mƒ±zrak ustasƒ±</div> -->
          <div class="char-skills">
            <b>X:</b> Mƒ±zrak uzatma (3s)<br/>
            <b>C:</b> Ay I≈üƒ±ƒüƒ± Patlamasƒ± (20s)
          </div>
        </div>
      </div>

      <!-- Ringo -->
      <div class="char-card" data-char="ringo">
        <div class="char-avatar" id="avatar-ringo" style="background: linear-gradient(135deg, #42a5f5, #1565c0);"></div>
        <div>
          <div class="char-name">Ringo</div>
          <!-- <div class="char-desc">Karanlƒ±ƒüƒ±n pen√ßesi.<br/>Shuriken ustasƒ±</div> -->
          <div class="char-skills">
            <b>X:</b> Shuriken fƒ±rlat (3s)<br/>
            <b>C:</b> Kartal U√ßu≈üu (20s)
          </div>
        </div>
      </div>

      <!-- Usagi -->
      <div class="char-card" data-char="usagi">
        <div class="char-avatar" id="avatar-usagi" style="background: linear-gradient(135deg, #ffeb3b, #ffc107);"></div>
        <div>
          <div class="char-name">Usagi</div>
          <!-- <div class="char-desc">Tav≈üancƒ±k.<br/>Buz ustasƒ±</div> -->
          <div class="char-skills">
            <b>X:</b> Su topu fƒ±rlat (3s)<br/>
            <b>C:</b> Buz Kalkanƒ± (20s)
          </div>
        </div>
      </div>

      <!-- Chisa -->
      <div class="char-card" data-char="chisa">
        <div class="char-avatar" id="avatar-chisa" style="background: linear-gradient(135deg, #9b59b6, #8e44ad);"></div>
        <div>
          <div class="char-name">Chisa</div>
          <!-- <div class="char-desc">Minik mor ninja<br/>Hƒ±zlƒ± Adƒ±mlar</div> -->
          <div class="char-skills">
            <b>X:</b> Katana darbesi (1.5s)<br/>
            <b>C:</b> Kƒ±lƒ±√ß Fƒ±rtƒ±nasƒ± (20s)
          </div>
        </div>
      </div>

      <!-- Butsuo -->
      <div class="char-card" data-char="butsuo">
        <div class="char-avatar" id="avatar-butsuo" style="background: linear-gradient(135deg, #ecf0f1, #bdc3c7);"></div>
        <div>
          <div class="char-name">Butsuo</div>
          <!-- <div class="char-desc">Dev kaslƒ± ninja<br/>Aygƒ±r</div> -->
          <div class="char-skills">
            <b>X:</b> Yumruk (1.5s)<br/>
            <b>C:</b> U√ßan Kafa(20s)
          </div>
        </div>
      </div>

      <!-- Teki -->
      <div class="char-card" data-char="teki">
        <div class="char-avatar" id="avatar-teki" style="background: linear-gradient(135deg, #27ae60, #1e8449);"></div>
        <div>
          <div class="char-name">Teki</div>
          <!-- <div class="char-desc">Zayƒ±f zehir ustasƒ±<br/>Zehir Ustasƒ±</div> -->
          <div class="char-skills">
            <b>X:</b> Zehir Mermisi (4s)<br/>
            <b>C:</b> Maymun Dostum (20s)
          </div>
        </div>
      </div>

      <!-- Susumu -->
      <div class="char-card" data-char="susumu">
        <div class="char-avatar" id="avatar-susumu" style="background: linear-gradient(135deg, #e74c3c, #c0392b);"></div>
        <div>
          <div class="char-name">Susumu</div>
          <!-- <div class="char-desc">Tƒ±bbi usta<br/>≈ûifacƒ± Ninja</div> -->
          <div class="char-skills">
            <b>X:</b> ƒ∞ƒüne Yaƒümuru (3s)<br/>
            <b>C:</b> Hayvan Dostlarƒ±m (20s)
          </div>
        </div>
      </div>

      <!-- Shinji -->
      <div class="char-card" data-char="shinji">
        <div class="char-avatar" id="avatar-shinji" style="background: linear-gradient(135deg, #9b59b6, #8e44ad);"></div>
        <div>
          <div class="char-name">Shinji</div>
          <!-- <div class="char-desc">ƒ∞l√ºzyon ustasƒ±<br/>Uzun boylu</div> -->
          <div class="char-skills">
            <b>X:</b> G√∂z I≈üƒ±nƒ± (3s)<br/>
            <b>C:</b> ƒ∞l√ºzyon Fƒ±rtƒ±nasƒ± (20s)
          </div>
        </div>
      </div>

      <!-- Kazuya -->
      <div class="char-card" data-char="kazuya">
        <div class="char-avatar" id="avatar-kazuya" style="background: linear-gradient(135deg, #8e44ad, #6c3483);"></div>
        <div>
          <div class="char-name">Kazuya</div>
          <!-- <div class="char-desc">R√ºzgar ustasƒ±<br/>Mor sa√ßlƒ±</div> -->
          <div class="char-skills">
            <b>X:</b> Hava Dalgasƒ± (3s)<br/>
            <b>C:</b> R√ºzgar Kƒ±lƒ±cƒ± (20s)
          </div>
        </div>
      </div>

      <!-- Togami -->
      <div class="char-card" data-char="togami">
        <div class="char-avatar" id="avatar-togami" style="background: linear-gradient(135deg, #3498db, #555);"></div>
        <div>
          <div class="char-name">Togami</div>
          <!-- <div class="char-desc">Karga ustasƒ±<br/>Gri elbiseli</div> -->
          <div class="char-skills">
            <b>X:</b> Karga T√ºy√º (4s)<br/>
            <b>C:</b> Karanlƒ±k G√º√ß (20s)
          </div>
        </div>
      </div>

      <!-- Kagi -->
      <div class="char-card" data-char="kagi">
        <div class="char-avatar" id="avatar-kagi" style="background: linear-gradient(135deg, #ecf0f1, #bdc3c7);"></div>
        <div>
          <div class="char-name">Kagi</div>
          <!-- <div class="char-desc">Kaƒüƒ±t ustasƒ±<br/>Uzun siyah sa√ßlƒ±</div> -->
          <div class="char-skills">
            <b>X:</b> Kaƒüƒ±t Fƒ±rlatma (3s)<br/>
            <b>C:</b> Kaƒüƒ±t Kanatlar (20s)
          </div>
        </div>
      </div>

      <!-- Akemi -->
      <div class="char-card" data-char="akemi">
        <div class="char-avatar" id="avatar-akemi" style="background: linear-gradient(135deg, #ff69b4, #f1c40f);"></div>
        <div>
          <div class="char-name">Akemi</div>
          <!-- <div class="char-desc">G√ºzel sarƒ±≈üƒ±n<br/>Alev ustasƒ±</div> -->
          <div class="char-skills">
            <b>X:</b> √ñp√ºc√ºk (3s)<br/>
            <b>C:</b> Alev Ejderi (20s)
          </div>
        </div>
      </div>

      <!-- Ryoken -->
      <div class="char-card" data-char="ryoken">
        <div class="char-avatar" id="avatar-ryoken" style="background: linear-gradient(135deg, #9b59b6, #f1c40f);"></div>
        <div>
          <div class="char-name">Ryoken</div>
          <!-- <div class="char-desc">Sarƒ±≈üƒ±n il√ºzyonist<br/>Mistik ninja</div> -->
          <div class="char-skills">
            <b>X:</b> ƒ∞l√ºzyon (3s)<br/>
            <b>C:</b> Mistik ≈ûim≈üek (20s)
          </div>
        </div>
      </div>

      <!-- Riku -->
      <div class="char-card" data-char="riku">
        <div class="char-avatar" id="avatar-riku" style="background: linear-gradient(135deg, #3498db, #fff);"></div>
        <div>
          <div class="char-name">Riku</div>
          <!-- <div class="char-desc">Minik ok√ßu<br/>Beyaz sa√ßlƒ±</div> -->
          <div class="char-skills">
            <b>X:</b> Ok Atƒ±≈üƒ± (2.5s)<br/>
            <b>C:</b> Ok Yaƒümuru (20s)
          </div>
        </div>
      </div>

      <!-- Joaryu -->
      <div class="char-card" data-char="joaryu">
        <div class="char-avatar" id="avatar-joaryu" style="background: linear-gradient(135deg, #8e44ad, #9b59b6);"></div>
        <div>
          <div class="char-name">Joaryu</div>
          <!-- <div class="char-desc">Mor sa√ßlƒ± uzun<br/>Klon ustasƒ±</div> -->
          <div class="char-skills">
            <b>X:</b> Kunai (2s)<br/>
            <b>C:</b> G√∂lge Klon (20s)
          </div>
        </div>
      </div>
    </div>

    <!-- Right side panel -->
    <div class="char-select-sidebar">
      <button class="btn-secondary" id="dojoBtn" style="background: rgba(255,180,0,0.3);">ü•ã Dojo</button>
      <button class="btn-secondary" id="arenaBtn" style="background: rgba(255,50,50,0.3);">‚öîÔ∏è Arena</button>
      <button class="btn-secondary" id="charSelectLeaderboardBtn">üèÜ Skor Tablosu</button>
      <button class="btn-secondary" id="logoutBtn" style="background: rgba(255,100,100,0.2);">üö™ √áƒ±kƒ±≈ü Yap</button>
    </div>

    <button class="btn" id="startBtn" disabled>Mekan Se√ß ‚Üí</button>
  </div>

  <!-- ===== DOJO OVERLAY ===== -->
  <div class="dojo-overlay" id="dojoOverlay">
    <div class="dojo-container">
      <div class="dojo-header">
        <div class="dojo-title">ü•ã DOJO - Kalƒ±cƒ± Bonuslar</div>
        <div class="dojo-coins" id="dojoCoins">ü™ô 0</div>
      </div>
      <div class="dojo-subtitle">Bu bonuslar hesabƒ±na kalƒ±cƒ± olarak eklenir!</div>
      
      <div class="dojo-grid">
        <div class="dojo-item" id="dojoDoubleJump">
          <div class="dojo-item-icon">ü¶ò</div>
          <div class="dojo-item-info">
            <div class="dojo-item-name">√áift Zƒ±plama</div>
            <div class="dojo-item-desc">Havadayken tekrar zƒ±playabilirsin!</div>
          </div>
          <div class="dojo-item-right">
            <div class="dojo-item-price">ü™ô 3000</div>
            <button class="dojo-buy-btn" id="buyDoubleJump">Satƒ±n Al</button>
            <div class="dojo-item-status" id="dojoDoubleJumpStatus"></div>
          </div>
        </div>
        
        <div class="dojo-item" id="dojoExtraLife">
          <div class="dojo-item-icon">‚ù§Ô∏è</div>
          <div class="dojo-item-info">
            <div class="dojo-item-name">Ekstra Can</div>
            <div class="dojo-item-desc">Her oyuna +1 can ile ba≈üla!</div>
          </div>
          <div class="dojo-item-right">
            <div class="dojo-item-price">ü™ô 3000</div>
            <button class="dojo-buy-btn" id="buyExtraLife">Satƒ±n Al</button>
            <div class="dojo-item-status" id="dojoExtraLifeStatus">x0</div>
          </div>
        </div>
        
        <div class="dojo-item" id="dojoAirDash">
          <div class="dojo-item-icon">üí®</div>
          <div class="dojo-item-info">
            <div class="dojo-item-name">ƒ∞tici G√º√ß</div>
            <div class="dojo-item-desc">Havada E tu≈üu ile ileri atƒ±l!</div>
          </div>
          <div class="dojo-item-right">
            <div class="dojo-item-price">ü™ô 3000</div>
            <button class="dojo-buy-btn" id="buyAirDash">Satƒ±n Al</button>
            <div class="dojo-item-status" id="dojoAirDashStatus"></div>
          </div>
        </div>
      </div>
      
      <button class="btn-secondary" id="dojoClose">Kapat</button>
    </div>
  </div>

  <!-- ===== ARENA OVERLAY ===== -->
  <div class="arena-overlay" id="arenaOverlay">
    <div class="arena-container">
      <!-- Main Menu -->
      <div id="arenaMenu">
        <div class="arena-title">‚öîÔ∏è ARENA - PvP</div>
        <div class="arena-subtitle">Diƒüer oyunculara kar≈üƒ± sava≈ü!</div>
        <div class="arena-subtitle">Hen√ºz geli≈ütirme a≈üamasƒ±ndadƒ±r! </div>
        
        <div class="arena-section">
          <div class="arena-section-title">üìã Aktif Odalar</div>
          <div class="arena-room-list" id="arenaRoomList">
            <div class="arena-no-rooms">Y√ºkleniyor...</div>
          </div>
        </div>
        
        <div style="display: flex; justify-content: center; gap: 10px;">
          <button class="arena-btn" id="arenaCreateRoom">üè† Oda Olu≈ütur</button>
          <button class="arena-btn secondary" id="arenaClose">‚ùå Kapat</button>
        </div>
      </div>

      <!-- Lobby -->
      <div class="arena-lobby" id="arenaLobby">
        <div class="arena-title">‚öîÔ∏è D√ºello Odasƒ±</div>
        <div class="arena-subtitle" id="arenaRoomCode">Oda Kodu: ---</div>
        
        <div class="arena-lobby-players">
          <div class="arena-player-slot" id="arenaPlayer1">
            <div style="font-size: 40px;">üë§</div>
            <div class="arena-player-name">Bekleniyor...</div>
            <div class="arena-player-char"></div>
          </div>
          <div class="arena-vs">VS</div>
          <div class="arena-player-slot" id="arenaPlayer2">
            <div style="font-size: 40px;">üë§</div>
            <div class="arena-player-name">Bekleniyor...</div>
            <div class="arena-player-char"></div>
          </div>
        </div>
        
        <div class="arena-countdown" id="arenaCountdown">3</div>
        
        <div id="arenaLobbyButtons">
          <button class="arena-ready-btn" id="arenaReadyBtn">‚úì Hazƒ±rƒ±m!</button>
          <button class="arena-btn secondary" id="arenaLeaveRoom">üö™ Odadan Ayrƒ±l</button>
        </div>
      </div>
    </div>
  </div>

  <!-- ===== LOCATION SELECT SCREEN ===== -->
  <div class="screen" id="locationSelectScreen">
    <div class="screen-title">üèîÔ∏è Mekan Se√ß</div>
    <div class="screen-subtitle">Maceranƒ±n ge√ßeceƒüi yeri se√ß!</div>
    
    <div class="location-grid">
      <!-- Dark Night -->
      <div class="location-card selected" data-location="dark">
        <div class="location-preview dark">üåô</div>
        <div class="location-name">Karanlƒ±k Gece</div>
        <div class="location-desc">Ay ƒ±≈üƒ±ƒüƒ±nda gizli ge√ßitler.<br/>Klasik ninja ortamƒ±.</div>
      </div>

      <!-- Forest -->
      <div class="location-card" data-location="forest">
        <div class="location-preview forest">üå≤</div>
        <div class="location-name">Orman</div>
        <div class="location-desc">Aydƒ±nlƒ±k ormanlƒ±k alan.<br/>Aƒüa√ßlar ve ye≈üillik.</div>
      </div>

      <!-- Mountain -->
      <div class="location-card" data-location="mountain">
        <div class="location-preview mountain">‚õ∞Ô∏è</div>
        <div class="location-name">Daƒü</div>
        <div class="location-desc">Y√ºksek daƒü zirveleri.<br/>G√ºn batƒ±mƒ± manzarasƒ±.</div>
      </div>
    </div>

    <button class="btn" id="locationStartBtn">Oyuna Ba≈üla! ‚öîÔ∏è</button>
  </div>

  <!-- ===== LEADERBOARD SCREEN ===== -->
  <div class="screen" id="leaderboardScreen">
    <div class="screen-title">üèÜ Liderlik Tablosu</div>
    <div class="screen-subtitle" id="playerRankText">En iyi oyuncular</div>
    
    <div class="leaderboard-container">
      <div class="leaderboard-header">
        <span>#</span>
        <span>Oyuncu</span>
        <span>Karakter</span>
        <span style="text-align:right">Skor</span>
      </div>
      <div id="leaderboardList">
        <div class="leaderboard-empty">Y√ºkleniyor...</div>
      </div>
    </div>

    <div>
      <button class="btn" id="playAgainBtn">Tekrar Oyna üéÆ</button>
      <button class="btn-secondary" id="backToMenuBtn">Ana Men√º üè†</button>
    </div>
  </div>

  <!-- ===== GAME SCREEN ===== -->
  <div class="screen" id="gameScreen">
    <div class="game-wrap">
      <div class="hud">
        <div class="pill" id="charPill">Ninja: -</div>
        <div class="pill" id="scorePill">Skor: 0</div>
        <div class="pill" id="coinPill" style="background: linear-gradient(135deg, rgba(255,215,0,0.2), rgba(245,158,11,0.2)); border: 1px solid #ffd700; color: #ffd700;">ü™ô 0</div>
        <button class="shop-btn" id="btnShop">üõí D√ºkkan(Z)</button>
      </div>

      <canvas id="game" width="480" height="640"></canvas>

      <div class="skill-bar">
        <button class="skill-btn skill-x" id="btnSkillX">
          <span class="skill-icon">‚öîÔ∏è</span> <span id="skillXName">Yetenek</span> <b>[X]</b>
          <div class="cd-bar" style="width: 100%;"></div>
          <span class="cd-text" id="cdTextX"></span>
        </button>
        <button class="skill-btn skill-f" id="btnSkillF">
          <span class="skill-icon">üåü</span> <span id="skillFName">Ultimate</span> <b>[C]</b>
          <div class="cd-bar" style="width: 100%;"></div>
          <span class="cd-text" id="cdTextF"></span>
        </button>
      </div>

      <div class="controls">
        <button class="ctrlBtn" id="btnMenu">üè† Men√º</button>
        <button class="ctrlBtn" id="btnLeaderboard">üèÜ</button>
        <button class="ctrlBtn" id="btnFullscreen">‚õ∂</button>
        <button class="ctrlBtn" id="btnJump">‚¨ÜÔ∏è Zƒ±pla</button>
        <button class="ctrlBtn" id="btnCrouch">‚¨áÔ∏è Eƒüil</button>
      </div>

      <div class="hint">
        <b>Zƒ±pla:</b> Space/‚Üë/W ‚Ä¢ <b>Eƒüil:</b> ‚Üì/S ‚Ä¢ <b>Yetenek:</b> X ‚Ä¢ <b>Ulti:</b> C ‚Ä¢ <b>E≈üya:</b> 1-2-3
      </div>

      <!-- Item Bar -->
      <div class="item-bar" id="itemBar">
        <div class="item-slot empty" id="itemSlot1" data-slot="0">
          <span class="slot-icon">-</span>
          <span class="slot-key">[1]</span>
        </div>
        <div class="item-slot empty" id="itemSlot2" data-slot="1">
          <span class="slot-icon">-</span>
          <span class="slot-key">[2]</span>
        </div>
        <div class="item-slot empty" id="itemSlot3" data-slot="2">
          <span class="slot-icon">-</span>
          <span class="slot-key">[3]</span>
        </div>
      </div>
    </div>
  </div>

  <!-- Item Shop Overlay -->
  <div class="item-shop-overlay" id="itemShopOverlay">
    <div class="item-shop">
      <div class="shop-header">
        <div class="shop-title">üõí E≈üya D√ºkkanƒ±</div>
        <div class="shop-coins" id="shopCoins">ü™ô 0</div>
        <button class="shop-close" id="shopClose">‚úï</button>
      </div>
      <div class="shop-grid" id="shopGrid">
        <!-- Items will be populated by JS -->
      </div>
    </div>
  </div>

  <!-- Background Music -->
  <audio id="bgMusic" loop preload="auto">
    <source src="ost/ost.mp3" type="audio/mpeg">
  </audio>

<script>
(() => {
  // ===== CONSTANTS =====
  const WORLD_W = 480;
  const WORLD_H = 640;

  // ===== CHARACTER DEFINITIONS =====
  const CHARACTERS = {
    haru: {
      name: 'Haru',
      color: '#e0e0e0',
      hairColor: '#fff',
      gender: 'female',
      weapon: 'spear',
      skillX: {
        name: 'Mƒ±zrak Uzat',
        icon: 'üó°Ô∏è',
        cooldown: 3,
        action: 'spearExtend'
      },
      skillF: {
        name: 'Ay I≈üƒ±ƒüƒ±',
        icon: 'üåô',
        cooldown: 20,
        duration: 4,
        action: 'moonlight'
      }
    },
    ringo: {
      name: 'Ringo',
      color: '#42a5f5',
      hairColor: '#1e88e5',
      gender: 'male',
      weapon: 'shuriken',
      skillX: {
        name: 'Shuriken',
        icon: '‚≠ê',
        cooldown: 2,
        action: 'shuriken'
      },
      skillF: {
        name: 'Kartal U√ßu≈üu',
        icon: 'ü¶Ö',
        cooldown: 20,
        duration: 5,
        action: 'eagleFlight'
      }
    },
    usagi: {
      name: 'Usagi',
      color: '#ffeb3b',
      hairColor: '#ffd54f',
      gender: 'female',
      weapon: 'water',
      skillX: {
        name: 'Su Topu',
        icon: 'üíß',
        cooldown: 3,
        action: 'waterBall'
      },
      skillF: {
        name: 'Buz Fƒ±rtƒ±nasƒ±',
        icon: 'üå®Ô∏è',
        cooldown: 20,
        duration: 4,
        action: 'iceStorm'
      }
    },
    chisa: {
      name: 'Chisa',
      color: '#9b59b6',
      hairColor: '#f1c40f',
      skinColor: '#9b59b6',
      gender: 'female',
      weapon: 'katana',
      isSmall: true,
      skillX: {
        name: 'Katana Darbesi',
        icon: '‚öîÔ∏è',
        cooldown: 1.5,
        action: 'katanaSlash'
      },
      skillF: {
        name: 'Kƒ±lƒ±√ß Fƒ±rtƒ±nasƒ±',
        icon: 'üåÄ',
        cooldown: 20,
        duration: 4,
        action: 'swordStorm'
      }
    },
    butsuo: {
      name: 'Butsuo',
      color: '#ecf0f1',
      hairColor: '#fff',
      gender: 'male',
      weapon: 'fist',
      isBig: true,
      skillX: {
        name: 'Yumruk',
        icon: 'üëä',
        cooldown: 1.5,
        action: 'punch'
      },
      skillF: {
        name: 'U√ßan Kafa',
        icon: 'üí•',
        cooldown: 20,
        duration: 6,
        action: 'headbutt'
      }
    },
    teki: {
      name: 'Teki',
      color: '#27ae60',
      hairColor: '#fff',
      gender: 'male',
      weapon: 'katana',
      isThin: true,
      skillX: {
        name: 'Zehir Mermisi',
        icon: '‚ò†Ô∏è',
        cooldown: 4,
        action: 'poisonShot'
      },
      skillF: {
        name: 'Maymun Dostum',
        icon: 'üêµ',
        cooldown: 20,
        duration: 5,
        action: 'monkeyFriend'
      }
    },
    susumu: {
      name: 'Susumu',
      color: '#e74c3c',
      hairColor: '#ddd',
      gender: 'male',
      weapon: 'needle',
      skillX: {
        name: 'ƒ∞ƒüne Yaƒümuru',
        icon: 'üíâ',
        cooldown: 3,
        action: 'needleThrow'
      },
      skillF: {
        name: 'Hayvan Dostlarƒ±',
        icon: 'üêæ',
        cooldown: 20,
        duration: 5,
        action: 'animalFriends'
      }
    },
    shinji: {
      name: 'Shinji',
      color: '#9b59b6',
      hairColor: '#333',
      gender: 'male',
      weapon: 'illusion',
      isTall: true,
      skillX: {
        name: 'G√∂z I≈üƒ±nƒ±',
        icon: 'üëÅÔ∏è',
        cooldown: 3,
        action: 'eyeBeam'
      },
      skillF: {
        name: 'ƒ∞l√ºzyon Fƒ±rtƒ±nasƒ±',
        icon: 'üåÄ',
        cooldown: 20,
        duration: 4,
        action: 'illusionStorm'
      }
    },
    kazuya: {
      name: 'Kazuya',
      color: '#8e44ad',
      hairColor: '#9b59b6',
      gender: 'male',
      weapon: 'wind',
      skillX: {
        name: 'Hava Dalgasƒ±',
        icon: 'üí®',
        cooldown: 3,
        action: 'windWave'
      },
      skillF: {
        name: 'R√ºzgar Kƒ±lƒ±cƒ±',
        icon: 'üå™Ô∏è',
        cooldown: 20,
        duration: 4,
        action: 'windSword'
      }
    },
    togami: {
      name: 'Togami',
      color: '#555',
      hairColor: '#3498db',
      gender: 'male',
      weapon: 'feather',
      skillX: {
        name: 'Karga T√ºy√º',
        icon: 'ü™∂',
        cooldown: 4,
        action: 'crowFeather'
      },
      skillF: {
        name: 'Karanlƒ±k G√º√ß',
        icon: 'ü¶Ü',
        cooldown: 20,
        duration: 4,
        action: 'darkAura'
      }
    },
    kagi: {
      name: 'Kagi',
      color: '#ecf0f1',
      hairColor: '#000',
      gender: 'female',
      weapon: 'paper',
      hasLongHair: true,
      skillX: {
        name: 'Kaƒüƒ±t Fƒ±rlatma',
        icon: 'üìÑ',
        cooldown: 3,
        action: 'paperThrow'
      },
      skillF: {
        name: 'Kaƒüƒ±t Kanatlar',
        icon: 'üïäÔ∏è',
        cooldown: 20,
        duration: 5,
        action: 'paperWings'
      }
    },
    akemi: {
      name: 'Akemi',
      color: '#ff69b4',
      hairColor: '#f1c40f',
      gender: 'female',
      weapon: 'kiss',
      hasLongHair: true,
      skillX: {
        name: '√ñp√ºc√ºk',
        icon: 'üíã',
        cooldown: 3,
        action: 'kissThrow'
      },
      skillF: {
        name: 'Alev Ejderi',
        icon: 'üê≤',
        cooldown: 20,
        duration: 4,
        action: 'fireDragon'
      }
    },
    ryoken: {
      name: 'Ryoken',
      color: '#9b59b6',
      hairColor: '#f1c40f',
      gender: 'male',
      weapon: 'illusion',
      skillX: {
        name: 'ƒ∞l√ºzyon',
        icon: 'üëÅÔ∏è',
        cooldown: 3,
        action: 'illusionKill'
      },
      skillF: {
        name: 'Mistik ≈ûim≈üek',
        icon: '‚ö°',
        cooldown: 20,
        duration: 4,
        action: 'mysticLightning'
      }
    },
    riku: {
      name: 'Riku',
      color: '#3498db',
      hairColor: '#fff',
      gender: 'male',
      weapon: 'bow',
      isSmall: true,
      skillX: {
        name: 'Ok Atƒ±≈üƒ±',
        icon: 'üèπ',
        cooldown: 2.5,
        action: 'arrowShot'
      },
      skillF: {
        name: 'Ok Yaƒümuru',
        icon: 'üéØ',
        cooldown: 20,
        duration: 4,
        action: 'arrowRain'
      }
    },
    joaryu: {
      name: 'Joaryu',
      color: '#8e44ad',
      hairColor: '#9b59b6',
      gender: 'male',
      weapon: 'kunai',
      isTall: true,
      skillX: {
        name: 'Kunai',
        icon: 'üó°Ô∏è',
        cooldown: 2,
        action: 'kunaiThrow'
      },
      skillF: {
        name: 'G√∂lge Klon',
        icon: 'üë•',
        cooldown: 20,
        duration: 4,
        action: 'shadowClone'
      }
    }
  };

  // ===== AVATAR DRAWING FUNCTION =====
  function drawCharacterAvatar(charKey, size = 140) {
    const char = CHARACTERS[charKey];
    if (!char) return null;
    
    const canvas = document.createElement('canvas');
    canvas.width = size;
    canvas.height = size;
    const ctx = canvas.getContext('2d');
    
    const centerX = size / 2;
    const centerY = size / 2;
    const scale = size / 140; // Base scale
    
    ctx.save();
    ctx.translate(centerX, centerY + 10 * scale);
    
    // Body
    ctx.fillStyle = '#2a2a3a';
    ctx.beginPath();
    ctx.roundRect(-17 * scale, -15 * scale, 34 * scale, 50 * scale, 8 * scale);
    ctx.fill();
    
    // Head
    const headSize = char.isSmall ? 14 : (char.isBig ? 24 : 18);
    const headY = -25 * scale;
    
    // Skin
    ctx.fillStyle = char.skinColor || '#f5deb3';
    ctx.beginPath();
    ctx.arc(0, headY, headSize * scale * 0.6, 0, Math.PI * 2);
    ctx.fill();
    
    // Hair
    ctx.fillStyle = char.hairColor;
    ctx.beginPath();
    
    if (charKey === 'usagi') {
      // Long golden hair
      ctx.ellipse(0, headY - 5 * scale, 12 * scale, 8 * scale, 0, Math.PI, 0);
      ctx.fill();
      ctx.fillRect(-12 * scale, headY - 5 * scale, 5 * scale, 35 * scale);
      ctx.fillRect(7 * scale, headY - 5 * scale, 5 * scale, 35 * scale);
    } else if (charKey === 'haru') {
      // White long hair
      ctx.ellipse(0, headY - 5 * scale, 11 * scale, 7 * scale, 0, Math.PI, 0);
      ctx.fill();
      ctx.fillRect(-13 * scale, headY - 5 * scale, 4 * scale, 40 * scale);
      ctx.fillRect(9 * scale, headY - 5 * scale, 4 * scale, 40 * scale);
    } else if (charKey === 'ringo') {
      // Spiky blue hair
      ctx.ellipse(0, headY - 5 * scale, 10 * scale, 6 * scale, 0, Math.PI, 0);
      ctx.fill();
      // Spikes
      ctx.beginPath();
      ctx.moveTo(-8 * scale, headY - 5 * scale);
      ctx.lineTo(-12 * scale, headY - 18 * scale);
      ctx.lineTo(-4 * scale, headY - 7 * scale);
      ctx.lineTo(0, headY - 22 * scale);
      ctx.lineTo(4 * scale, headY - 7 * scale);
      ctx.lineTo(12 * scale, headY - 15 * scale);
      ctx.lineTo(8 * scale, headY - 5 * scale);
      ctx.fill();
    } else if (charKey === 'chisa') {
      // Twin tails
      ctx.ellipse(0, headY - 4 * scale, 9 * scale, 6 * scale, 0, Math.PI, 0);
      ctx.fill();
      ctx.beginPath();
      ctx.ellipse(-9 * scale, headY + 5 * scale, 3 * scale, 10 * scale, -0.3, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.ellipse(9 * scale, headY + 5 * scale, 3 * scale, 10 * scale, 0.3, 0, Math.PI * 2);
      ctx.fill();
      // Ribbons
      ctx.fillStyle = '#e74c3c';
      ctx.beginPath();
      ctx.arc(-9 * scale, headY - 2 * scale, 2.5 * scale, 0, Math.PI * 2);
      ctx.arc(9 * scale, headY - 2 * scale, 2.5 * scale, 0, Math.PI * 2);
      ctx.fill();
    } else if (charKey === 'butsuo') {
      // Short spiky white
      ctx.ellipse(0, headY - 4 * scale, 14 * scale, 9 * scale, 0, Math.PI, 0);
      ctx.fill();
      ctx.beginPath();
      ctx.moveTo(-10 * scale, headY - 5 * scale);
      ctx.lineTo(-15 * scale, headY - 12 * scale);
      ctx.lineTo(-6 * scale, headY - 7 * scale);
      ctx.lineTo(0, headY - 16 * scale);
      ctx.lineTo(6 * scale, headY - 7 * scale);
      ctx.lineTo(15 * scale, headY - 12 * scale);
      ctx.lineTo(10 * scale, headY - 5 * scale);
      ctx.fill();
    } else if (charKey === 'teki') {
      // Short wavy
      ctx.ellipse(0, headY - 4 * scale, 10 * scale, 7 * scale, 0, Math.PI, 0);
      ctx.fill();
    } else if (charKey === 'susumu') {
      // Long white hair
      ctx.ellipse(0, headY - 4 * scale, 12 * scale, 8 * scale, 0, Math.PI, 0);
      ctx.fill();
      ctx.fillRect(-13 * scale, headY - 4 * scale, 5 * scale, 40 * scale);
      ctx.fillRect(8 * scale, headY - 4 * scale, 5 * scale, 40 * scale);
    } else if (charKey === 'shinji') {
      // Long purple
      ctx.ellipse(0, headY - 4 * scale, 11 * scale, 7 * scale, 0, Math.PI, 0);
      ctx.fill();
      ctx.fillRect(-12 * scale, headY - 4 * scale, 4 * scale, 30 * scale);
      ctx.fillRect(8 * scale, headY - 4 * scale, 4 * scale, 30 * scale);
    } else if (charKey === 'kazuya') {
      // Purple spiky
      ctx.ellipse(0, headY - 4 * scale, 10 * scale, 7 * scale, 0, Math.PI, 0);
      ctx.fill();
      ctx.beginPath();
      ctx.moveTo(-6 * scale, headY - 5 * scale);
      ctx.lineTo(-10 * scale, headY - 18 * scale);
      ctx.lineTo(-2 * scale, headY - 8 * scale);
      ctx.lineTo(3 * scale, headY - 20 * scale);
      ctx.lineTo(8 * scale, headY - 7 * scale);
      ctx.lineTo(14 * scale, headY - 14 * scale);
      ctx.lineTo(10 * scale, headY - 5 * scale);
      ctx.fill();
    } else if (charKey === 'togami') {
      // Blue-gray hair
      ctx.ellipse(0, headY - 4 * scale, 10 * scale, 7 * scale, 0, Math.PI, 0);
      ctx.fill();
    } else if (charKey === 'kagi') {
      // Long black hair
      ctx.ellipse(0, headY - 4 * scale, 11 * scale, 7 * scale, 0, Math.PI, 0);
      ctx.fill();
      ctx.fillRect(-12 * scale, headY - 4 * scale, 5 * scale, 45 * scale);
      ctx.fillRect(7 * scale, headY - 4 * scale, 5 * scale, 45 * scale);
    } else if (charKey === 'akemi') {
      // Long blonde
      ctx.ellipse(0, headY - 4 * scale, 12 * scale, 8 * scale, 0, Math.PI, 0);
      ctx.fill();
      ctx.fillRect(-13 * scale, headY - 4 * scale, 5 * scale, 42 * scale);
      ctx.fillRect(8 * scale, headY - 4 * scale, 5 * scale, 42 * scale);
    } else if (charKey === 'ryoken') {
      // Blonde spiky
      ctx.ellipse(0, headY - 4 * scale, 11 * scale, 7 * scale, 0, Math.PI, 0);
      ctx.fill();
      ctx.beginPath();
      ctx.moveTo(-8 * scale, headY - 5 * scale);
      ctx.lineTo(-14 * scale, headY - 16 * scale);
      ctx.lineTo(-4 * scale, headY - 8 * scale);
      ctx.lineTo(2 * scale, headY - 20 * scale);
      ctx.lineTo(8 * scale, headY - 7 * scale);
      ctx.lineTo(16 * scale, headY - 14 * scale);
      ctx.lineTo(10 * scale, headY - 5 * scale);
      ctx.fill();
    } else if (charKey === 'riku') {
      // White short
      ctx.ellipse(0, headY - 4 * scale, 9 * scale, 6 * scale, 0, Math.PI, 0);
      ctx.fill();
    } else if (charKey === 'joaryu') {
      // Medium purple hair
      ctx.ellipse(0, headY - 4 * scale, 11 * scale, 7 * scale, 0, Math.PI, 0);
      ctx.fill();
      ctx.fillRect(-12 * scale, headY - 4 * scale, 4 * scale, 20 * scale);
      ctx.fillRect(8 * scale, headY - 4 * scale, 4 * scale, 20 * scale);
    } else {
      // Default hair
      ctx.ellipse(0, headY - 4 * scale, 10 * scale, 7 * scale, 0, Math.PI, 0);
      ctx.fill();
    }
    
    // Eyes
    ctx.fillStyle = '#000';
    ctx.beginPath();
    ctx.ellipse(-5 * scale, headY - 2 * scale, 2 * scale, 2.5 * scale, 0, 0, Math.PI * 2);
    ctx.ellipse(5 * scale, headY - 2 * scale, 2 * scale, 2.5 * scale, 0, 0, Math.PI * 2);
    ctx.fill();
    
    // Eye shine
    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.arc(-4 * scale, headY - 3 * scale, 1 * scale, 0, Math.PI * 2);
    ctx.arc(6 * scale, headY - 3 * scale, 1 * scale, 0, Math.PI * 2);
    ctx.fill();
    
    // Outfit accent color
    ctx.fillStyle = char.color;
    ctx.beginPath();
    ctx.roundRect(-15 * scale, 5 * scale, 30 * scale, 8 * scale, 3 * scale);
    ctx.fill();
    
    ctx.restore();
    
    return canvas;
  }
  
  // Generate all character avatars on page load
  function generateAllAvatars() {
    const charKeys = Object.keys(CHARACTERS);
    charKeys.forEach(charKey => {
      const container = document.getElementById('avatar-' + charKey);
      if (container) {
        const avatarCanvas = drawCharacterAvatar(charKey, 140);
        if (avatarCanvas) {
          container.appendChild(avatarCanvas);
        }
      }
    });
  }

  // ===== LOCATIONS =====
  const LOCATIONS = {
    dark: {
      name: 'Karanlƒ±k Gece',
      bgGradient: ['#0b0d12', '#12162a', '#1a1a2e'],
      groundColor: 'rgba(255,255,255,0.2)',
      dashColor: 'rgba(255,255,255,0.08)',
      cloudColor: '#fff',
      cloudAlpha: 0.12,
      skyObjects: 'moon',
      canvasBg: 'radial-gradient(900px 700px at 50% 0%, #12162a 0%, #0b0d12 60%, #070910 100%)'
    },
    forest: {
      name: 'Orman',
      bgGradient: ['#87ceeb', '#98d8c8', '#2d5016'],
      groundColor: 'rgba(34,139,34,0.8)',
      dashColor: 'rgba(139,69,19,0.4)',
      cloudColor: '#fff',
      cloudAlpha: 0.5,
      skyObjects: 'sun',
      trees: true,
      canvasBg: 'linear-gradient(180deg, #87ceeb 0%, #98d8c8 40%, #2d5016 100%)'
    },
    mountain: {
      name: 'Daƒü',
      bgGradient: ['#f9a825', '#ffcc80', '#5d4037'],
      groundColor: 'rgba(93,64,55,0.8)',
      dashColor: 'rgba(121,85,72,0.5)',
      cloudColor: '#ffecb3',
      cloudAlpha: 0.4,
      skyObjects: 'sunset',
      mountains: true,
      canvasBg: 'linear-gradient(180deg, #f9a825 0%, #ffcc80 40%, #8d6e63 70%, #5d4037 100%)'
    }
  };

  // ===== DOM ELEMENTS =====
  const screens = {
    auth: document.getElementById('authScreen'),
    nickname: document.getElementById('nicknameScreen'),
    charSelect: document.getElementById('charSelectScreen'),
    locationSelect: document.getElementById('locationSelectScreen'),
    leaderboard: document.getElementById('leaderboardScreen'),
    game: document.getElementById('gameScreen')
  };

  // Auth elements
  const loginContainer = document.getElementById('loginContainer');
  const registerContainer = document.getElementById('registerContainer');
  const loginUsername = document.getElementById('loginUsername');
  const loginPassword = document.getElementById('loginPassword');
  const loginBtn = document.getElementById('loginBtn');
  const loginError = document.getElementById('loginError');
  const registerUsername = document.getElementById('registerUsername');
  const registerEmail = document.getElementById('registerEmail');
  const registerPassword = document.getElementById('registerPassword');
  const registerBtn = document.getElementById('registerBtn');
  const registerError = document.getElementById('registerError');
  const showRegister = document.getElementById('showRegister');
  const showLogin = document.getElementById('showLogin');
  const authLeaderboardBtn = document.getElementById('authLeaderboardBtn');

  // Logged in user
  let currentUser = null;

  const nickInput = document.getElementById('nickInput');
  const nickBtn = document.getElementById('nickBtn');
  const welcomeText = document.getElementById('welcomeText');
  const startBtn = document.getElementById('startBtn');
  const charCards = document.querySelectorAll('.char-card');
  const locationCards = document.querySelectorAll('.location-card');
  const locationStartBtn = document.getElementById('locationStartBtn');

  // Dojo elements
  const charSelectCoins = document.getElementById('charSelectCoins');
  const dojoBtn = document.getElementById('dojoBtn');
  const dojoOverlay = document.getElementById('dojoOverlay');
  const dojoCoins = document.getElementById('dojoCoins');
  const dojoDoubleJump = document.getElementById('dojoDoubleJump');
  const dojoExtraLife = document.getElementById('dojoExtraLife');
  const dojoDoubleJumpStatus = document.getElementById('dojoDoubleJumpStatus');
  const dojoExtraLifeStatus = document.getElementById('dojoExtraLifeStatus');
  const dojoAirDashStatus = document.getElementById('dojoAirDashStatus');
  const buyDoubleJump = document.getElementById('buyDoubleJump');
  const buyExtraLife = document.getElementById('buyExtraLife');
  const buyAirDash = document.getElementById('buyAirDash');
  const dojoAirDash = document.getElementById('dojoAirDash');
  const dojoClose = document.getElementById('dojoClose');

  // Arena elements
  const arenaBtn = document.getElementById('arenaBtn');
  const arenaOverlay = document.getElementById('arenaOverlay');
  const arenaMenu = document.getElementById('arenaMenu');
  const arenaLobby = document.getElementById('arenaLobby');
  const arenaRoomList = document.getElementById('arenaRoomList');
  const arenaCreateRoom = document.getElementById('arenaCreateRoom');
  const arenaClose = document.getElementById('arenaClose');
  const arenaRoomCode = document.getElementById('arenaRoomCode');
  const arenaPlayer1 = document.getElementById('arenaPlayer1');
  const arenaPlayer2 = document.getElementById('arenaPlayer2');
  const arenaReadyBtn = document.getElementById('arenaReadyBtn');
  const arenaLeaveRoom = document.getElementById('arenaLeaveRoom');
  const arenaCountdown = document.getElementById('arenaCountdown');
  const arenaLobbyButtons = document.getElementById('arenaLobbyButtons');

  // Permanent bonuses (loaded from Firebase)
  let permBonuses = {
    doubleJump: false,
    extraLives: 0,
    airDash: false
  };

  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  const charPill = document.getElementById('charPill');
  const scorePill = document.getElementById('scorePill');
  const coinPill = document.getElementById('coinPill');

  // Item Shop elements
  const btnShop = document.getElementById('btnShop');
  const itemShopOverlay = document.getElementById('itemShopOverlay');
  const shopGrid = document.getElementById('shopGrid');
  const shopCoins = document.getElementById('shopCoins');
  const shopClose = document.getElementById('shopClose');
  const itemSlots = [
    document.getElementById('itemSlot1'),
    document.getElementById('itemSlot2'),
    document.getElementById('itemSlot3')
  ];

  const btnSkillX = document.getElementById('btnSkillX');
  const btnSkillF = document.getElementById('btnSkillF');
  const skillXName = document.getElementById('skillXName');
  const skillFName = document.getElementById('skillFName');
  const cdTextX = document.getElementById('cdTextX');
  const cdTextF = document.getElementById('cdTextF');

  const btnMenu = document.getElementById('btnMenu');
  const btnLeaderboard = document.getElementById('btnLeaderboard');
  const btnFullscreen = document.getElementById('btnFullscreen');
  const btnJump = document.getElementById('btnJump');
  const btnCrouch = document.getElementById('btnCrouch');

  // Music - global button
  const globalMusicBtn = document.getElementById('globalMusicBtn');
  const bgMusic = document.getElementById('bgMusic');
  let musicPlaying = false;
  bgMusic.volume = 0.4;

  const leaderboardList = document.getElementById('leaderboardList');
  const playerRankText = document.getElementById('playerRankText');
  const playAgainBtn = document.getElementById('playAgainBtn');
  const backToMenuBtn = document.getElementById('backToMenuBtn');
  const charSelectLeaderboardBtn = document.getElementById('charSelectLeaderboardBtn');
  const logoutBtn = document.getElementById('logoutBtn');
  const nickLeaderboardBtn = document.getElementById('nickLeaderboardBtn');

  // ===== FIREBASE CONFIGURATION =====
  const firebaseConfig = {
    apiKey: "AIzaSyAhD6M8GLt-Rn8Qo83vwZuXH_thZMmVRUQ",
    authDomain: "ninja-runner-694e8.firebaseapp.com",
    databaseURL: "https://ninja-runner-694e8-default-rtdb.europe-west1.firebasedatabase.app",
    projectId: "ninja-runner-694e8",
    storageBucket: "ninja-runner-694e8.firebasestorage.app",
    messagingSenderId: "676105736280",
    appId: "1:676105736280:web:ee2be2eeae6528fd50ba2d"
  };

  // Initialize Firebase
  firebase.initializeApp(firebaseConfig);
  const auth = firebase.auth();
  const database = firebase.database();

  // Firebase Realtime Database URL (for REST API fallback - arena uses this)
  const FIREBASE_URL = firebaseConfig.databaseURL;

  // Game session for anti-cheat (client-side now)
  let gameSessionToken = null;
  let gameStartTime = 0;
  let lastScoreUpdate = 0;

  // ===== STATE =====
  let nickname = '';
  let selectedChar = null;
  let selectedLocation = 'dark';

  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const rand = (a, b) => a + Math.random() * (b - a);

  // ===== GAME STATE =====
  const G = {
    t: 0, dt: 0, last: 0,
    running: false, gameOver: false,

    score: 0,
    speed: 280,
    speedMax: 600,
    speedAccel: 12,
    gravity: 2400,

    groundY: 520,
    groundScroll: 0,

    spawnTimer: 0,
    spawnMin: 0.70,
    spawnMax: 1.20,

    obstacles: [],
    projectiles: [],
    particles: [],
    clouds: [],

    skillXCooldown: 0,
    skillFCooldown: 0,
    ultActive: false,
    ultTimer: 0,
    ultType: null,

    // Eagle flight state
    eagleY: 0,
    eagleTargetY: 0,
    eagleWingPhase: 0,

    // Monkey friend state
    monkeyRect: null,

    // Boss state
    bossActive: false,
    riaru1Defeated: false,
    maxdownDefeated: false,
    currentBossType: null, // 'riaru' or 'maxdown'
    boss: null,
    bossProjectiles: [],
    bossAttackTimer: 0,
    bossUltiTimer: 0,
    bossUltiActive: false,
    lightningStrikes: [],
    laserActive: false,
    laserTimer: 0,
    laserY: 0,

    // Parchment/Scroll system
    scrolls: [],
    scrollSpawnTimer: 0,
    lives: 1,
    maxLives: 3,
    scoreMultiplier: 1,
    scoreMultiplierTimer: 0,
    ultiDurationMultiplier: 1,

    // Platform system
    platforms: [],
    platformSpawnTimer: 0,
    onPlatform: null, // Currently standing platform

    // Coin & Item system
    coins: 0,
    ownedItems: [], // Purchased items
    itemSlots: [null, null, null], // 3 item slots
    activeItem: null, // Currently active item effect
    activeItemTimer: 0,
    itemCooldowns: [0, 0, 0], // Cooldowns for each slot
    
    // Puppet (slave character) state
    puppet: null, // { charKey, x, y, hp }

    scaleX: 1,
    scaleY: 1
  };

  // ===== ARENA STATE =====
  let arenaState = {
    active: false,
    roomId: null,
    isHost: false,
    ready: false,
    opponentReady: false,
    countdown: 0,
    inMatch: false,
    listener: null, // Firebase listener reference
    
    // WebRTC
    peerConnection: null,
    dataChannel: null,
    isConnected: false,
    
    // Match state
    player: {
      x: 100,
      y: 400,
      hp: 100,
      maxHp: 100,
      vx: 0,
      vy: 0,
      facingRight: true,
      attacking: false,
      attackTimer: 0,
      skillXCooldown: 0,
      skillFCooldown: 0,
      stunned: 0,
      invincible: 0
    },
    opponent: {
      x: 380,
      y: 400,
      hp: 100,
      maxHp: 100,
      charKey: null,
      name: '',
      facingRight: false
    },
    projectiles: [],
    particles: [],
    lastUpdate: 0,
    countdownStarted: false
  };

  // ===== SPECIAL ITEMS =====
  const SPECIAL_ITEMS = [
    {
      id: 'lightning_armor',
      name: 'Yƒ±ldƒ±rƒ±m Zƒ±rhƒ±',
      icon: '‚ö°',
      description: '15 saniye boyunca t√ºm rakiplerin i√ßinden ge√ß! Dokunulmaz ol.',
      price: 100,
      duration: 15,
      cooldown: 30,
      effect: 'invincible'
    },
    {
      id: 'ishigakure_necklace',
      name: 'Ishigakure Kolyesi',
      icon: 'üìø',
      description: '10 saniye boyunca X yeteneƒüi cooldown s√ºresi 0.5 saniyeye d√º≈üer!',
      price: 75,
      duration: 10,
      cooldown: 45,
      effect: 'rapidFire'
    },
    {
      id: 'ancient_elixir',
      name: 'Kadim ≈ûurup',
      icon: 'üß™',
      description: '+1 can ekler. Kalƒ±cƒ±dƒ±r. Maximum can sƒ±nƒ±rƒ±nƒ± a≈üabilir!',
      price: 50,
      duration: 0,
      cooldown: 10,
      effect: 'extraLife'
    },
    {
      id: 'rasengan',
      name: 'Rasengan',
      icon: 'üåÄ',
      description: 'Mavi ƒ±≈üƒ±klƒ± k√ºre fƒ±rlatƒ±rsƒ±n! T√ºm rakipleri temizler, boss\'a √ßok hasar! Dattebayo!',
      price: 125,
      duration: 0,
      cooldown: 20,
      effect: 'rasengan'
    },
    {
      id: 'viagra',
      name: 'Viagra',
      icon: 'üíä',
      description: '30 saniye boyunca d√º≈ümanlar yava≈ülar! Ba≈üka etkileri de var!',
      price: 100,
      duration: 30,
      cooldown: 40,
      effect: 'slowEnemies'
    },
    {
      id: 'puppet_parchment',
      name: 'Kuklacƒ±nƒ±n Par≈ü√∂meni',
      icon: 'üìú',
      description: 'Rastgele bir karakteri k√∂len olarak √ßaƒüƒ±r! √ñn√ºnde y√ºr√ºr ve sana kalkan olur!',
      price: 150,
      duration: 0,
      cooldown: 0,
      effect: 'summonPuppet'
    },
    {
      id: 'iori_katana',
      name: "Iori'nin Katanasƒ±",
      icon: '‚öîÔ∏è',
      description: '10 saniye boyunca g√∂kten metal par√ßalar yaƒüdƒ±r! T√ºm d√º≈ümanlar √∂l√ºr!',
      price: 100,
      duration: 10,
      cooldown: 0,
      effect: 'metalRain'
    }
  ];

  // ===== ITEM SHOP FUNCTIONS =====
  function openItemShop() {
    G.running = false; // Pause game
    itemShopOverlay.classList.add('active');
    updateShopUI();
  }

  function closeItemShop() {
    itemShopOverlay.classList.remove('active');
    if (!G.gameOver) {
      G.running = true; // Resume game
    }
  }

  function updateShopUI() {
    shopCoins.textContent = `ü™ô ${G.coins}`;
    coinPill.textContent = `ü™ô ${G.coins}`;
    
    shopGrid.innerHTML = SPECIAL_ITEMS.map(item => {
      const owned = G.ownedItems.includes(item.id);
      const canAfford = G.coins >= item.price;
      const inSlot = G.itemSlots.includes(item.id);
      
      return `
        <div class="shop-item ${owned ? 'owned' : ''}">
          <div class="item-icon">${item.icon}</div>
          <div class="item-name">${item.name}</div>
          <div class="item-desc">${item.description}</div>
          <div class="item-price">
            <span class="price-tag">${owned ? '‚úÖ Satƒ±n Alƒ±ndƒ±' : `ü™ô ${item.price}`}</span>
            ${owned ? 
              (inSlot ? 
                `<button class="buy-btn" disabled>Slotta</button>` :
                `<button class="buy-btn" onclick="equipItem('${item.id}')">Ku≈üan</button>`
              ) :
              `<button class="buy-btn" ${!canAfford ? 'disabled' : ''} onclick="buyItem('${item.id}')">Satƒ±n Al</button>`
            }
          </div>
        </div>
      `;
    }).join('');
  }

  // Make functions global for onclick
  window.buyItem = function(itemId) {
    const item = SPECIAL_ITEMS.find(i => i.id === itemId);
    if (!item) return;
    if (G.coins < item.price) return;
    if (G.ownedItems.includes(itemId)) return;
    
    G.coins -= item.price;
    G.ownedItems.push(itemId);
    updateShopUI();
    updateItemSlotsUI();
  };

  window.equipItem = function(itemId) {
    // Find empty slot
    const emptySlot = G.itemSlots.findIndex(s => s === null);
    if (emptySlot === -1) {
      // All slots full, replace first slot
      G.itemSlots[0] = itemId;
    } else {
      G.itemSlots[emptySlot] = itemId;
    }
    updateShopUI();
    updateItemSlotsUI();
  };

  function updateItemSlotsUI() {
    coinPill.textContent = `ü™ô ${G.coins}`;
    
    itemSlots.forEach((slot, i) => {
      const itemId = G.itemSlots[i];
      const item = SPECIAL_ITEMS.find(it => it.id === itemId);
      const cooldown = G.itemCooldowns[i];
      
      if (!item) {
        slot.classList.add('empty');
        slot.classList.remove('active', 'cooldown');
        slot.querySelector('.slot-icon').textContent = '-';
        // Remove cooldown overlay if exists
        const overlay = slot.querySelector('.cooldown-overlay');
        if (overlay) overlay.remove();
      } else {
        slot.classList.remove('empty');
        slot.querySelector('.slot-icon').textContent = item.icon;
        
        // Check if this item is currently active
        if (G.activeItem === itemId) {
          slot.classList.add('active');
          slot.classList.remove('cooldown');
        } else if (cooldown > 0) {
          slot.classList.add('cooldown');
          slot.classList.remove('active');
          // Add or update cooldown overlay
          let overlay = slot.querySelector('.cooldown-overlay');
          if (!overlay) {
            overlay = document.createElement('div');
            overlay.className = 'cooldown-overlay';
            slot.appendChild(overlay);
          }
          overlay.textContent = Math.ceil(cooldown) + 's';
        } else {
          slot.classList.remove('active', 'cooldown');
          const overlay = slot.querySelector('.cooldown-overlay');
          if (overlay) overlay.remove();
        }
      }
    });
  }

  function useItem(slotIndex) {
    if (!G.running || G.gameOver) return;
    
    const itemId = G.itemSlots[slotIndex];
    if (!itemId) return;
    
    const item = SPECIAL_ITEMS.find(i => i.id === itemId);
    if (!item) return;
    
    // Check cooldown
    if (G.itemCooldowns[slotIndex] > 0) return;
    
    // Check if another item is active (except instant items)
    if (G.activeItem && item.duration > 0) return;
    
    // Apply item effect
    applyItemEffect(item, slotIndex);
  }

  function applyItemEffect(item, slotIndex) {
    switch (item.effect) {
      case 'invincible':
        // Lightning Armor - 10 seconds invincibility
        G.activeItem = item.id;
        G.activeItemTimer = item.duration;
        // Remove from slot and owned after use
        G.itemSlots[slotIndex] = null;
        G.ownedItems = G.ownedItems.filter(id => id !== item.id);
        break;
        
      case 'rapidFire':
        // Ishigakure Necklace - reduced X cooldown
        G.activeItem = item.id;
        G.activeItemTimer = item.duration;
        // Remove from slot and owned after use
        G.itemSlots[slotIndex] = null;
        G.ownedItems = G.ownedItems.filter(id => id !== item.id);
        break;
        
      case 'extraLife':
        // Ancient Elixir - +1 life (instant, permanent)
        G.lives += 1;
        G.maxLives = Math.max(G.maxLives, G.lives);
        // Remove from slot after use
        G.itemSlots[slotIndex] = null;
        // Remove from owned items
        G.ownedItems = G.ownedItems.filter(id => id !== item.id);
        break;
        
      case 'rasengan':
        // Rasengan - clear all enemies, half boss HP damage
        fireRasengan();
        // Remove from slot and owned after use
        G.itemSlots[slotIndex] = null;
        G.ownedItems = G.ownedItems.filter(id => id !== item.id);
        break;
        
      case 'slowEnemies':
        // Viagra - slow enemies
        G.activeItem = item.id;
        G.activeItemTimer = item.duration;
        // Remove from slot and owned after use
        G.itemSlots[slotIndex] = null;
        G.ownedItems = G.ownedItems.filter(id => id !== item.id);
        break;
        
      case 'summonPuppet':
        // Puppeteer's Parchment - summon a random character as shield
        summonPuppet();
        // Remove from slot and owned after use
        G.itemSlots[slotIndex] = null;
        G.ownedItems = G.ownedItems.filter(id => id !== item.id);
        break;
        
      case 'metalRain':
        // Iori's Katana - metal rain for 10 seconds
        G.activeItem = 'iori_katana';
        G.activeItemTimer = item.duration;
        G.metalRainTimer = 0;
        G.ioriKatanaActive = true;
        // Remove from slot and owned after use
        G.itemSlots[slotIndex] = null;
        G.ownedItems = G.ownedItems.filter(id => id !== item.id);
        break;
    }
    
    updateItemSlotsUI();
  }

  function fireRasengan() {
    const pr = playerRect();
    
    // Create rasengan projectile
    G.projectiles.push({
      type: 'rasengan',
      x: pr.x + pr.w,
      y: pr.y + pr.h * 0.4,
      radius: 30,
      vx: 500,
      life: 3,
      cleared: false
    });
    
    // Visual particles
    for (let i = 0; i < 20; i++) {
      G.particles.push({
        x: pr.x + pr.w + 20,
        y: pr.y + pr.h * 0.4,
        vx: rand(100, 300),
        vy: rand(-100, 100),
        life: rand(0.3, 0.6),
        color: '#3b82f6'
      });
    }
  }

  function summonPuppet() {
    // Pick a random playable character for the puppet
    const playableChars = ['haru', 'ringo', 'usagi', 'chisa', 'butsuo', 'teki', 'susumu', 'shinji', 'kazuya', 'togami', 'kagi', 'akemi', 'ryoken', 'riku', 'joaryu'];
    const randomCharKey = playableChars[Math.floor(Math.random() * playableChars.length)];
    const char = CHARACTERS[randomCharKey];
    const pr = playerRect();
    
    // Create puppet in front of player
    G.puppet = {
      charKey: randomCharKey,
      x: pr.x + pr.w + 50,
      y: G.groundY,
      w: 35,
      h: 58,
      hp: 1, // Dies on first hit
      phase: 0,
      timer: 15, // 10 seconds duration
      attackCooldown: 0, // Attack timer
      attackRate: char.skillX.cooldown * 0.5 // Attack faster than player
    };
    
    // Summon particles
    for (let i = 0; i < 15; i++) {
      G.particles.push({
        x: G.puppet.x + 15,
        y: G.puppet.y - 30,
        vx: rand(-100, 100),
        vy: rand(-150, -50),
        life: rand(0.4, 0.7),
        color: '#a855f7'
      });
    }
  }

  // Metal Rain System for Iori's Katana
  function updateMetalRain(dt) {
    if (!G.ioriKatanaActive) return;
    
    G.metalRainTimer += dt;
    
    // Spawn metal pieces every 0.1 seconds
    if (G.metalRainTimer >= 0.1) {
      G.metalRainTimer = 0;
      
      // Spawn 2-3 metal pieces
      const count = Math.floor(rand(2, 4));
      for (let i = 0; i < count; i++) {
        const isDisc = Math.random() < 0.5;
        if (!G.metalPieces) G.metalPieces = [];
        G.metalPieces.push({
          x: rand(50, WORLD_W - 50),
          y: -50,
          w: isDisc ? 25 : rand(15, 40),
          h: isDisc ? 25 : rand(8, 15),
          vy: rand(400, 600),
          rotation: rand(0, Math.PI * 2),
          rotSpeed: rand(-10, 10),
          isDisc: isDisc
        });
      }
    }
    
    // Update metal pieces
    if (G.metalPieces) {
      for (let i = G.metalPieces.length - 1; i >= 0; i--) {
        const m = G.metalPieces[i];
        m.y += m.vy * dt;
        m.rotation += m.rotSpeed * dt;
        
        // Remove if off screen
        if (m.y > G.groundY + 50) {
          // Impact particles
          for (let k = 0; k < 5; k++) {
            G.particles.push({
              x: m.x,
              y: G.groundY,
              vx: rand(-100, 100),
              vy: rand(-150, -50),
              life: rand(0.2, 0.4),
              color: '#888'
            });
          }
          G.metalPieces.splice(i, 1);
          continue;
        }
        
        // Kill enemies on contact
        const metalRect = { x: m.x - m.w/2, y: m.y - m.h/2, w: m.w, h: m.h };
        for (let j = G.obstacles.length - 1; j >= 0; j--) {
          const o = G.obstacles[j];
          const oRect = { x: o.x, y: o.y - o.h, w: o.w, h: o.h };
          if (rectsOverlap(metalRect, oRect)) {
            // Kill enemy
            for (let k = 0; k < 10; k++) {
              G.particles.push({
                x: o.x + o.w/2,
                y: o.y - o.h/2,
                vx: rand(-150, 150),
                vy: rand(-200, -50),
                life: rand(0.3, 0.6),
                color: k % 2 === 0 ? '#c0c0c0' : '#ff4444'
              });
            }
            G.obstacles.splice(j, 1);
            G.score += 10;
          }
        }
        
        // Damage boss
        if (G.boss) {
          const bossRect = { x: G.boss.x, y: G.boss.y - G.boss.h, w: G.boss.w, h: G.boss.h };
          if (rectsOverlap(metalRect, bossRect)) {
            G.boss.hp -= 2;
            G.metalPieces.splice(i, 1);
            // Spark particles
            for (let k = 0; k < 5; k++) {
              G.particles.push({
                x: m.x,
                y: m.y,
                vx: rand(-100, 100),
                vy: rand(-100, 50),
                life: rand(0.2, 0.4),
                color: '#ffff00'
              });
            }
            if (G.boss.hp <= 0) {
              defeatBoss();
            }
          }
        }
      }
    }
    
    // Check if effect ended
    if (G.activeItemTimer <= 0) {
      G.ioriKatanaActive = false;
      G.metalPieces = [];
    }
  }

  function drawMetalRain() {
    if (!G.metalPieces || G.metalPieces.length === 0) return;
    
    ctx.save();
    for (const m of G.metalPieces) {
      ctx.save();
      ctx.translate(m.x, m.y);
      ctx.rotate(m.rotation);
      
      if (m.isDisc) {
        // Draw disc
        ctx.fillStyle = '#c0c0c0';
        ctx.beginPath();
        ctx.arc(0, 0, m.w/2, 0, Math.PI * 2);
        ctx.fill();
        
        // Disc shine
        ctx.fillStyle = '#e0e0e0';
        ctx.beginPath();
        ctx.arc(-3, -3, m.w/4, 0, Math.PI * 2);
        ctx.fill();
        
        // Disc edge
        ctx.strokeStyle = '#888';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(0, 0, m.w/2, 0, Math.PI * 2);
        ctx.stroke();
      } else {
        // Draw rectangle metal piece
        ctx.fillStyle = '#a0a0a0';
        ctx.fillRect(-m.w/2, -m.h/2, m.w, m.h);
        
        // Shine
        ctx.fillStyle = '#d0d0d0';
        ctx.fillRect(-m.w/2 + 2, -m.h/2 + 2, m.w/3, m.h - 4);
        
        // Edge
        ctx.strokeStyle = '#666';
        ctx.lineWidth = 1;
        ctx.strokeRect(-m.w/2, -m.h/2, m.w, m.h);
      }
      
      ctx.restore();
    }
    ctx.restore();
  }

  function drawIoriKatana() {
    if (!G.ioriKatanaActive) return;
    
    const pr = playerRect();
    ctx.save();
    
    // Katana in player's hand
    const katanaX = pr.x + pr.w - 5;
    const katanaY = pr.y + pr.h * 0.3;
    const swing = Math.sin(G.t * 8) * 0.3;
    
    ctx.translate(katanaX, katanaY);
    ctx.rotate(-0.5 + swing);
    
    // Blade
    ctx.fillStyle = '#e0e0e0';
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(50, -5);
    ctx.lineTo(55, 0);
    ctx.lineTo(50, 5);
    ctx.lineTo(0, 3);
    ctx.closePath();
    ctx.fill();
    
    // Blade shine
    ctx.fillStyle = '#fff';
    ctx.fillRect(5, -2, 40, 2);
    
    // Handle
    ctx.fillStyle = '#4a3728';
    ctx.fillRect(-15, -4, 18, 8);
    
    // Guard
    ctx.fillStyle = '#8B4513';
    ctx.fillRect(-2, -7, 4, 14);
    
    ctx.restore();
  }

  function updatePuppet(dt) {
    if (!G.puppet) return;
    
    const pr = playerRect();
    const puppet = G.puppet;
    
    // Timer countdown
    puppet.timer -= dt;
    if (puppet.timer <= 0) {
      // Puppet disappears
      for (let k = 0; k < 15; k++) {
        G.particles.push({
          x: puppet.x + puppet.w / 2,
          y: puppet.y - puppet.h / 2,
          vx: rand(-100, 100),
          vy: rand(-150, -50),
          life: rand(0.3, 0.5),
          color: '#a855f7'
        });
      }
      G.puppet = null;
      return;
    }
    
    // Puppet stays in front of player
    const targetX = pr.x + pr.w + 40;
    puppet.x += (targetX - puppet.x) * 5 * dt;
    puppet.y = G.groundY;
    puppet.phase += dt * 5;
    
    // Attack cooldown
    if (puppet.attackCooldown > 0) {
      puppet.attackCooldown -= dt;
    } else {
      // Use basic attack (X skill)
      puppetAttack();
      puppet.attackCooldown = puppet.attackRate;
    }
  }
  
  function puppetAttack() {
    if (!G.puppet) return;
    
    const puppet = G.puppet;
    const char = CHARACTERS[puppet.charKey];
    const puppetCenterX = puppet.x + puppet.w;
    const puppetCenterY = puppet.y - puppet.h * 0.4;
    
    // Create projectile based on character's skill
    if (char.skillX.action === 'spearExtend') {
      G.projectiles.push({
        type: 'spear',
        x: puppetCenterX,
        y: puppetCenterY,
        w: 80,
        h: 6,
        vx: 0,
        extending: true,
        maxW: 120,
        life: 0.4
      });
    } else if (char.skillX.action === 'shuriken') {
      G.projectiles.push({
        type: 'shuriken',
        x: puppetCenterX,
        y: puppetCenterY,
        radius: 10,
        vx: 600,
        spin: 0,
        life: 2
      });
    } else if (char.skillX.action === 'waterBall') {
      G.projectiles.push({
        type: 'waterBall',
        x: puppetCenterX,
        y: puppetCenterY,
        radius: 12,
        vx: 500,
        life: 2,
        trail: []
      });
    } else if (char.skillX.action === 'katanaSlash') {
      G.projectiles.push({
        type: 'katanaSlash',
        x: puppetCenterX - 10,
        y: puppetCenterY,
        w: 50,
        h: 40,
        vx: 0,
        life: 0.2,
        slashPhase: 0
      });
    } else if (char.skillX.action === 'punch') {
      G.projectiles.push({
        type: 'punch',
        x: puppetCenterX,
        y: puppetCenterY,
        w: 40,
        h: 35,
        vx: 0,
        life: 0.25,
        punchPhase: 0
      });
    } else if (char.skillX.action === 'arrowShot') {
      G.projectiles.push({
        type: 'arrowShot',
        x: puppetCenterX,
        y: puppetCenterY,
        w: 30,
        h: 6,
        vx: 700,
        life: 2
      });
    } else if (char.skillX.action === 'kunai') {
      G.projectiles.push({
        type: 'kunai',
        x: puppetCenterX,
        y: puppetCenterY,
        w: 25,
        h: 8,
        vx: 650,
        spin: 0,
        life: 2
      });
    } else {
      // Default: generic projectile
      G.projectiles.push({
        type: 'shuriken',
        x: puppetCenterX,
        y: puppetCenterY,
        radius: 8,
        vx: 550,
        spin: 0,
        life: 2
      });
    }
    
    // Attack particles
    for (let i = 0; i < 5; i++) {
      G.particles.push({
        x: puppetCenterX,
        y: puppetCenterY,
        vx: rand(50, 150),
        vy: rand(-50, 50),
        life: rand(0.2, 0.4),
        color: char.color || '#a855f7'
      });
    }
  }

  function drawPuppet() {
    if (!G.puppet) return;
    
    const puppet = G.puppet;
    const char = CHARACTERS[puppet.charKey];
    
    ctx.save();
    ctx.translate(puppet.x + puppet.w / 2, puppet.y);
    
    // Puppet glow effect
    ctx.globalAlpha = 0.3 + Math.sin(puppet.phase) * 0.1;
    const glowGrad = ctx.createRadialGradient(0, -puppet.h / 2, 0, 0, -puppet.h / 2, 50);
    glowGrad.addColorStop(0, 'rgba(168, 85, 247, 0.5)');
    glowGrad.addColorStop(1, 'rgba(168, 85, 247, 0)');
    ctx.fillStyle = glowGrad;
    ctx.fillRect(-40, -puppet.h - 20, 80, puppet.h + 40);
    
    ctx.globalAlpha = 0.85; // Slightly transparent to show it's a puppet
    
    // Shadow
    ctx.fillStyle = 'rgba(0,0,0,0.3)';
    ctx.beginPath();
    ctx.ellipse(0, 5, 15, 5, 0, 0, Math.PI * 2);
    ctx.fill();
    
    // Body
    ctx.fillStyle = char.color || '#888';
    ctx.beginPath();
    ctx.ellipse(0, -puppet.h / 2, puppet.w / 2 - 5, puppet.h / 2 - 5, 0, 0, Math.PI * 2);
    ctx.fill();
    
    // Head
    ctx.fillStyle = '#f5d0c5';
    ctx.beginPath();
    ctx.arc(0, -puppet.h + 12, 14, 0, Math.PI * 2);
    ctx.fill();
    
    // Hair
    ctx.fillStyle = char.hairColor || '#333';
    ctx.beginPath();
    ctx.arc(0, -puppet.h + 8, 12, Math.PI, Math.PI * 2);
    ctx.fill();
    
    // Eyes
    ctx.fillStyle = '#000';
    ctx.beginPath();
    ctx.arc(-4, -puppet.h + 14, 2, 0, Math.PI * 2);
    ctx.arc(4, -puppet.h + 14, 2, 0, Math.PI * 2);
    ctx.fill();
    
    // Purple control strings (puppet effect)
    ctx.strokeStyle = 'rgba(168, 85, 247, 0.6)';
    ctx.lineWidth = 1;
    ctx.setLineDash([3, 3]);
    ctx.beginPath();
    ctx.moveTo(0, -puppet.h);
    ctx.lineTo(0, -puppet.h - 50);
    ctx.moveTo(-10, -puppet.h + 20);
    ctx.lineTo(-20, -puppet.h - 40);
    ctx.moveTo(10, -puppet.h + 20);
    ctx.lineTo(20, -puppet.h - 40);
    ctx.stroke();
    ctx.setLineDash([]);
    
    // Character name tag
    ctx.fillStyle = 'rgba(0,0,0,0.7)';
    ctx.font = 'bold 10px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText(char.name, 0, -puppet.h - 5);
    
    // Timer display
    const timerText = puppet.timer.toFixed(1) + 's';
    ctx.fillStyle = puppet.timer <= 3 ? 'rgba(255,50,50,0.9)' : 'rgba(168,85,247,0.9)';
    ctx.font = 'bold 12px sans-serif';
    ctx.fillText(timerText, 0, -puppet.h - 55);
    
    // Timer bar
    const barWidth = 30;
    const barHeight = 4;
    const timerPercent = puppet.timer / 10;
    ctx.fillStyle = 'rgba(0,0,0,0.5)';
    ctx.fillRect(-barWidth/2, -puppet.h - 50, barWidth, barHeight);
    ctx.fillStyle = puppet.timer <= 3 ? '#ff3232' : '#a855f7';
    ctx.fillRect(-barWidth/2, -puppet.h - 50, barWidth * timerPercent, barHeight);
    
    ctx.restore();
  }

  function puppetRect() {
    if (!G.puppet) return null;
    return {
      x: G.puppet.x,
      y: G.puppet.y - G.puppet.h,
      w: G.puppet.w,
      h: G.puppet.h
    };
  }

  function updateItemEffects(dt) {
    // Update item cooldowns
    for (let i = 0; i < 3; i++) {
      if (G.itemCooldowns[i] > 0) {
        G.itemCooldowns[i] -= dt;
        if (G.itemCooldowns[i] <= 0) {
          G.itemCooldowns[i] = 0;
        }
      }
    }
    
    // Update active item timer
    if (G.activeItem && G.activeItemTimer > 0) {
      G.activeItemTimer -= dt;
      if (G.activeItemTimer <= 0) {
        G.activeItem = null;
        G.activeItemTimer = 0;
      }
    }
    
    updateItemSlotsUI();
  }

  // ===== BOSS DEFINITIONS =====
  const BOSS = {
    name: 'Raijin',
    maxHp: 100,
    width: 80,
    height: 120,
    x: 400,
    attackCooldown: 2.5,
    ultiCooldown: 12,
    ultiDuration: 3
  };

  const BOSS_MAXDOWN = {
    name: 'MAXDOWN',
    maxHp: 1500,
    width: 120,
    height: 160,
    x: 400,
    attackCooldown: 2.0,
    laserCooldown: 4,
    laserDuration: 0.8
  };

  // ===== PLAYER =====
  const P = {
    x: 100,
    y: 520,
    w: 40,
    h: 64,
    vy: 0,
    onGround: true,
    crouching: false,
    baseH: 64,
    crouchH: 36,
    jumpVel: -920
  };

  // ===== SCREEN NAVIGATION =====
  function showScreen(name) {
    Object.values(screens).forEach(s => s.classList.remove('active'));
    screens[name].classList.add('active');
  }

  // ===== AUTH SCREEN =====
  // Toggle between login and register
  showRegister.addEventListener('click', () => {
    loginContainer.classList.add('hidden');
    registerContainer.classList.remove('hidden');
    loginError.textContent = '';
    registerError.textContent = '';
  });

  showLogin.addEventListener('click', () => {
    registerContainer.classList.add('hidden');
    loginContainer.classList.remove('hidden');
    loginError.textContent = '';
    registerError.textContent = '';
  });

  // Register with Firebase Auth
  registerBtn.addEventListener('click', async () => {
    const username = registerUsername.value.trim();
    const email = registerEmail.value.trim();
    const password = registerPassword.value;

    if (username.length < 2) {
      registerError.textContent = 'Kullanƒ±cƒ± adƒ± en az 2 karakter olmalƒ±';
      return;
    }
    if (!email.includes('@')) {
      registerError.textContent = 'Ge√ßerli bir e-posta girin';
      return;
    }
    if (password.length < 6) {
      registerError.textContent = '≈ûifre en az 6 karakter olmalƒ±';
      return;
    }

    registerBtn.disabled = true;
    registerError.textContent = '';

    try {
      // Check if username is taken
      const usernameSnapshot = await database.ref(`usernames/${username.toLowerCase()}`).once('value');
      if (usernameSnapshot.exists()) {
        registerError.textContent = 'Bu kullanƒ±cƒ± adƒ± zaten alƒ±nmƒ±≈ü';
        registerBtn.disabled = false;
        return;
      }

      // Create Firebase Auth user
      const userCredential = await auth.createUserWithEmailAndPassword(email, password);
      const user = userCredential.user;

      // Save username -> email mapping (for login lookup) and user data
      await database.ref(`usernames/${username.toLowerCase()}`).set(email);
      await database.ref(`users/${user.uid}`).set({
        username: username,
        email: email,
        coins: 0,
        doubleJump: false,
        extraLives: 0,
        airDash: false,
        createdAt: Date.now()
      });

      // Set display name
      await user.updateProfile({ displayName: username });

      // Registration successful
      currentUser = { username: username, email: email, uid: user.uid };
      nickname = username;
      G.coins = 0;
      permBonuses.doubleJump = false;
      permBonuses.extraLives = 0;
      permBonuses.airDash = false;
      localStorage.setItem('ninja_user', JSON.stringify(currentUser));
      welcomeText.textContent = `Ho≈ü geldin, ${username}!`;
      updateCoinsDisplay();
      showScreen('charSelect');
    } catch (err) {
      console.error('Register error:', err);
      if (err.code === 'auth/email-already-in-use') {
        registerError.textContent = 'Bu e-posta zaten kayƒ±tlƒ±';
      } else if (err.code === 'auth/weak-password') {
        registerError.textContent = '≈ûifre √ßok zayƒ±f (en az 6 karakter)';
      } else if (err.code === 'auth/invalid-email') {
        registerError.textContent = 'Ge√ßersiz e-posta adresi';
      } else {
        registerError.textContent = err.message || 'Kayƒ±t ba≈üarƒ±sƒ±z';
      }
    }
    registerBtn.disabled = false;
  });

  // Login with Firebase Auth
  loginBtn.addEventListener('click', async () => {
    const usernameOrEmail = loginUsername.value.trim();
    const password = loginPassword.value;

    if (usernameOrEmail.length < 1 || password.length < 1) {
      loginError.textContent = 'T√ºm alanlarƒ± doldurun';
      return;
    }

    loginBtn.disabled = true;
    loginError.textContent = '';

    try {
      let email = usernameOrEmail;
      
      // If not an email, look up the email from username
      if (!usernameOrEmail.includes('@')) {
        const usernameSnapshot = await database.ref(`usernames/${usernameOrEmail.toLowerCase()}`).once('value');
        if (!usernameSnapshot.exists()) {
          loginError.textContent = 'Kullanƒ±cƒ± bulunamadƒ±';
          loginBtn.disabled = false;
          return;
        }
        // usernames tablosunda email saklanƒ±yor
        email = usernameSnapshot.val();
      }

      // Sign in with Firebase Auth
      const userCredential = await auth.signInWithEmailAndPassword(email, password);
      const user = userCredential.user;

      // Load user data from database
      const userDataSnapshot = await database.ref(`users/${user.uid}`).once('value');
      const userData = userDataSnapshot.val() || {};

      // Login successful
      currentUser = { 
        username: userData.username || user.displayName || usernameOrEmail, 
        email: user.email, 
        uid: user.uid 
      };
      nickname = currentUser.username;
      localStorage.setItem('ninja_user', JSON.stringify(currentUser));
      
      // Load coins and bonuses
      G.coins = userData.coins || 0;
      permBonuses.doubleJump = userData.doubleJump || false;
      permBonuses.extraLives = userData.extraLives || 0;
      permBonuses.airDash = userData.airDash || false;
      
      updateCoinsDisplay();
      updateDojoUI();
      welcomeText.textContent = `Ho≈ü geldin, ${currentUser.username}!`;
      showScreen('charSelect');
    } catch (err) {
      console.error('Login error:', err);
      if (err.code === 'auth/user-not-found') {
        loginError.textContent = 'Kullanƒ±cƒ± bulunamadƒ±';
      } else if (err.code === 'auth/wrong-password') {
        loginError.textContent = '≈ûifre yanlƒ±≈ü';
      } else if (err.code === 'auth/invalid-email') {
        loginError.textContent = 'Ge√ßersiz e-posta adresi';
      } else if (err.code === 'auth/too-many-requests') {
        loginError.textContent = '√áok fazla deneme. L√ºtfen bekleyin.';
      } else {
        loginError.textContent = err.message || 'Giri≈ü ba≈üarƒ±sƒ±z';
      }
    }
    loginBtn.disabled = false;
  });

  // Auth leaderboard button
  authLeaderboardBtn.addEventListener('click', () => {
    viewLeaderboard('auth');
  });

  // Load user data from Firebase Database
  async function loadUserData(uid) {
    try {
      const snapshot = await database.ref(`users/${uid}`).once('value');
      const data = snapshot.val();
      if (data) {
        G.coins = data.coins || 0;
        permBonuses.doubleJump = data.doubleJump || false;
        permBonuses.extraLives = data.extraLives || 0;
        permBonuses.airDash = data.airDash || false;
      } else {
        G.coins = 0;
        permBonuses.doubleJump = false;
        permBonuses.extraLives = 0;
        permBonuses.airDash = false;
      }
      updateCoinsDisplay();
      updateDojoUI();
    } catch (err) {
      console.error('Failed to load user data:', err);
      G.coins = 0;
      permBonuses.doubleJump = false;
      permBonuses.extraLives = 0;
      permBonuses.airDash = false;
    }
  }

  // Save user data to Firebase Database
  async function saveUserData() {
    if (!currentUser || !currentUser.uid) return;
    try {
      await database.ref(`users/${currentUser.uid}`).update({
        coins: G.coins,
        doubleJump: permBonuses.doubleJump,
        extraLives: permBonuses.extraLives,
        airDash: permBonuses.airDash
      });
    } catch (err) {
      console.error('Failed to save user data:', err);
    }
  }

  // Update coins display everywhere
  function updateCoinsDisplay() {
    coinPill.textContent = `ü™ô ${G.coins}`;
    charSelectCoins.textContent = `ü™ô ${G.coins}`;
    dojoCoins.textContent = `ü™ô ${G.coins}`;
  }

  // Update Dojo UI based on bonuses and coins
  function updateDojoUI() {
    // Double Jump
    if (permBonuses.doubleJump) {
      dojoDoubleJump.classList.add('owned');
      dojoDoubleJump.classList.remove('cant-afford');
      dojoDoubleJumpStatus.textContent = '‚úì Sahipsin';
      buyDoubleJump.textContent = '‚úì Alƒ±ndƒ±';
      buyDoubleJump.classList.add('owned');
      buyDoubleJump.disabled = true;
    } else if (G.coins >= 3000) {
      dojoDoubleJump.classList.remove('owned', 'cant-afford');
      dojoDoubleJumpStatus.textContent = '';
      buyDoubleJump.textContent = 'Satƒ±n Al';
      buyDoubleJump.classList.remove('owned');
      buyDoubleJump.disabled = false;
    } else {
      dojoDoubleJump.classList.remove('owned');
      dojoDoubleJump.classList.add('cant-afford');
      dojoDoubleJumpStatus.textContent = '';
      buyDoubleJump.textContent = 'Satƒ±n Al';
      buyDoubleJump.classList.remove('owned');
      buyDoubleJump.disabled = true;
    }

    // Extra Lives
    dojoExtraLifeStatus.textContent = `Mevcut: +${permBonuses.extraLives} can`;
    if (G.coins >= 3000) {
      dojoExtraLife.classList.remove('cant-afford');
      buyExtraLife.disabled = false;
    } else {
      dojoExtraLife.classList.add('cant-afford');
      buyExtraLife.disabled = true;
    }

    // Air Dash
    if (permBonuses.airDash) {
      dojoAirDash.classList.add('owned');
      dojoAirDash.classList.remove('cant-afford');
      dojoAirDashStatus.textContent = '‚úì Sahipsin';
      buyAirDash.textContent = '‚úì Alƒ±ndƒ±';
      buyAirDash.classList.add('owned');
      buyAirDash.disabled = true;
    } else if (G.coins >= 3000) {
      dojoAirDash.classList.remove('owned', 'cant-afford');
      dojoAirDashStatus.textContent = '';
      buyAirDash.textContent = 'Satƒ±n Al';
      buyAirDash.classList.remove('owned');
      buyAirDash.disabled = false;
    } else {
      dojoAirDash.classList.remove('owned');
      dojoAirDash.classList.add('cant-afford');
      dojoAirDashStatus.textContent = '';
      buyAirDash.textContent = 'Satƒ±n Al';
      buyAirDash.classList.remove('owned');
      buyAirDash.disabled = true;
    }
  }

  // Dojo purchase handlers
  buyDoubleJump.addEventListener('click', async () => {
    if (permBonuses.doubleJump || G.coins < 3000) return;
    G.coins -= 3000;
    permBonuses.doubleJump = true;
    await saveUserData();
    updateCoinsDisplay();
    updateDojoUI();
  });

  buyExtraLife.addEventListener('click', async () => {
    if (G.coins < 3000) return;
    G.coins -= 3000;
    permBonuses.extraLives += 1;
    await saveUserData();
    updateCoinsDisplay();
    updateDojoUI();
  });

  buyAirDash.addEventListener('click', async () => {
    if (permBonuses.airDash || G.coins < 3000) return;
    G.coins -= 3000;
    permBonuses.airDash = true;
    await saveUserData();
    updateCoinsDisplay();
    updateDojoUI();
  });

  // Dojo open/close
  dojoBtn.addEventListener('click', () => {
    updateDojoUI();
    dojoOverlay.classList.add('active');
  });

  dojoClose.addEventListener('click', () => {
    dojoOverlay.classList.remove('active');
  });

  // ===== ARENA FUNCTIONS =====
  
  // Generate random room code
  function generateRoomCode() {
    const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
    let code = '';
    for (let i = 0; i < 6; i++) {
      code += chars[Math.floor(Math.random() * chars.length)];
    }
    return code;
  }

  // Open arena overlay
  arenaBtn.addEventListener('click', () => {
    if (!selectedChar) {
      alert('√ñnce bir karakter se√ß!');
      return;
    }
    arenaOverlay.classList.add('active');
    arenaMenu.style.display = 'block';
    arenaLobby.classList.remove('active');
    loadArenaRooms();
  });

  arenaClose.addEventListener('click', () => {
    arenaOverlay.classList.remove('active');
  });

  // ===== WebRTC Configuration =====
  const rtcConfig = {
    iceServers: [
      { urls: 'stun:stun.l.google.com:19302' },
      { urls: 'stun:stun1.l.google.com:19302' },
      { urls: 'stun:stun2.l.google.com:19302' }
    ]
  };

  // Create WebRTC peer connection
  function createPeerConnection() {
    const pc = new RTCPeerConnection(rtcConfig);
    
    pc.onicecandidate = async (event) => {
      if (event.candidate && arenaState.roomId) {
        // Send ICE candidate to Firebase
        const path = arenaState.isHost ? 'hostCandidates' : 'guestCandidates';
        try {
          await fetch(`${FIREBASE_URL}/arena/${arenaState.roomId}/${path}.json`, {
            method: 'POST',
            body: JSON.stringify(event.candidate.toJSON())
          });
        } catch (err) {
          console.error('Failed to send ICE candidate:', err);
        }
      }
    };

    pc.onconnectionstatechange = () => {
      console.log('WebRTC connection state:', pc.connectionState);
      if (pc.connectionState === 'connected') {
        arenaState.isConnected = true;
        console.log('üéÆ WebRTC P2P baƒülantƒ±sƒ± kuruldu!');
      } else if (pc.connectionState === 'disconnected' || pc.connectionState === 'failed') {
        arenaState.isConnected = false;
        console.log('WebRTC baƒülantƒ±sƒ± kesildi');
      }
    };

    return pc;
  }

  // Setup data channel for game data
  function setupDataChannel(channel) {
    channel.onopen = () => {
      console.log('üì° DataChannel a√ßƒ±ldƒ± - P2P aktif!');
      arenaState.isConnected = true;
    };

    channel.onclose = () => {
      console.log('DataChannel kapandƒ±');
      arenaState.isConnected = false;
    };

    channel.onmessage = (event) => {
      try {
        const data = JSON.parse(event.data);
        handlePeerMessage(data);
      } catch (err) {
        console.error('Failed to parse peer message:', err);
      }
    };

    arenaState.dataChannel = channel;
  }

  // Handle incoming peer messages
  function handlePeerMessage(data) {
    console.log('üì® Peer message received:', data.type, data); // DEBUG
    
    if (data.type === 'position') {
      // Update opponent position and animation state
      arenaState.opponent.targetX = data.x;
      arenaState.opponent.targetY = data.y;
      arenaState.opponent.vx = data.vx || 0;
      arenaState.opponent.vy = data.vy || 0;
      arenaState.opponent.facingRight = data.facingRight;
      arenaState.opponent.crouching = data.crouching || false;
      arenaState.opponent.jumping = data.jumping || false;
      arenaState.opponent.attacking = data.attacking || false;
    } else if (data.type === 'projectile') {
      // Opponent fired a projectile - add it to our view (reversed)
      const proj = {
        ...data.proj,
        x: 480 - data.proj.x, // Mirror X position
        vx: -data.proj.vx,    // Reverse velocity
        isPlayer: false       // It's opponent's projectile
      };
      arenaState.projectiles.push(proj);
    } else if (data.type === 'damage') {
      // We got hit!
      console.log('üí• Received damage:', data.amount, 'Current HP:', arenaState.player.hp);
      arenaState.player.hp -= data.amount;
      console.log('üíî New HP:', arenaState.player.hp);
      
      if (arenaState.player.hp <= 0) {
        arenaState.player.hp = 0;
        console.log('‚ò†Ô∏è We died! Ending match...');
        endArenaMatch(false);
      }
    } else if (data.type === 'matchEnd') {
      // Opponent says match ended
      console.log('üèÅ Match end message received:', data);
      if (data.winner === 'me') {
        // Opponent won, we lost
        endArenaMatch(false);
      }
    }
  }

  // Send data to peer
  function sendToPeer(data) {
    if (arenaState.dataChannel && arenaState.dataChannel.readyState === 'open') {
      arenaState.dataChannel.send(JSON.stringify(data));
    }
  }

  // Poll for ICE candidates from Firebase
  async function pollIceCandidates() {
    if (!arenaState.roomId || !arenaState.peerConnection) return;
    
    const path = arenaState.isHost ? 'guestCandidates' : 'hostCandidates';
    
    try {
      const response = await fetch(`${FIREBASE_URL}/arena/${arenaState.roomId}/${path}.json`);
      const candidates = await response.json();
      
      if (candidates) {
        for (const key of Object.keys(candidates)) {
          const candidate = candidates[key];
          if (candidate && !candidate._added) {
            try {
              await arenaState.peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
              // Mark as added
              await fetch(`${FIREBASE_URL}/arena/${arenaState.roomId}/${path}/${key}/_added.json`, {
                method: 'PUT',
                body: JSON.stringify(true)
              });
            } catch (err) {
              console.error('Failed to add ICE candidate:', err);
            }
          }
        }
      }
    } catch (err) {
      console.error('Failed to poll ICE candidates:', err);
    }
  }

  // Clean up WebRTC
  function cleanupWebRTC() {
    if (arenaState.dataChannel) {
      arenaState.dataChannel.close();
      arenaState.dataChannel = null;
    }
    if (arenaState.peerConnection) {
      arenaState.peerConnection.close();
      arenaState.peerConnection = null;
    }
    arenaState.isConnected = false;
  }

  // Load arena rooms from Firebase
  async function loadArenaRooms() {
    arenaRoomList.innerHTML = '<div class="arena-no-rooms">Y√ºkleniyor...</div>';
    
    try {
      const response = await fetch(`${FIREBASE_URL}/arena.json`);
      const data = await response.json();
      
      if (!data) {
        arenaRoomList.innerHTML = '<div class="arena-no-rooms">Hen√ºz oda yok. ƒ∞lk sen olu≈ütur!</div>';
        return;
      }
      
      // Filter only waiting rooms
      const rooms = Object.entries(data).filter(([id, room]) => 
        room && room.status === 'waiting' && room.host
      );
      
      if (rooms.length === 0) {
        arenaRoomList.innerHTML = '<div class="arena-no-rooms">Bekleyen oda yok. Yeni bir oda olu≈ütur!</div>';
        return;
      }
      
      arenaRoomList.innerHTML = '';
      rooms.forEach(([roomId, room]) => {
        const roomEl = document.createElement('div');
        roomEl.className = 'arena-room-item';
        roomEl.innerHTML = `
          <div class="arena-room-info">
            <div class="arena-room-host">${room.host.name}</div>
            <div class="arena-room-char">${CHARACTERS[room.host.charKey]?.name || room.host.charKey}</div>
          </div>
          <div class="arena-room-status waiting">Bekliyor</div>
        `;
        roomEl.addEventListener('click', () => joinArenaRoom(roomId, room));
        arenaRoomList.appendChild(roomEl);
      });
    } catch (err) {
      console.error('Failed to load arena rooms:', err);
      arenaRoomList.innerHTML = '<div class="arena-no-rooms">Baƒülantƒ± hatasƒ±!</div>';
    }
  }

  // Create a new arena room
  arenaCreateRoom.addEventListener('click', async () => {
    if (!selectedChar || !currentUser) {
      alert('√ñnce giri≈ü yap ve karakter se√ß!');
      return;
    }
    
    const roomId = generateRoomCode();
    
    // Create WebRTC peer connection as host
    cleanupWebRTC();
    arenaState.peerConnection = createPeerConnection();
    
    // Host creates the data channel
    const dataChannel = arenaState.peerConnection.createDataChannel('arena', {
      ordered: false, // UDP-like for lower latency
      maxRetransmits: 0
    });
    setupDataChannel(dataChannel);
    
    // Create offer
    const offer = await arenaState.peerConnection.createOffer();
    await arenaState.peerConnection.setLocalDescription(offer);
    
    const roomData = {
      host: {
        name: currentUser.username,
        charKey: selectedChar,
        ready: false,
        hp: 100,
        x: 100,
        y: 400
      },
      guest: null,
      status: 'waiting',
      createdAt: Date.now(),
      offer: offer.sdp // Store WebRTC offer
    };
    
    try {
      await fetch(`${FIREBASE_URL}/arena/${roomId}.json`, {
        method: 'PUT',
        body: JSON.stringify(roomData)
      });
      
      arenaState.roomId = roomId;
      arenaState.isHost = true;
      arenaState.ready = false;
      
      enterArenaLobby(roomId, roomData, true);
    } catch (err) {
      console.error('Failed to create room:', err);
      alert('Oda olu≈üturulamadƒ±!');
      cleanupWebRTC();
    }
  });

  // Join an existing room
  async function joinArenaRoom(roomId, room) {
    if (!selectedChar || !currentUser) {
      alert('√ñnce giri≈ü yap ve karakter se√ß!');
      return;
    }
    
    // Check if room still exists and is waiting
    try {
      const response = await fetch(`${FIREBASE_URL}/arena/${roomId}.json`);
      const currentRoom = await response.json();
      
      if (!currentRoom || currentRoom.status !== 'waiting') {
        alert('Bu oda artƒ±k mevcut deƒüil!');
        loadArenaRooms();
        return;
      }
      
      if (currentRoom.guest) {
        alert('Bu oda dolu!');
        loadArenaRooms();
        return;
      }
      
      // Create WebRTC peer connection as guest
      cleanupWebRTC();
      arenaState.peerConnection = createPeerConnection();
      
      // Guest receives data channel from host
      arenaState.peerConnection.ondatachannel = (event) => {
        setupDataChannel(event.channel);
      };
      
      // Set remote description (host's offer)
      if (currentRoom.offer) {
        const offerDesc = new RTCSessionDescription({
          type: 'offer',
          sdp: currentRoom.offer
        });
        await arenaState.peerConnection.setRemoteDescription(offerDesc);
        
        // Create and send answer
        const answer = await arenaState.peerConnection.createAnswer();
        await arenaState.peerConnection.setLocalDescription(answer);
        
        // Save answer to Firebase
        await fetch(`${FIREBASE_URL}/arena/${roomId}/answer.json`, {
          method: 'PUT',
          body: JSON.stringify(answer.sdp)
        });
      }
      
      // Join the room
      const guestData = {
        name: currentUser.username,
        charKey: selectedChar,
        ready: false,
        hp: 100,
        x: 380,
        y: 400
      };
      
      await fetch(`${FIREBASE_URL}/arena/${roomId}/guest.json`, {
        method: 'PUT',
        body: JSON.stringify(guestData)
      });
      
      arenaState.roomId = roomId;
      arenaState.isHost = false;
      arenaState.ready = false;
      
      enterArenaLobby(roomId, { ...currentRoom, guest: guestData }, false);
    } catch (err) {
      console.error('Failed to join room:', err);
      alert('Odaya katƒ±lƒ±namadƒ±!');
      cleanupWebRTC();
    }
  }

  // Enter the lobby
  function enterArenaLobby(roomId, room, isHost) {
    arenaMenu.style.display = 'none';
    arenaLobby.classList.add('active');
    arenaRoomCode.textContent = `Oda Kodu: ${roomId}`;
    arenaCountdown.classList.remove('active');
    arenaLobbyButtons.style.display = 'block';
    arenaReadyBtn.textContent = '‚úì Hazƒ±rƒ±m!';
    arenaReadyBtn.classList.remove('ready');
    arenaState.countdownStarted = false; // Reset countdown flag
    
    updateLobbyPlayers(room);
    
    // Start listening to room changes
    startRoomListener(roomId);
  }

  // Update lobby player slots
  function updateLobbyPlayers(room) {
    // Host
    if (room.host) {
      arenaPlayer1.classList.add('filled');
      arenaPlayer1.classList.toggle('ready', room.host.ready);
      arenaPlayer1.innerHTML = `
        <div style="font-size: 40px;">‚öîÔ∏è</div>
        <div class="arena-player-name">${room.host.name}</div>
        <div class="arena-player-char">${CHARACTERS[room.host.charKey]?.name || room.host.charKey}</div>
        ${room.host.ready ? '<div style="color: #4ade80; font-size: 12px;">‚úì Hazƒ±r</div>' : ''}
      `;
    }
    
    // Guest
    if (room.guest) {
      arenaPlayer2.classList.add('filled');
      arenaPlayer2.classList.toggle('ready', room.guest.ready);
      arenaPlayer2.innerHTML = `
        <div style="font-size: 40px;">‚öîÔ∏è</div>
        <div class="arena-player-name">${room.guest.name}</div>
        <div class="arena-player-char">${CHARACTERS[room.guest.charKey]?.name || room.guest.charKey}</div>
        ${room.guest.ready ? '<div style="color: #4ade80; font-size: 12px;">‚úì Hazƒ±r</div>' : ''}
      `;
    } else {
      arenaPlayer2.classList.remove('filled', 'ready');
      arenaPlayer2.innerHTML = `
        <div style="font-size: 40px;">üë§</div>
        <div class="arena-player-name">Bekleniyor...</div>
        <div class="arena-player-char"></div>
      `;
    }
  }

  // Start listening to room changes
  function startRoomListener(roomId) {
    // Stop any existing listener
    if (arenaState.listener) {
      clearInterval(arenaState.listener);
    }
    
    let answerProcessed = false;
    
    // Poll for changes every 500ms
    arenaState.listener = setInterval(async () => {
      try {
        const response = await fetch(`${FIREBASE_URL}/arena/${roomId}.json`);
        const room = await response.json();
        
        console.log('Room state:', room); // DEBUG
        
        if (!room) {
          // Room deleted
          alert('Oda silindi!');
          leaveArenaRoom();
          return;
        }
        
        updateLobbyPlayers(room);
        
        // WebRTC: Host receives answer from guest
        if (arenaState.isHost && room.answer && !answerProcessed && arenaState.peerConnection) {
          answerProcessed = true;
          try {
            const answerDesc = new RTCSessionDescription({
              type: 'answer',
              sdp: room.answer
            });
            await arenaState.peerConnection.setRemoteDescription(answerDesc);
            console.log('WebRTC: Answer received and set');
          } catch (err) {
            console.error('Failed to set answer:', err);
          }
        }
        
        // Poll ICE candidates
        await pollIceCandidates();
        
        // Show WebRTC connection status
        if (arenaState.isConnected) {
          arenaRoomCode.textContent = `Oda: ${roomId} üü¢ P2P Baƒülƒ±`;
        } else if (room.guest) {
          arenaRoomCode.textContent = `Oda: ${roomId} üü° Baƒülanƒ±yor...`;
        }
        
        // Check if both players are ready
        if (room.host?.ready && room.guest?.ready && room.status === 'waiting') {
          console.log('Both players ready! Starting countdown...'); // DEBUG
          // Start countdown - only once
          if (!arenaState.countdownStarted && !arenaState.inMatch) {
            arenaState.countdownStarted = true;
            startArenaCountdown(roomId, room);
          }
        }
        
        // Check if match started
        if (room.status === 'playing' && !arenaState.inMatch) {
          console.log('Match starting!'); // DEBUG
          startArenaMatch(roomId, room);
        }
        
      } catch (err) {
        console.error('Room listener error:', err);
      }
    }, 500);
  }

  // Ready button
  arenaReadyBtn.addEventListener('click', async () => {
    if (!arenaState.roomId) return;
    
    arenaState.ready = !arenaState.ready;
    
    const playerPath = arenaState.isHost ? 'host' : 'guest';
    
    try {
      await fetch(`${FIREBASE_URL}/arena/${arenaState.roomId}/${playerPath}/ready.json`, {
        method: 'PUT',
        body: JSON.stringify(arenaState.ready)
      });
      
      arenaReadyBtn.textContent = arenaState.ready ? '‚úó ƒ∞ptal' : '‚úì Hazƒ±rƒ±m!';
      arenaReadyBtn.classList.toggle('ready', arenaState.ready);
    } catch (err) {
      console.error('Failed to update ready state:', err);
    }
  });

  // Leave room
  arenaLeaveRoom.addEventListener('click', () => {
    leaveArenaRoom();
  });

  async function leaveArenaRoom() {
    if (arenaState.listener) {
      clearInterval(arenaState.listener);
      arenaState.listener = null;
    }
    
    // Clean up WebRTC
    cleanupWebRTC();
    
    if (arenaState.roomId) {
      try {
        if (arenaState.isHost) {
          // Delete the room
          await fetch(`${FIREBASE_URL}/arena/${arenaState.roomId}.json`, {
            method: 'DELETE'
          });
        } else {
          // Remove guest
          await fetch(`${FIREBASE_URL}/arena/${arenaState.roomId}/guest.json`, {
            method: 'DELETE'
          });
        }
      } catch (err) {
        console.error('Failed to leave room:', err);
      }
    }
    
    arenaState.roomId = null;
    arenaState.isHost = false;
    arenaState.ready = false;
    arenaState.inMatch = false;
    arenaState.countdownStarted = false;
    
    arenaLobby.classList.remove('active');
    arenaMenu.style.display = 'block';
    loadArenaRooms();
  }

  // Start countdown when both ready
  async function startArenaCountdown(roomId, room) {
    arenaLobbyButtons.style.display = 'none';
    arenaCountdown.classList.add('active');
    
    let count = 3;
    arenaCountdown.textContent = count;
    
    const countInterval = setInterval(async () => {
      count--;
      if (count > 0) {
        arenaCountdown.textContent = count;
      } else {
        clearInterval(countInterval);
        arenaCountdown.textContent = 'SAVA≈û!';
        
        // Host sets status to playing
        if (arenaState.isHost) {
          await fetch(`${FIREBASE_URL}/arena/${roomId}/status.json`, {
            method: 'PUT',
            body: JSON.stringify('playing')
          });
        }
      }
    }, 1000);
  }

  // Start the arena match
  function startArenaMatch(roomId, room) {
    console.log('Starting arena match!'); // DEBUG
    arenaState.inMatch = true;
    arenaOverlay.classList.remove('active');
    
    // Show game screen with canvas
    Object.values(screens).forEach(s => s.classList.remove('active'));
    screens.game.classList.add('active');
    
    // Set up arena match state
    const myData = arenaState.isHost ? room.host : room.guest;
    const oppData = arenaState.isHost ? room.guest : room.host;
    
    arenaState.player = {
      x: arenaState.isHost ? 100 : 380,
      y: 460,
      hp: 100,
      maxHp: 100,
      vx: 0,
      vy: 0,
      facingRight: arenaState.isHost,
      attacking: false,
      attackTimer: 0,
      skillXCooldown: 0,
      skillFCooldown: 0,
      stunned: 0,
      invincible: 0,
      charKey: selectedChar
    };
    
    arenaState.opponent = {
      x: arenaState.isHost ? 380 : 100,
      y: 460,
      targetX: arenaState.isHost ? 380 : 100,
      targetY: 460,
      hp: 100,
      maxHp: 100,
      charKey: oppData.charKey,
      name: oppData.name,
      facingRight: !arenaState.isHost
    };
    
    arenaState.projectiles = [];
    arenaState.particles = [];
    arenaState.active = true;
    arenaLastTime = performance.now();
    
    // Start arena game loop
    console.log('Starting arena game loop'); // DEBUG
    requestAnimationFrame(arenaGameLoop);
  }

  // Arena game loop
  let arenaLastTime = 0;
  function arenaGameLoop(timestamp) {
    if (!arenaState.active) return;
    
    const dt = Math.min((timestamp - arenaLastTime) / 1000, 0.05);
    arenaLastTime = timestamp;
    
    updateArena(dt);
    drawArena();
    syncArenaState();
    
    requestAnimationFrame(arenaGameLoop);
  }

  // Arena input state
  const arenaKeys = {
    left: false,
    right: false,
    up: false,
    down: false,
    x: false,
    c: false
  };

  // Arena keyboard controls
  document.addEventListener('keydown', (e) => {
    if (!arenaState.active) return;
    
    if (e.key === 'ArrowLeft' || e.key === 'a') arenaKeys.left = true;
    if (e.key === 'ArrowRight' || e.key === 'd') arenaKeys.right = true;
    if (e.key === 'ArrowUp' || e.key === 'w' || e.key === ' ') arenaKeys.up = true;
    if (e.key === 'ArrowDown' || e.key === 's') arenaKeys.down = true;
    if (e.key === 'x' || e.key === 'X') {
      arenaKeys.x = true;
      arenaUseSkillX();
    }
    if (e.key === 'c' || e.key === 'C') {
      arenaKeys.c = true;
      arenaUseSkillF();
    }
  });

  document.addEventListener('keyup', (e) => {
    if (e.key === 'ArrowLeft' || e.key === 'a') arenaKeys.left = false;
    if (e.key === 'ArrowRight' || e.key === 'd') arenaKeys.right = false;
    if (e.key === 'ArrowUp' || e.key === 'w' || e.key === ' ') arenaKeys.up = false;
    if (e.key === 'ArrowDown' || e.key === 's') arenaKeys.down = false;
    if (e.key === 'x' || e.key === 'X') arenaKeys.x = false;
    if (e.key === 'c' || e.key === 'C') arenaKeys.c = false;
  });

  // Arena update
  function updateArena(dt) {
    // Update time for animations
    G.t += dt;
    
    const p = arenaState.player;
    const opp = arenaState.opponent;
    
    // Interpolate opponent position for smooth movement
    const lerpSpeed = 12; // Higher = faster catch up
    opp.x += (opp.targetX - opp.x) * Math.min(1, lerpSpeed * dt);
    opp.y += (opp.targetY - opp.y) * Math.min(1, lerpSpeed * dt);
    
    // Movement
    if (p.stunned <= 0) {
      if (arenaKeys.left) {
        p.vx = -300;
        p.facingRight = false;
      } else if (arenaKeys.right) {
        p.vx = 300;
        p.facingRight = true;
      } else {
        p.vx *= 0.8;
      }
      
      // Jump
      if (arenaKeys.up && p.y >= 460) {
        p.vy = -600;
      }
    }
    
    // Gravity
    p.vy += 1500 * dt;
    p.x += p.vx * dt;
    p.y += p.vy * dt;
    
    // Bounds
    if (p.x < 20) p.x = 20;
    if (p.x > 460) p.x = 460;
    if (p.y > 460) {
      p.y = 460;
      p.vy = 0;
    }
    
    // Cooldowns
    if (p.skillXCooldown > 0) p.skillXCooldown -= dt;
    if (p.skillFCooldown > 0) p.skillFCooldown -= dt;
    if (p.stunned > 0) p.stunned -= dt;
    if (p.invincible > 0) p.invincible -= dt;
    if (p.attackTimer > 0) p.attackTimer -= dt;
    
    // Update projectiles
    arenaState.projectiles = arenaState.projectiles.filter(proj => {
      proj.x += proj.vx * dt;
      proj.y += (proj.vy || 0) * dt;
      proj.life -= dt;
      
      // Check collision with opponent (use interpolated position)
      if (proj.isPlayer) {
        if (Math.abs(proj.x - opp.x) < 40 && Math.abs(proj.y - opp.y) < 60) {
          // Hit opponent
          damageOpponent(proj.damage || 10);
          return false;
        }
      }
      
      return proj.life > 0 && proj.x > 0 && proj.x < 480;
    });
    
    // Update particles
    arenaState.particles = arenaState.particles.filter(part => {
      part.x += part.vx * dt;
      part.y += part.vy * dt;
      part.life -= dt;
      return part.life > 0;
    });
  }

  // Use X skill in arena
  function arenaUseSkillX() {
    const p = arenaState.player;
    if (p.skillXCooldown > 0 || p.stunned > 0) return;
    
    const char = CHARACTERS[p.charKey];
    if (!char) return;
    
    p.skillXCooldown = char.skillX.cooldown;
    p.attacking = true;
    p.attackTimer = 0.3;
    
    const projX = p.facingRight ? p.x + 40 : p.x - 40;
    const projVx = p.facingRight ? 500 : -500;
    
    // Create projectile based on character's skill
    const skillAction = char.skillX.action;
    let projData = {
      x: projX,
      y: p.y - 30,
      vx: projVx,
      vy: 0,
      life: 1.5,
      damage: 15,
      isPlayer: true,
      type: skillAction,
      color: char.color,
      radius: 12
    };
    
    // Character-specific projectiles
    if (skillAction === 'shuriken') {
      projData.radius = 10;
      projData.spin = 0;
      projData.damage = 12;
    } else if (skillAction === 'spearExtend') {
      projData.radius = 8;
      projData.w = 80;
      projData.h = 6;
      projData.damage = 18;
    } else if (skillAction === 'waterBall') {
      projData.radius = 14;
      projData.color = '#3498db';
      projData.damage = 14;
    } else if (skillAction === 'katanaSlash') {
      projData.radius = 20;
      projData.color = '#e0e0e0';
      projData.damage = 20;
      projData.life = 0.3;
      projData.vx = projVx * 0.5;
    } else if (skillAction === 'punch') {
      projData.radius = 18;
      projData.color = '#f39c12';
      projData.damage = 22;
      projData.life = 0.25;
      projData.vx = projVx * 0.3;
    } else if (skillAction === 'poisonShot') {
      // Teki: Poison shot
      projData.color = '#2ecc71';
      projData.radius = 12;
      projData.damage = 15;
    } else if (skillAction === 'needleThrow') {
      // Susumu: Needle throw - multiple needles
      projData.color = '#c0392b';
      projData.radius = 5;
      projData.damage = 8;
      for (let i = 0; i < 5; i++) {
        arenaState.projectiles.push({
          ...projData,
          y: p.y - 30 + (i - 2) * 15,
          vx: projVx * (0.9 + i * 0.05)
        });
      }
      return;
    } else if (skillAction === 'eyeBeam') {
      // Shinji: Eye beam
      projData.color = '#9b59b6';
      projData.radius = 14;
      projData.damage = 18;
      projData.vx = projVx * 1.2;
    } else if (skillAction === 'illusionKill') {
      projData.color = '#9b59b6';
      projData.radius = 16;
      projData.damage = 16;
    } else if (skillAction === 'windWave') {
      projData.color = '#87ceeb';
      projData.radius = 18;
      projData.damage = 14;
    } else if (skillAction === 'crowFeather') {
      projData.color = '#2c3e50';
      projData.radius = 10;
      projData.damage = 12;
    } else if (skillAction === 'paperThrow') {
      projData.color = '#ecf0f1';
      projData.radius = 8;
      projData.damage = 10;
      projData.vx = projVx * 1.2;
    } else if (skillAction === 'kissThrow') {
      projData.color = '#ff69b4';
      projData.radius = 12;
      projData.damage = 14;
    } else if (skillAction === 'arrowShot') {
      projData.color = '#fff';
      projData.radius = 6;
      projData.damage = 16;
      projData.vx = projVx * 1.4;
    } else if (skillAction === 'kunaiThrow') {
      projData.color = '#555';
      projData.radius = 8;
      projData.damage = 14;
      projData.vx = projVx * 1.3;
    }
    
    arenaState.projectiles.push(projData);
    
    // Particles
    for (let i = 0; i < 8; i++) {
      arenaState.particles.push({
        x: projX,
        y: p.y - 30,
        vx: rand(-50, 50) + projVx * 0.3,
        vy: rand(-80, 80),
        life: rand(0.2, 0.4),
        color: char.color
      });
    }
  }

  // Use F skill (ultimate) in arena
  function arenaUseSkillF() {
    const p = arenaState.player;
    if (p.skillFCooldown > 0 || p.stunned > 0) return;
    
    const char = CHARACTERS[p.charKey];
    if (!char) return;
    
    p.skillFCooldown = char.skillF.cooldown;
    
    const projX = p.facingRight ? p.x + 40 : p.x - 40;
    const projVx = p.facingRight ? 350 : -350;
    
    const skillAction = char.skillF.action;
    
    // Character-specific ultimate projectiles
    if (skillAction === 'eagleFlight') {
      // Ringo: Big eagle projectile
      arenaState.projectiles.push({
        x: projX, y: p.y - 30, vx: projVx, vy: 0,
        life: 2.5, damage: 40, isPlayer: true,
        type: 'eagle', color: '#8b5cf6', radius: 30
      });
    } else if (skillAction === 'moonlight') {
      // Haru: Beam of light
      for (let i = 0; i < 5; i++) {
        arenaState.projectiles.push({
          x: projX + i * 30, y: p.y - 30 + (i - 2) * 15,
          vx: projVx, vy: 0, life: 1.5, damage: 15,
          isPlayer: true, type: 'moonlight', color: '#fff', radius: 15
        });
      }
    } else if (skillAction === 'iceStorm') {
      // Usagi: Multiple ice shards
      for (let i = 0; i < 8; i++) {
        arenaState.projectiles.push({
          x: projX, y: p.y - 30,
          vx: projVx * (0.7 + Math.random() * 0.6),
          vy: rand(-200, 200),
          life: 2, damage: 12, isPlayer: true,
          type: 'ice', color: '#67e8f9', radius: 10
        });
      }
    } else if (skillAction === 'swordStorm') {
      // Chisa: Spinning sword wave
      arenaState.projectiles.push({
        x: projX, y: p.y - 30, vx: projVx * 0.8, vy: 0,
        life: 2, damage: 50, isPlayer: true,
        type: 'swordStorm', color: '#e74c3c', radius: 35
      });
    } else if (skillAction === 'headbutt') {
      // Butsuo: Charging attack
      arenaState.projectiles.push({
        x: projX, y: p.y - 20, vx: projVx * 1.5, vy: 0,
        life: 1.5, damage: 55, isPlayer: true,
        type: 'headbutt', color: '#ecf0f1', radius: 40
      });
    } else if (skillAction === 'monkeyFriend') {
      // Teki: Monkey friend attack
      arenaState.projectiles.push({
        x: projX, y: p.y - 30, vx: projVx * 1.2, vy: 0,
        life: 3, damage: 35, isPlayer: true,
        type: 'monkey', color: '#8b4513', radius: 25
      });
      // Monkey throws bananas
      for (let i = 0; i < 4; i++) {
        setTimeout(() => {
          if (!arenaState.active) return;
          arenaState.projectiles.push({
            x: projX + (p.facingRight ? 50 : -50),
            y: p.y - 40,
            vx: projVx * 0.8,
            vy: rand(-150, 150),
            life: 1.5, damage: 10, isPlayer: true,
            type: 'banana', color: '#f1c40f', radius: 8
          });
        }, i * 300);
      }
    } else if (skillAction === 'animalFriends') {
      // Susumu: Animal stampede
      for (let i = 0; i < 4; i++) {
        arenaState.projectiles.push({
          x: projX - i * 40, y: p.y - 20 + rand(-20, 20),
          vx: projVx * (1 + i * 0.1), vy: 0,
          life: 2, damage: 15, isPlayer: true,
          type: 'animal', color: '#8b4513', radius: 20
        });
      }
    } else if (skillAction === 'illusionStorm') {
      // Shinji: Multiple illusions
      for (let i = 0; i < 5; i++) {
        arenaState.projectiles.push({
          x: projX, y: p.y - 30 + (i - 2) * 25,
          vx: projVx, vy: rand(-30, 30),
          life: 2, damage: 12, isPlayer: true,
          type: 'illusion', color: '#9b59b6', radius: 14
        });
      }
    } else if (skillAction === 'windSword') {
      // Kazuya: Giant wind blade
      arenaState.projectiles.push({
        x: projX, y: p.y - 30, vx: projVx * 1.2, vy: 0,
        life: 2, damage: 45, isPlayer: true,
        type: 'windSword', color: '#3498db', radius: 35
      });
    } else if (skillAction === 'darkAura') {
      // Togami: Dark crow attack
      arenaState.projectiles.push({
        x: projX, y: p.y - 40, vx: projVx, vy: 0,
        life: 2.5, damage: 40, isPlayer: true,
        type: 'darkCrow', color: '#1a1a1a', radius: 30
      });
    } else if (skillAction === 'paperWings') {
      // Kagi: Paper storm
      for (let i = 0; i < 10; i++) {
        arenaState.projectiles.push({
          x: projX + rand(-20, 20), y: p.y - 30 + rand(-40, 40),
          vx: projVx * (0.8 + Math.random() * 0.4),
          vy: rand(-100, 100),
          life: 2, damage: 8, isPlayer: true,
          type: 'paper', color: '#ecf0f1', radius: 8
        });
      }
    } else if (skillAction === 'fireDragon') {
      // Akemi: Fire dragon breath
      arenaState.projectiles.push({
        x: projX, y: p.y - 30, vx: projVx, vy: 0,
        life: 2.5, damage: 50, isPlayer: true,
        type: 'fireDragon', color: '#e74c3c', radius: 40
      });
    } else if (skillAction === 'mysticLightning') {
      // Ryoken: Lightning bolts
      for (let i = 0; i < 3; i++) {
        arenaState.projectiles.push({
          x: projX, y: p.y - 30,
          vx: projVx * (1 + i * 0.2), vy: (i - 1) * 100,
          life: 1.5, damage: 20, isPlayer: true,
          type: 'lightning', color: '#f1c40f', radius: 12
        });
      }
    } else if (skillAction === 'arrowRain') {
      // Riku: Arrow rain
      for (let i = 0; i < 8; i++) {
        arenaState.projectiles.push({
          x: projX + i * 10, y: p.y - 60 - i * 20,
          vx: projVx * 0.8, vy: 200 + i * 30,
          life: 2, damage: 10, isPlayer: true,
          type: 'arrow', color: '#fff', radius: 6
        });
      }
    } else if (skillAction === 'shadowClone') {
      // Joaryu: Shadow clones attack
      for (let i = 0; i < 3; i++) {
        arenaState.projectiles.push({
          x: projX, y: p.y - 30 + (i - 1) * 30,
          vx: projVx * (0.9 + i * 0.1), vy: 0,
          life: 2, damage: 18, isPlayer: true,
          type: 'shadowClone', color: '#8e44ad', radius: 20
        });
      }
    } else {
      // Default ultimate
      arenaState.projectiles.push({
        x: projX, y: p.y - 30, vx: projVx, vy: 0,
        life: 2, damage: 35, isPlayer: true,
        type: 'ultimate', color: char.color, radius: 25
      });
    }
    
    // Big particle burst
    for (let i = 0; i < 20; i++) {
      arenaState.particles.push({
        x: projX,
        y: p.y - 30,
        vx: rand(-150, 150) + projVx * 0.2,
        vy: rand(-150, 150),
        life: rand(0.3, 0.6),
        color: char.color
      });
    }
  }

  // Damage opponent
  async function damageOpponent(damage) {
    console.log('‚öîÔ∏è Dealing damage:', damage, 'WebRTC connected:', arenaState.isConnected);
    
    // Send damage via WebRTC (instant!)
    if (arenaState.isConnected && arenaState.dataChannel?.readyState === 'open') {
      console.log('üì§ Sending damage via WebRTC');
      sendToPeer({ type: 'damage', amount: damage });
      arenaState.opponent.hp -= damage; // Local prediction
      
      if (arenaState.opponent.hp <= 0) {
        arenaState.opponent.hp = 0;
        endArenaMatch(true);
      }
      return;
    }
    
    // Fallback to Firebase - write pendingDamage for opponent to read
    console.log('üì§ Sending damage via Firebase fallback');
    arenaState.opponent.hp -= damage; // Local prediction
    
    if (arenaState.roomId) {
      const myPath = arenaState.isHost ? 'host' : 'guest';
      const oppPath = arenaState.isHost ? 'guest' : 'host';
      try {
        // Write damage to opponent's pendingDamage field
        const response = await fetch(`${FIREBASE_URL}/arena/${arenaState.roomId}/${oppPath}/pendingDamage.json`);
        const currentDamage = await response.json() || 0;
        
        await fetch(`${FIREBASE_URL}/arena/${arenaState.roomId}/${oppPath}/pendingDamage.json`, {
          method: 'PUT',
          body: JSON.stringify(currentDamage + damage)
        });
      } catch (err) {
        console.error('Failed to sync damage:', err);
      }
    }
    
    // Check for win
    if (arenaState.opponent.hp <= 0) {
      endArenaMatch(true);
    }
  }

  // Sync player state via WebRTC (or fallback to Firebase)
  let lastSyncTime = 0;
  async function syncArenaState() {
    if (!arenaState.roomId || !arenaState.active) return;
    
    const now = Date.now();
    if (now - lastSyncTime < 16) return; // ~60fps for WebRTC, will be throttled for Firebase
    lastSyncTime = now;
    
    const p = arenaState.player;
    
    // Use WebRTC if connected (much faster!)
    if (arenaState.isConnected && arenaState.dataChannel?.readyState === 'open') {
      // Send position via P2P - super fast!
      sendToPeer({
        type: 'position',
        x: Math.round(p.x),
        y: Math.round(p.y),
        vx: Math.round(p.vx || 0),
        vy: Math.round(p.vy || 0),
        hp: p.hp,
        facingRight: p.facingRight,
        crouching: arenaKeys.down,
        jumping: p.y < 460,
        attacking: p.attacking || false
      });
      return; // Don't use Firebase when WebRTC is active
    }
    
    // Fallback to Firebase (slower, only if WebRTC not available)
    if (now - lastSyncTime < 100) return; // Throttle Firebase to 100ms
    
    const playerPath = arenaState.isHost ? 'host' : 'guest';
    
    try {
      await fetch(`${FIREBASE_URL}/arena/${arenaState.roomId}/${playerPath}.json`, {
        method: 'PATCH',
        body: JSON.stringify({
          x: Math.round(p.x),
          y: Math.round(p.y),
          hp: p.hp,
          facingRight: p.facingRight
        })
      });
      
      // Also fetch opponent state, our pending damage, and room status
      const oppPath = arenaState.isHost ? 'guest' : 'host';
      const [oppResponse, myDataResponse, roomResponse] = await Promise.all([
        fetch(`${FIREBASE_URL}/arena/${arenaState.roomId}/${oppPath}.json`),
        fetch(`${FIREBASE_URL}/arena/${arenaState.roomId}/${playerPath}.json`),
        fetch(`${FIREBASE_URL}/arena/${arenaState.roomId}/status.json`)
      ]);
      const oppData = await oppResponse.json();
      const myData = await myDataResponse.json();
      const roomStatus = await roomResponse.json();
      
      // Check if match was ended by opponent
      if (roomStatus === 'finished') {
        endArenaMatch(false);
        return;
      }
      
      // Check for pending damage from opponent
      if (myData?.pendingDamage && myData.pendingDamage > 0) {
        arenaState.player.hp -= myData.pendingDamage;
        console.log('Received damage:', myData.pendingDamage, 'HP now:', arenaState.player.hp);
        
        // Clear pending damage
        await fetch(`${FIREBASE_URL}/arena/${arenaState.roomId}/${playerPath}/pendingDamage.json`, {
          method: 'PUT',
          body: JSON.stringify(0)
        });
        
        if (arenaState.player.hp <= 0) {
          arenaState.player.hp = 0;
          endArenaMatch(false);
          return;
        }
      }
      
      if (oppData) {
        arenaState.opponent.targetX = oppData.x ?? arenaState.opponent.targetX;
        arenaState.opponent.targetY = oppData.y ?? arenaState.opponent.targetY;
        arenaState.opponent.facingRight = oppData.facingRight ?? arenaState.opponent.facingRight;
        
        // Don't override opponent HP from Firebase - we track it locally from damage
      }
    } catch (err) {
      if (!arenaState.active) return;
      console.error('Sync error:', err);
    }
  }

  // End arena match
  async function endArenaMatch(won) {
    if (!arenaState.active) return; // Prevent double calls
    arenaState.active = false;
    
    // Notify opponent via WebRTC
    if (arenaState.isConnected) {
      sendToPeer({ type: 'matchEnd', winner: won ? 'me' : 'opponent' });
    }
    
    // Clean up WebRTC
    cleanupWebRTC();
    
    if (arenaState.listener) {
      clearInterval(arenaState.listener);
      arenaState.listener = null;
    }
    
    // Mark room as finished in Firebase so opponent knows (fallback)
    if (arenaState.roomId && won) {
      try {
        await fetch(`${FIREBASE_URL}/arena/${arenaState.roomId}/status.json`, {
          method: 'PUT',
          body: JSON.stringify('finished')
        });
      } catch (err) {
        console.error('Error marking room finished:', err);
      }
    }
    
    // Show result on canvas
    const resultText = won ? 'üèÜ KAZANDIN!' : 'üíÄ KAYBETTƒ∞N!';
    
    // Draw result overlay
    ctx.fillStyle = 'rgba(0,0,0,0.8)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    ctx.fillStyle = won ? '#ffd700' : '#ff4444';
    ctx.font = 'bold 48px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText(resultText, canvas.width / 2, canvas.height / 2 - 30);
    
    ctx.fillStyle = '#fff';
    ctx.font = '24px sans-serif';
    ctx.fillText('Devam etmek i√ßin tƒ±kla', canvas.width / 2, canvas.height / 2 + 30);
    
    // Wait for click to continue
    const handleClick = () => {
      canvas.removeEventListener('click', handleClick);
      
      // Clean up room
      if (arenaState.roomId) {
        fetch(`${FIREBASE_URL}/arena/${arenaState.roomId}.json`, {
          method: 'DELETE'
        }).catch(() => {});
      }
      
      arenaState.roomId = null;
      arenaState.isHost = false;
      arenaState.ready = false;
      arenaState.inMatch = false;
      arenaState.countdownStarted = false;
      
      // Go back to character select
      showScreen('charSelect');
    };
    
    setTimeout(() => {
      canvas.addEventListener('click', handleClick);
    }, 500);
  }

  // Draw arena
  function drawArena() {
    // Forest background (from LOCATIONS.forest)
    const grad = ctx.createLinearGradient(0, 0, 0, canvas.height);
    grad.addColorStop(0, '#87ceeb');
    grad.addColorStop(0.4, '#98d8c8');
    grad.addColorStop(0.7, '#2d5016');
    grad.addColorStop(1, '#1a3009');
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Sun
    ctx.fillStyle = '#fff8dc';
    ctx.shadowColor = '#ffd700';
    ctx.shadowBlur = 40;
    ctx.beginPath();
    ctx.arc(400, 80, 35, 0, Math.PI * 2);
    ctx.fill();
    ctx.shadowBlur = 0;
    
    // Background trees
    drawArenaTrees();
    
    // Arena ground (forest floor)
    ctx.fillStyle = 'rgba(34,100,34,0.9)';
    ctx.fillRect(0, 460, 480, 180);
    
    // Grass details
    ctx.strokeStyle = '#228b22';
    ctx.lineWidth = 2;
    for (let i = 0; i < 30; i++) {
      const gx = i * 16 + Math.sin(G.t * 2 + i) * 3;
      ctx.beginPath();
      ctx.moveTo(gx, 460);
      ctx.lineTo(gx + 3, 450 + Math.sin(G.t * 3 + i) * 3);
      ctx.stroke();
    }
    
    // Arena center line
    ctx.strokeStyle = 'rgba(255,255,255,0.2)';
    ctx.lineWidth = 3;
    ctx.setLineDash([10, 10]);
    ctx.beginPath();
    ctx.moveTo(240, 380);
    ctx.lineTo(240, 460);
    ctx.stroke();
    ctx.setLineDash([]);
    
    // Draw players using the main game's drawPlayer function
    // Save original values
    const origP = { x: P.x, y: P.y, w: P.w, h: P.h, onGround: P.onGround, crouching: P.crouching };
    const origSelectedChar = selectedChar;
    const origGroundY = G.groundY;
    
    // Set arena ground
    G.groundY = 460;
    
    // Draw my character
    P.x = arenaState.player.x - P.w / 2;
    P.y = arenaState.player.y;
    P.onGround = arenaState.player.y >= 460;
    P.crouching = arenaKeys.down;
    selectedChar = arenaState.player.charKey;
    
    // Flip if facing left
    if (!arenaState.player.facingRight) {
      ctx.save();
      ctx.translate(arenaState.player.x * 2, 0);
      ctx.scale(-1, 1);
    }
    drawPlayer();
    if (!arenaState.player.facingRight) {
      ctx.restore();
    }
    
    // Draw opponent
    P.x = arenaState.opponent.x - P.w / 2;
    P.y = arenaState.opponent.y;
    P.onGround = arenaState.opponent.y >= 460;
    P.crouching = arenaState.opponent.crouching || false;
    selectedChar = arenaState.opponent.charKey;
    
    // Flip if facing left
    if (!arenaState.opponent.facingRight) {
      ctx.save();
      ctx.translate(arenaState.opponent.x * 2, 0);
      ctx.scale(-1, 1);
    }
    drawPlayer();
    if (!arenaState.opponent.facingRight) {
      ctx.restore();
    }
    
    // Restore original values
    P.x = origP.x;
    P.y = origP.y;
    P.w = origP.w;
    P.h = origP.h;
    P.onGround = origP.onGround;
    P.crouching = origP.crouching;
    selectedChar = origSelectedChar;
    G.groundY = origGroundY;
    
    // Draw projectiles with character-specific visuals
    arenaState.projectiles.forEach(proj => {
      ctx.save();
      ctx.shadowColor = proj.color || '#ff6b6b';
      ctx.shadowBlur = 15;
      
      const t = proj.type;
      
      // Shuriken - spinning star
      if (t === 'shuriken') {
        ctx.translate(proj.x, proj.y);
        ctx.rotate((G.t * 15) % (Math.PI * 2));
        ctx.fillStyle = '#888';
        for (let i = 0; i < 4; i++) {
          ctx.rotate(Math.PI / 2);
          ctx.beginPath();
          ctx.moveTo(0, 0);
          ctx.lineTo(-4, -12);
          ctx.lineTo(0, -10);
          ctx.lineTo(4, -12);
          ctx.closePath();
          ctx.fill();
        }
      }
      // Spear extend - long rectangle
      else if (t === 'spearExtend') {
        ctx.fillStyle = '#a0a0a0';
        ctx.fillRect(proj.x - 40, proj.y - 3, 80, 6);
        ctx.fillStyle = '#ff6b6b';
        ctx.beginPath();
        ctx.moveTo(proj.x + 40, proj.y);
        ctx.lineTo(proj.x + 55, proj.y - 6);
        ctx.lineTo(proj.x + 55, proj.y + 6);
        ctx.closePath();
        ctx.fill();
      }
      // Water ball
      else if (t === 'waterBall') {
        ctx.fillStyle = 'rgba(52, 152, 219, 0.7)';
        ctx.beginPath();
        ctx.arc(proj.x, proj.y, proj.radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = 'rgba(255,255,255,0.5)';
        ctx.beginPath();
        ctx.arc(proj.x - 4, proj.y - 4, proj.radius * 0.3, 0, Math.PI * 2);
        ctx.fill();
      }
      // Katana slash - arc
      else if (t === 'katanaSlash') {
        ctx.strokeStyle = '#e0e0e0';
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.arc(proj.x, proj.y, 25, -0.5, 0.5);
        ctx.stroke();
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.stroke();
      }
      // Punch - fist
      else if (t === 'punch') {
        ctx.fillStyle = '#f39c12';
        ctx.beginPath();
        ctx.arc(proj.x, proj.y, 15, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 16px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('üëä', proj.x, proj.y + 5);
      }
      // Poison shot
      else if (t === 'poisonShot') {
        ctx.fillStyle = '#2ecc71';
        ctx.beginPath();
        ctx.arc(proj.x, proj.y, proj.radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#27ae60';
        ctx.beginPath();
        ctx.arc(proj.x + 3, proj.y - 2, proj.radius * 0.4, 0, Math.PI * 2);
        ctx.fill();
      }
      // Needle
      else if (t === 'needleThrow') {
        ctx.strokeStyle = '#c0392b';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(proj.x - 8, proj.y);
        ctx.lineTo(proj.x + 8, proj.y);
        ctx.stroke();
        ctx.fillStyle = '#e74c3c';
        ctx.beginPath();
        ctx.arc(proj.x + 8, proj.y, 2, 0, Math.PI * 2);
        ctx.fill();
      }
      // Eye beam
      else if (t === 'eyeBeam') {
        ctx.fillStyle = '#9b59b6';
        ctx.beginPath();
        ctx.ellipse(proj.x, proj.y, 18, 8, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(proj.x, proj.y, 4, 0, Math.PI * 2);
        ctx.fill();
      }
      // Eagle
      else if (t === 'eagle') {
        ctx.fillStyle = '#8b5cf6';
        ctx.font = 'bold 40px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('ü¶Ö', proj.x, proj.y + 12);
      }
      // Fire dragon
      else if (t === 'fireDragon') {
        ctx.fillStyle = '#e74c3c';
        ctx.font = 'bold 50px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('üê≤', proj.x, proj.y + 15);
      }
      // Monkey
      else if (t === 'monkey') {
        ctx.fillStyle = '#8b4513';
        ctx.font = 'bold 35px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('üêµ', proj.x, proj.y + 10);
      }
      // Arrow
      else if (t === 'arrow' || t === 'arrowShot') {
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(proj.x - 12, proj.y);
        ctx.lineTo(proj.x + 8, proj.y);
        ctx.stroke();
        ctx.fillStyle = '#e74c3c';
        ctx.beginPath();
        ctx.moveTo(proj.x + 8, proj.y);
        ctx.lineTo(proj.x + 14, proj.y - 4);
        ctx.lineTo(proj.x + 14, proj.y + 4);
        ctx.closePath();
        ctx.fill();
      }
      // Lightning
      else if (t === 'lightning') {
        ctx.strokeStyle = '#f1c40f';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(proj.x - 10, proj.y - 8);
        ctx.lineTo(proj.x, proj.y);
        ctx.lineTo(proj.x - 5, proj.y);
        ctx.lineTo(proj.x + 10, proj.y + 10);
        ctx.stroke();
      }
      // Ice
      else if (t === 'ice' || t === 'iceStorm') {
        ctx.fillStyle = '#67e8f9';
        ctx.beginPath();
        ctx.moveTo(proj.x, proj.y - 10);
        ctx.lineTo(proj.x + 8, proj.y + 8);
        ctx.lineTo(proj.x - 8, proj.y + 8);
        ctx.closePath();
        ctx.fill();
      }
      // Wind
      else if (t === 'windWave' || t === 'windSword') {
        ctx.strokeStyle = '#87ceeb';
        ctx.lineWidth = 3;
        ctx.beginPath();
        for (let i = 0; i < 3; i++) {
          ctx.arc(proj.x + i * 8, proj.y, 8, Math.PI * 0.5, Math.PI * 1.5);
        }
        ctx.stroke();
      }
      // Paper
      else if (t === 'paper' || t === 'paperThrow') {
        ctx.fillStyle = '#ecf0f1';
        ctx.save();
        ctx.translate(proj.x, proj.y);
        ctx.rotate(G.t * 5);
        ctx.fillRect(-6, -8, 12, 16);
        ctx.restore();
      }
      // Shadow clone
      else if (t === 'shadowClone') {
        ctx.fillStyle = 'rgba(142, 68, 173, 0.7)';
        ctx.beginPath();
        ctx.ellipse(proj.x, proj.y, 15, 25, 0, 0, Math.PI * 2);
        ctx.fill();
      }
      // Crow / dark
      else if (t === 'darkCrow' || t === 'crowFeather') {
        ctx.fillStyle = '#2c3e50';
        ctx.font = 'bold 30px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('üê¶‚Äç‚¨õ', proj.x, proj.y + 8);
      }
      // Kiss
      else if (t === 'kissThrow') {
        ctx.fillStyle = '#ff69b4';
        ctx.font = 'bold 24px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('üíã', proj.x, proj.y + 8);
      }
      // Kunai
      else if (t === 'kunaiThrow') {
        ctx.fillStyle = '#555';
        ctx.beginPath();
        ctx.moveTo(proj.x + 12, proj.y);
        ctx.lineTo(proj.x - 4, proj.y - 4);
        ctx.lineTo(proj.x - 8, proj.y);
        ctx.lineTo(proj.x - 4, proj.y + 4);
        ctx.closePath();
        ctx.fill();
      }
      // Default circle projectile
      else {
        ctx.fillStyle = proj.color || '#ff6b6b';
        ctx.beginPath();
        ctx.arc(proj.x, proj.y, proj.radius || 12, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(proj.x, proj.y, (proj.radius || 12) * 0.4, 0, Math.PI * 2);
        ctx.fill();
      }
      
      ctx.restore();
    });
    
    // Draw particles
    arenaState.particles.forEach(part => {
      ctx.globalAlpha = Math.min(1, part.life * 2);
      ctx.fillStyle = part.color || '#fff';
      ctx.beginPath();
      ctx.arc(part.x, part.y, 5, 0, Math.PI * 2);
      ctx.fill();
    });
    ctx.globalAlpha = 1;
    
    // Draw name tags
    ctx.font = 'bold 14px sans-serif';
    ctx.textAlign = 'center';
    ctx.strokeStyle = '#000';
    ctx.lineWidth = 3;
    
    // My name
    ctx.fillStyle = '#4ade80';
    ctx.strokeText('SEN', arenaState.player.x, arenaState.player.y - 80);
    ctx.fillText('SEN', arenaState.player.x, arenaState.player.y - 80);
    
    // Opponent name
    ctx.fillStyle = '#ff6b6b';
    ctx.strokeText(arenaState.opponent.name, arenaState.opponent.x, arenaState.opponent.y - 80);
    ctx.fillText(arenaState.opponent.name, arenaState.opponent.x, arenaState.opponent.y - 80);
    
    // Draw HP bars
    drawArenaHPBar(arenaState.player, 20, 20, true);
    drawArenaHPBar(arenaState.opponent, 260, 20, false);
    
    // Draw WebRTC connection status
    ctx.font = 'bold 12px sans-serif';
    ctx.textAlign = 'right';
    if (arenaState.isConnected) {
      ctx.fillStyle = '#4ade80';
      ctx.fillText('üü¢ P2P Baƒülƒ±', 470, 55);
    } else {
      ctx.fillStyle = '#f59e0b';
      ctx.fillText('üü° Firebase', 470, 55);
    }
    
    // Draw skill cooldowns
    drawArenaSkillUI();
  }

  // Draw background trees for arena
  function drawArenaTrees() {
    // Back layer trees (darker, smaller)
    ctx.fillStyle = '#1a4d1a';
    for (let i = 0; i < 8; i++) {
      const tx = i * 70 + 20;
      const ty = 350;
      // Tree trunk
      ctx.fillStyle = '#4a3728';
      ctx.fillRect(tx - 8, ty, 16, 110);
      // Tree top
      ctx.fillStyle = '#1a4d1a';
      ctx.beginPath();
      ctx.moveTo(tx, ty - 80);
      ctx.lineTo(tx - 40, ty + 20);
      ctx.lineTo(tx + 40, ty + 20);
      ctx.closePath();
      ctx.fill();
      ctx.beginPath();
      ctx.moveTo(tx, ty - 50);
      ctx.lineTo(tx - 35, ty + 40);
      ctx.lineTo(tx + 35, ty + 40);
      ctx.closePath();
      ctx.fill();
    }
  }

  // Draw HP bar
  function drawArenaHPBar(player, x, y, isMe) {
    const barWidth = 200;
    const barHeight = 20;
    const hpPercent = Math.max(0, player.hp / player.maxHp);
    
    // Background
    ctx.fillStyle = 'rgba(0,0,0,0.5)';
    ctx.fillRect(x, y, barWidth, barHeight);
    
    // HP
    ctx.fillStyle = isMe ? '#4ade80' : '#ff6b6b';
    ctx.fillRect(x + 2, y + 2, (barWidth - 4) * hpPercent, barHeight - 4);
    
    // Border
    ctx.strokeStyle = isMe ? '#4ade80' : '#ff6b6b';
    ctx.lineWidth = 2;
    ctx.strokeRect(x, y, barWidth, barHeight);
    
    // Text
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 12px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText(`${Math.max(0, Math.round(player.hp))} / ${player.maxHp}`, x + barWidth / 2, y + 15);
  }

  // Draw skill UI
  function drawArenaSkillUI() {
    const p = arenaState.player;
    const char = CHARACTERS[p.charKey];
    if (!char) return;
    
    // X skill
    ctx.fillStyle = p.skillXCooldown > 0 ? 'rgba(100,100,100,0.8)' : 'rgba(255,100,100,0.8)';
    ctx.fillRect(160, 590, 70, 40);
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 14px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('[X] ' + char.skillX.icon, 195, 610);
    if (p.skillXCooldown > 0) {
      ctx.fillStyle = '#ffd700';
      ctx.fillText(p.skillXCooldown.toFixed(1) + 's', 195, 625);
    }
    
    // C skill
    ctx.fillStyle = p.skillFCooldown > 0 ? 'rgba(100,100,100,0.8)' : 'rgba(168,85,247,0.8)';
    ctx.fillRect(250, 590, 70, 40);
    ctx.fillStyle = '#fff';
    ctx.fillText('[C] ' + char.skillF.icon, 285, 610);
    if (p.skillFCooldown > 0) {
      ctx.fillStyle = '#ffd700';
      ctx.fillText(p.skillFCooldown.toFixed(1) + 's', 285, 625);
    }
  }

  // Check Firebase Auth state on page load
  auth.onAuthStateChanged(async (user) => {
    if (user) {
      // User is signed in
      try {
        const userDataSnapshot = await database.ref(`users/${user.uid}`).once('value');
        const userData = userDataSnapshot.val() || {};
        
        currentUser = { 
          username: userData.username || user.displayName || user.email.split('@')[0], 
          email: user.email, 
          uid: user.uid 
        };
        nickname = currentUser.username;
        
        // Load coins and bonuses
        G.coins = userData.coins || 0;
        permBonuses.doubleJump = userData.doubleJump || false;
        permBonuses.extraLives = userData.extraLives || 0;
        permBonuses.airDash = userData.airDash || false;
        
        localStorage.setItem('ninja_user', JSON.stringify(currentUser));
        updateCoinsDisplay();
        updateDojoUI();
        welcomeText.textContent = `Ho≈ü geldin, ${currentUser.username}!`;
        showScreen('charSelect');
      } catch (e) {
        console.error('Error loading user data:', e);
        auth.signOut();
      }
    } else {
      // User is signed out - check localStorage for backwards compatibility
      const saved = localStorage.getItem('ninja_user');
      if (saved) {
        // Clear old localStorage data since Firebase says no user
        localStorage.removeItem('ninja_user');
      }
      currentUser = null;
      nickname = '';
    }
  });

  // ===== NICKNAME SCREEN =====
  nickInput.addEventListener('input', () => {
    const val = nickInput.value.trim();
    nickBtn.disabled = val.length < 1;
  });

  nickBtn.addEventListener('click', () => {
    nickname = nickInput.value.trim().slice(0, 16);
    if (nickname.length < 1) return;
    sessionStorage.setItem('ninja_nick', nickname);
    welcomeText.textContent = `Ho≈ü geldin, ${nickname}!`;
    welcomeText.textContent = `Dene ve G√∂r - bilge birisi.`;
    showScreen('charSelect');
  });

  // ===== CHARACTER SELECT =====
  charCards.forEach(card => {
    card.addEventListener('click', () => {
      charCards.forEach(c => c.classList.remove('selected'));
      card.classList.add('selected');
      selectedChar = card.dataset.char;
      startBtn.disabled = false;
    });
  });

  startBtn.addEventListener('click', () => {
    if (!selectedChar) return;
    showScreen('locationSelect');
  });

  // ===== LOCATION SELECT =====
  locationCards.forEach(card => {
    card.addEventListener('click', () => {
      locationCards.forEach(c => c.classList.remove('selected'));
      card.classList.add('selected');
      selectedLocation = card.dataset.location;
    });
  });

  locationStartBtn.addEventListener('click', () => {
    showScreen('game');
    initGame();
  });

  // ===== LEADERBOARD =====
  playAgainBtn.addEventListener('click', () => {
    showScreen('game');
    resetGame();
  });

  backToMenuBtn.addEventListener('click', () => {
    if (leaderboardReturnTo === 'game') {
      showScreen('game');
      if (G.running === false && !G.gameOver) {
        G.running = true;
        requestAnimationFrame(loop);
      }
    } else if (leaderboardReturnTo === 'nickname') {
      showScreen('nickname');
    } else if (leaderboardReturnTo === 'auth') {
      showScreen('auth');
    } else {
      showScreen('charSelect');
    }
  });

  // Karakter se√ßim ekranƒ±ndan skor tablosuna
  charSelectLeaderboardBtn.addEventListener('click', () => {
    viewLeaderboard('charSelect');
  });

  // √áƒ±kƒ±≈ü yap butonu - Firebase Auth signOut
  logoutBtn.addEventListener('click', async () => {
    try {
      await auth.signOut();
    } catch (e) {
      console.error('Logout error:', e);
    }
    currentUser = null;
    nickname = '';
    G.coins = 0;
    permBonuses.doubleJump = false;
    permBonuses.extraLives = 0;
    permBonuses.airDash = false;
    localStorage.removeItem('ninja_user');
    // Reset form inputs
    loginUsername.value = '';
    loginPassword.value = '';
    registerUsername.value = '';
    registerEmail.value = '';
    registerPassword.value = '';
    loginError.textContent = '';
    registerError.textContent = '';
    // Show login container
    loginContainer.classList.remove('hidden');
    registerContainer.classList.add('hidden');
    showScreen('auth');
  });

  // Oyun i√ßinden skor tablosuna
  btnLeaderboard.addEventListener('click', () => {
    G.running = false;
    viewLeaderboard('game');
  });

  // ƒ∞sim giri≈ü ekranƒ±ndan skor tablosuna
  nickLeaderboardBtn.addEventListener('click', () => {
    viewLeaderboard('nickname');
  });

  // Submit score to Firebase Database
  async function submitScore(score) {
    try {
      if (!currentUser || !currentUser.uid) {
        console.warn('No user logged in');
        return { isNewHighScore: false };
      }

      // Save user data (coins, bonuses)
      await saveUserData();

      const finalScore = Math.floor(score);
      
      // Basic anti-cheat: Check game duration
      const gameDuration = (Date.now() - gameStartTime) / 1000;
      const maxPossibleScore = gameDuration * 50; // Max 50 points per second
      
      if (finalScore > maxPossibleScore * 1.2) { // 20% tolerance
        console.warn('üö® Score seems too high for game duration');
        return { isNewHighScore: false };
      }

      // Get current high score
      const scoreRef = database.ref(`scores/${currentUser.uid}`);
      const currentSnapshot = await scoreRef.once('value');
      const currentData = currentSnapshot.val();
      const currentHighScore = currentData?.score || 0;

      const isNewHighScore = finalScore > currentHighScore;

      if (isNewHighScore) {
        // Save new high score
        await scoreRef.set({
          nickname: currentUser.username,
          score: finalScore,
          character: selectedChar,
          location: selectedLocation,
          timestamp: Date.now()
        });
        console.log('üèÜ New high score saved!', finalScore);
      }

      return { 
        isNewHighScore,
        entry: { 
          nickname: currentUser.username, 
          score: finalScore,
          character: selectedChar,
          location: selectedLocation
        }
      };
    } catch (error) {
      console.error('Failed to submit score:', error);
      return null;
    }
  }

  let leaderboardReturnTo = 'charSelect';

  // Fetch leaderboard from Firebase
  async function fetchLeaderboard() {
    try {
      const snapshot = await database.ref('scores')
        .orderByChild('score')
        .limitToLast(100)
        .once('value');
      
      const data = snapshot.val();
      if (!data) return [];
      
      // Convert to array and sort descending
      const scores = Object.values(data)
        .sort((a, b) => b.score - a.score);
      
      return scores;
    } catch (error) {
      console.error('Failed to fetch leaderboard:', error);
      return [];
    }
  }

  async function showLeaderboard(finalScore) {
    leaderboardReturnTo = 'charSelect'; // Oyun bittiƒüinde normal davranƒ±≈ü
    showScreen('leaderboard');
    leaderboardList.innerHTML = '<div class="leaderboard-empty">Y√ºkleniyor...</div>';
    
    // Butonlarƒ± normal duruma getir
    playAgainBtn.style.display = 'inline-block';
    backToMenuBtn.textContent = 'Ana Men√º üè†';
    
    // Submit score first
    const submitResult = await submitScore(finalScore);
    
    // Fetch leaderboard
    const scores = await fetchLeaderboard();
    
    if (!scores || scores.length === 0) {
      leaderboardList.innerHTML = '<div class="leaderboard-empty">Hen√ºz skor yok. ƒ∞lk sen ol!</div>';
      playerRankText.textContent = 'Skorun kaydedildi!';
      return;
    }
    
    // Find player's rank
    const playerIndex = scores.findIndex(s => s.nickname.toLowerCase() === nickname.toLowerCase());
    if (playerIndex !== -1) {
      const rank = playerIndex + 1;
      const suffix = rank === 1 ? 'ü•á' : rank === 2 ? 'ü•à' : rank === 3 ? 'ü•â' : '';
      playerRankText.textContent = `Sƒ±ralaman: #${rank} ${suffix}`;
      if (submitResult && submitResult.isNewHighScore) {
        playerRankText.textContent += ' - Yeni Rekor! üéâ';
      }
    } else {
      playerRankText.textContent = `Skorun: ${Math.floor(finalScore)}`;
    }
    
    // Render leaderboard
    leaderboardList.innerHTML = scores.map((s, i) => {
      const rank = i + 1;
      const isCurrentPlayer = s.nickname.toLowerCase() === nickname.toLowerCase();
      const rankClass = rank === 1 ? 'top-1' : rank === 2 ? 'top-2' : rank === 3 ? 'top-3' : '';
      const charName = CHARACTERS[s.character]?.name || s.character;
      
      return `
        <div class="leaderboard-row ${rankClass} ${isCurrentPlayer ? 'current-player' : ''}">
          <span class="rank ${rankClass}">${rank <= 3 ? (rank === 1 ? 'ü•á' : rank === 2 ? 'ü•à' : 'ü•â') : rank}</span>
          <span class="player-name">${escapeHtml(s.nickname)}</span>
          <span class="player-char">${charName}</span>
          <span class="player-score">${s.score.toLocaleString()}</span>
        </div>
      `;
    }).join('');
  }

  function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }

  // Skor tablosunu sadece g√∂r√ºnt√ºle (skor kaydetmeden)
  async function viewLeaderboard(returnScreen = 'charSelect') {
    leaderboardReturnTo = returnScreen;
    showScreen('leaderboard');
    leaderboardList.innerHTML = '<div class="leaderboard-empty">Y√ºkleniyor...</div>';
    playerRankText.textContent = 'En iyi oyuncular';
    
    // Buton metinlerini duruma g√∂re g√ºncelle
    if (returnScreen === 'game') {
      playAgainBtn.style.display = 'none';
      backToMenuBtn.textContent = '‚Üê Oyuna D√∂n';
    } else {
      playAgainBtn.style.display = 'inline-block';
      backToMenuBtn.textContent = 'Ana Men√º üè†';
    }
    
    const scores = await fetchLeaderboard();
    
    if (!scores || scores.length === 0) {
      leaderboardList.innerHTML = '<div class="leaderboard-empty">Hen√ºz skor yok. ƒ∞lk sen ol!</div>';
      return;
    }
    
    // Find player's rank if exists
    const playerIndex = scores.findIndex(s => s.nickname.toLowerCase() === nickname.toLowerCase());
    if (playerIndex !== -1) {
      const rank = playerIndex + 1;
      const suffix = rank === 1 ? 'ü•á' : rank === 2 ? 'ü•à' : rank === 3 ? 'ü•â' : '';
      playerRankText.textContent = `Sƒ±ralaman: #${rank} ${suffix}`;
    }
    
    // Render leaderboard
    leaderboardList.innerHTML = scores.map((s, i) => {
      const rank = i + 1;
      const isCurrentPlayer = s.nickname.toLowerCase() === nickname.toLowerCase();
      const rankClass = rank === 1 ? 'top-1' : rank === 2 ? 'top-2' : rank === 3 ? 'top-3' : '';
      const charName = CHARACTERS[s.character]?.name || s.character;
      
      return `
        <div class="leaderboard-row ${rankClass} ${isCurrentPlayer ? 'current-player' : ''}">
          <span class="rank ${rankClass}">${rank <= 3 ? (rank === 1 ? 'ü•á' : rank === 2 ? 'ü•à' : 'ü•â') : rank}</span>
          <span class="player-name">${escapeHtml(s.nickname)}</span>
          <span class="player-char">${charName}</span>
          <span class="player-score">${s.score.toLocaleString()}</span>
        </div>
      `;
    }).join('');
  }

  // ===== RESPONSIVE CANVAS =====
  function resizeCanvas() {
    const rect = canvas.getBoundingClientRect();
    const cssW = Math.max(320, Math.floor(rect.width));
    const cssH = Math.floor(cssW * (WORLD_H / WORLD_W));
    canvas.style.height = cssH + 'px';

    const dpr = Math.min(2, window.devicePixelRatio || 1);
    canvas.width = Math.floor(cssW * dpr);
    canvas.height = Math.floor(cssH * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

    G.scaleX = cssW / WORLD_W;
    G.scaleY = cssH / WORLD_H;
  }

  // ===== INIT GAME =====
  async function initGame() {
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    const char = CHARACTERS[selectedChar];
    const loc = LOCATIONS[selectedLocation];
    
    charPill.textContent = `${char.name} | ${nickname}`;
    skillXName.textContent = char.skillX.name;
    skillFName.textContent = char.skillF.name;
    btnSkillX.querySelector('.skill-icon').textContent = char.skillX.icon;
    btnSkillF.querySelector('.skill-icon').textContent = char.skillF.icon;
    
    // Apply location background to canvas
    canvas.style.background = loc.canvasBg;

    // Start game session (client-side tracking for anti-cheat)
    gameStartTime = Date.now();
    console.log('üéÆ Game session started');

    resetGame();
    requestAnimationFrame(gameLoop);
  }

  function resetGame() {
    G.running = true;
    G.gameOver = false;
    G.score = 0;
    G.speed = 280;
    G.spawnTimer = rand(G.spawnMin, G.spawnMax);
    G.obstacles = [];
    G.projectiles = [];
    G.particles = [];
    G.groundScroll = 0;

    G.skillXCooldown = 0;
    G.skillFCooldown = 0;
    G.ultActive = false;
    G.ultTimer = 0;
    G.ultType = null;
    G.eagleY = 0;
    G.eagleTargetY = G.groundY - 200;
    G.eagleWingPhase = 0;
    G.headbuttY = G.groundY - 25;
    G.swordStormTimer = 0;

    // Boss reset
    G.bossActive = false;
    G.riaru1Defeated = false;
    G.maxdownDefeated = false;
    G.currentBossType = null;
    G.boss = null;
    G.bossProjectiles = [];
    G.bossAttackTimer = 0;
    G.bossUltiTimer = 0;
    G.bossUltiActive = false;
    G.lightningStrikes = [];
    G.laserActive = false;
    G.laserTimer = 0;

    // Scroll/parchment reset
    G.scrolls = [];
    G.scrollSpawnTimer = rand(3, 6);
    
    // Platform reset
    G.platforms = [];
    G.platformSpawnTimer = rand(2, 4);
    G.onPlatform = null;
    
    // Apply permanent bonuses
    G.lives = 3 + permBonuses.extraLives;
    G.maxLives = 3 + permBonuses.extraLives;
    G.canDoubleJump = permBonuses.doubleJump;
    G.hasDoubleJumped = false;
    G.canAirDash = permBonuses.airDash;
    G.hasAirDashed = false;
    G.airDashTimer = 0;
    
    G.scoreMultiplier = 1;
    G.scoreMultiplierTimer = 0;
    G.ultiDurationMultiplier = 1;

    // Item system reset (keep coins and owned items)
    G.activeItem = null;
    G.activeItemTimer = 0;
    G.itemCooldowns = [0, 0, 0];
    G.puppet = null; // Reset puppet
    updateItemSlotsUI();

    // Adjust player size based on character
    const char = CHARACTERS[selectedChar];
    if (char.isSmall) {
      P.baseH = 44;
      P.crouchH = 26;
      P.w = 32;
    } else if (char.isBig) {
      P.baseH = 80;
      P.crouchH = 48;
      P.w = 50;
    } else if (char.isThin) {
      P.baseH = 64;
      P.crouchH = 36;
      P.w = 34; // Thinner body for Teki
    } else {
      P.baseH = 64;
      P.crouchH = 36;
      P.w = 40;
    }
    P.h = P.baseH;

    P.y = G.groundY;
    P.vy = 0;
    P.onGround = true;
    P.crouching = false;

    G.clouds = Array.from({length: 5}, () => ({
      x: rand(0, WORLD_W),
      y: rand(40, 150),
      s: rand(0.5, 1.0),
      v: rand(15, 30)
    }));

    updateSkillUI();
    
    // Start music when game starts
    if (!musicPlaying) {
      bgMusic.play().catch(() => {});
      globalMusicBtn.textContent = 'üîä';
      musicPlaying = true;
    }
  }

  // ===== OBSTACLES =====
  function spawnObstacle() {
    const roll = Math.random();
    if (roll < 0.65) {
      // Ground enemy (ninja)
      const w = rand(30, 45);
      const h = rand(50, 70);
      G.obstacles.push({ 
        type: 'enemy', 
        x: WORLD_W + 40, 
        y: G.groundY, 
        w, h, 
        hitPad: 6,
        color: `hsl(${rand(0, 360)}, 50%, 40%)`
      });
    } else {
      // Flying enemy (bird/kunai)
      const y = G.groundY - (Math.random() < 0.5 ? 80 : 140);
      G.obstacles.push({ 
        type: 'flying', 
        x: WORLD_W + 40, 
        y, 
        w: 50, h: 28, 
        hitPad: 8,
        phase: 0 
      });
    }
  }

  function obstacleRect(o) { return { x: o.x, y: o.y - o.h, w: o.w, h: o.h }; }
  function playerRect() { return { x: P.x, y: P.y - P.h, w: P.w, h: P.h }; }
  function rectsOverlap(a, b) {
    return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
  }

  // ===== BOSS SYSTEM =====
  function spawnBoss(bossType) {
    G.bossActive = true;
    G.currentBossType = bossType;
    
    if (bossType === 'riaru') {
      G.boss = {
        hp: BOSS.maxHp,
        maxHp: BOSS.maxHp,
        x: WORLD_W + 100,
        targetX: 280,
        y: G.groundY,
        w: BOSS.width,
        h: BOSS.height,
        phase: 0,
        attacking: false,
        attackAnim: 0
      };
      G.bossAttackTimer = 2;
      G.bossUltiTimer = BOSS.ultiCooldown;
    } else if (bossType === 'maxdown') {
      G.boss = {
        hp: BOSS_MAXDOWN.maxHp,
        maxHp: BOSS_MAXDOWN.maxHp,
        x: WORLD_W + 100,
        targetX: 320,
        y: G.groundY,
        w: BOSS_MAXDOWN.width,
        h: BOSS_MAXDOWN.height,
        phase: 0,
        attacking: false,
        attackAnim: 0,
        eyeGlow: 0
      };
      G.bossAttackTimer = 2;
      G.bossUltiTimer = BOSS_MAXDOWN.laserCooldown;
      G.laserActive = false;
      G.laserTimer = 0;
      G.maxdownFirstLaserFired = false; // Don't attack until first laser
    }
    
    G.bossProjectiles = [];
    G.lightningStrikes = [];
    G.bossMeleeDamageTimer = 0;
    G.obstacles = [];
    G.speed = 0;
  }

  function updateBoss(dt) {
    const boss = G.boss;
    
    // Move boss into position
    if (boss.x > boss.targetX) {
      boss.x -= 150 * dt;
      if (boss.x < boss.targetX) boss.x = boss.targetX;
    }
    
    // Animation phase
    boss.phase += dt * 3;
    
    // Eye glow for MAXDOWN
    if (G.currentBossType === 'maxdown') {
      boss.eyeGlow = (boss.eyeGlow || 0) + dt * 5;
    }
    
    // Attack animation timer
    if (boss.attacking) {
      boss.attackAnim -= dt;
      if (boss.attackAnim <= 0) boss.attacking = false;
    }
    
    // Attack timer
    G.bossAttackTimer -= dt;
    if (G.bossAttackTimer <= 0) {
      bossAttack();
      const cooldown = G.currentBossType === 'maxdown' ? BOSS_MAXDOWN.attackCooldown : BOSS.attackCooldown;
      G.bossAttackTimer = cooldown;
    }
    
    // MAXDOWN laser attack
    if (G.currentBossType === 'maxdown' && boss.x <= boss.targetX) {
      G.bossUltiTimer -= dt;
      
      // Laser warning state (last 1.5 seconds before firing)
      G.laserWarning = G.bossUltiTimer <= 1.5 && G.bossUltiTimer > 0 && !G.laserActive;
      
      if (G.bossUltiTimer <= 0 && !G.laserActive) {
        // Start laser attack
        G.laserActive = true;
        G.laserWarning = false;
        G.laserTimer = BOSS_MAXDOWN.laserDuration;
        G.laserY = G.groundY - 40; // Laser at player height
        boss.attacking = true;
        boss.attackAnim = BOSS_MAXDOWN.laserDuration;
      }
      
      // Update laser
      if (G.laserActive) {
        G.laserTimer -= dt;
        
        // Laser damage to player
        const pr = playerRect();
        const laserRect = { x: 0, y: G.laserY - 15, w: boss.x, h: 30 };
        const isInvincible = G.activeItem === 'lightning_armor';
        const isFlying = G.ultActive && (G.ultType === 'eagleFlight' || G.ultType === 'moonlight' || G.ultType === 'iceStorm');
        
        if (!isInvincible && !isFlying && rectsOverlap(pr, laserRect)) {
          // Damage every 0.5 seconds
          if (!G.laserDamageTimer) G.laserDamageTimer = 0;
          G.laserDamageTimer -= dt;
          if (G.laserDamageTimer <= 0) {
            G.lives--;
            G.laserDamageTimer = 3; // Only hit once per laser (longer than laser duration)
            
            // Hit particles
            for (let k = 0; k < 8; k++) {
              G.particles.push({
                x: pr.x + pr.w/2,
                y: pr.y + pr.h/2,
                vx: rand(-100, 100),
                vy: rand(-100, 50),
                life: rand(0.2, 0.4),
                color: '#ff0000'
              });
            }
            
            if (G.lives <= 0) {
              G.gameOver = true;
              G.running = false;
              G.bossActive = false;
              G.boss = null;
              G.laserActive = false;
              canvas.classList.remove('ult-active');
              setTimeout(() => showLeaderboard(G.score), 500);
              return;
            }
          }
        }
        
        if (G.laserTimer <= 0) {
          G.laserActive = false;
          G.bossUltiTimer = BOSS_MAXDOWN.laserCooldown;
        }
      }
    }
    
    // Update boss projectiles
    for (let i = G.bossProjectiles.length - 1; i >= 0; i--) {
      const p = G.bossProjectiles[i];
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.life -= dt;
      
      // Remove if off screen or expired
      if (p.x < -50 || p.life <= 0) {
        G.bossProjectiles.splice(i, 1);
        continue;
      }
      
      // Collision with player
      const pr = playerRect();
      const pRect = { x: p.x - 20, y: p.y - 10, w: 80, h: 20 };
      if (rectsOverlap(pr, pRect)) {
        // Player hit - check for invincibility from Lightning Armor
        const isInvincible = G.activeItem === 'lightning_armor';
        if (!isInvincible && (!G.ultActive || (G.ultType !== 'eagleFlight' && G.ultType !== 'moonlight' && G.ultType !== 'iceStorm'))) {
          G.lives--;
          G.bossProjectiles.splice(i, 1);
          
          // Hit particles
          for (let k = 0; k < 12; k++) {
            G.particles.push({
              x: pr.x + pr.w/2,
              y: pr.y + pr.h/2,
              vx: rand(-150, 150),
              vy: rand(-150, 50),
              life: rand(0.3, 0.5),
              color: '#ef4444'
            });
          }
          
          if (G.lives <= 0) {
            G.gameOver = true;
            G.running = false;
            G.bossActive = false;
            G.boss = null;
            G.bossProjectiles = [];
            G.lightningStrikes = [];
            canvas.classList.remove('ult-active');
            setTimeout(() => showLeaderboard(G.score), 500);
            return;
          }
        } else {
          G.bossProjectiles.splice(i, 1);
        }
      }
    }
    
    // Check player projectiles hitting boss
    for (let i = G.projectiles.length - 1; i >= 0; i--) {
      const p = G.projectiles[i];
      
      // Skip rasengan - it has special damage handling
      if (p.type === 'rasengan') continue;
      
      const pRect = p.type === 'spear' 
        ? { x: p.x, y: p.y - p.h / 2, w: p.w, h: p.h }
        : { x: p.x - 15, y: p.y - 15, w: 30, h: 30 };
      
      const bossRect = { x: boss.x, y: boss.y - boss.h, w: boss.w, h: boss.h };
      
      if (rectsOverlap(pRect, bossRect)) {
        // Damage boss
        const damage = p.type === 'spear' ? 8 : 5;
        boss.hp -= damage;
        
        // Hit particles
        for (let k = 0; k < 8; k++) {
          G.particles.push({
            x: boss.x + rand(0, boss.w),
            y: boss.y - boss.h / 2 + rand(-20, 20),
            vx: rand(-150, -50),
            vy: rand(-100, 100),
            life: rand(0.3, 0.5),
            color: '#ffeb3b'
          });
        }
        
        // Remove projectile (except spear)
        if (p.type !== 'spear') {
          G.projectiles.splice(i, 1);
        }
        
        // Check if boss defeated
        if (boss.hp <= 0) {
          defeatBoss();
          return;
        }
      }
    }
    
    // Check melee ultimate collision with boss (headbutt, swordDance, animalFriends, etc.)
    if (G.ultActive && G.boss) {
      const pr = playerRect();
      const bossRect = { x: boss.x, y: boss.y - boss.h, w: boss.w, h: boss.h };
      
      // Melee ultimates that can damage boss on contact
      const meleeUlts = ['headbutt', 'swordDance', 'animalFriends', 'monkeyFriend', 'iceStorm', 'paperWings'];
      
      if (meleeUlts.includes(G.ultType)) {
        // Extended hitbox for melee attacks
        const meleeRange = G.ultType === 'swordDance' ? 150 : 
                           G.ultType === 'headbutt' ? 120 : 
                           G.ultType === 'iceStorm' ? 180 : 100;
        const meleeRect = { x: pr.x, y: pr.y, w: pr.w + meleeRange, h: pr.h };
        
        if (rectsOverlap(meleeRect, bossRect)) {
          // Damage boss with melee (continuous damage)
          if (!G.bossMeleeDamageTimer) G.bossMeleeDamageTimer = 0.25; // Trigger immediately on first hit
          G.bossMeleeDamageTimer += dt;
          if (G.bossMeleeDamageTimer >= 0.25) {
            const damage = G.ultType === 'swordDance' ? 12 : 
                           G.ultType === 'headbutt' ? 15 : 
                           G.ultType === 'iceStorm' ? 10 : 8;
            boss.hp -= damage;
            G.bossMeleeDamageTimer = 0; // Reset timer
            
            // Hit particles
            for (let k = 0; k < 6; k++) {
              G.particles.push({
                x: boss.x + rand(0, boss.w),
                y: boss.y - boss.h / 2 + rand(-20, 20),
                vx: rand(-150, -50),
                vy: rand(-100, 100),
                life: rand(0.3, 0.5),
                color: G.ultType === 'iceStorm' ? '#67e8f9' : '#ffeb3b'
              });
            }
            
            // Check if boss defeated
            if (boss.hp <= 0) {
              defeatBoss();
              return;
            }
          }
        }
      }
    }
  }

  function bossAttack() {
    const boss = G.boss;
    
    if (G.currentBossType === 'maxdown') {
      // MAXDOWN sadece lazer kullanƒ±r - plasma saldƒ±rƒ±sƒ± yok
      return;
    } else {
      boss.attacking = true;
      boss.attackAnim = 0.5;
      
      // Riaru electric shock wave
      const attackLow = Math.random() < 0.35;
      const attackY = attackLow ? (boss.y - 20) : (boss.y - 70);
      
      G.bossProjectiles.push({
        x: boss.x,
        y: attackY,
        vx: -450,
        vy: 0,
        life: 3,
        type: 'shockwave',
        isLow: attackLow
      });
      
      // Particles
      for (let i = 0; i < 15; i++) {
        G.particles.push({
          x: boss.x + rand(-10, 20),
          y: attackY + rand(-20, 20),
          vx: rand(-300, -100),
          vy: rand(-50, 50),
          life: rand(0.3, 0.6),
          color: attackLow ? '#fbbf24' : '#67e8f9'
        });
      }
    }
  }

  function defeatBoss() {
    const bossType = G.currentBossType;
    const bonus = bossType === 'maxdown' ? 500 : 200;
    
    G.bossActive = false;
    if (bossType === 'riaru') {
      G.riaru1Defeated = true;
    } else if (bossType === 'maxdown') {
      G.maxdownDefeated = true;
    }
    G.currentBossType = null;
    G.boss = null;
    G.bossProjectiles = [];
    G.lightningStrikes = [];
    G.laserActive = false;
    G.speed = 280; // Resume game
    G.score += bonus; // Bonus for defeating boss
    
    // Victory particles
    const particleColors = bossType === 'maxdown' 
      ? ['#ff0000', '#ff4444', '#ff8800', '#ffcc00']
      : ['#fbbf24', '#f59e0b', '#ef4444', '#ec4899'];
    
    for (let i = 0; i < 50; i++) {
      G.particles.push({
        x: WORLD_W - 100 + rand(-50, 50),
        y: G.groundY - 60 + rand(-50, 50),
        vx: rand(-200, 200),
        vy: rand(-300, -100),
        life: rand(0.5, 1.2),
        color: particleColors[Math.floor(rand(0, 4))]
      });
    }
  }

  // ===== SCROLL/PARCHMENT SYSTEM =====
  const SCROLL_TYPES = [
    { type: 'blue', color: '#3b82f6', effect: 'life', label: '‚ù§Ô∏è' },
    { type: 'red', color: '#ef4444', effect: 'ultiBoost', label: '‚ö°' },
    { type: 'yellow', color: '#eab308', effect: 'scoreBoost', label: 'üí∞' }
  ];

  function spawnScroll() {
    const scrollType = SCROLL_TYPES[Math.floor(Math.random() * SCROLL_TYPES.length)];
    G.scrolls.push({
      x: WORLD_W + 50,
      y: G.groundY - rand(80, 200),
      w: 35,
      h: 45,
      type: scrollType.type,
      color: scrollType.color,
      effect: scrollType.effect,
      label: scrollType.label,
      bobPhase: rand(0, Math.PI * 2)
    });
  }

  // ===== PLATFORM SYSTEM =====
  function spawnPlatform() {
    const width = rand(150, 250); // Wider platforms
    const height = rand(100, 180); // Height from ground
    
    G.platforms.push({
      x: WORLD_W + 50,
      y: G.groundY - height,
      w: width,
      h: 18,
      type: Math.random() < 0.3 ? 'wood' : 'stone' // 30% wood, 70% stone
    });
  }

  function updatePlatforms(dt) {
    // Apply slow effect from Viagra item
    const speedMod = G.activeItem === 'viagra' ? 0.5 : 1;
    const effectiveSpeed = G.speed * speedMod;
    
    // Spawn timer (only when not in boss fight)
    if (!G.bossActive) {
      G.platformSpawnTimer -= dt;
      if (G.platformSpawnTimer <= 0) {
        if (Math.random() < 0.4) { // 40% chance to spawn
          spawnPlatform();
        }
        G.platformSpawnTimer = rand(3, 6); // Every 3-6 seconds
      }
    }
    
    // Update platforms
    for (let i = G.platforms.length - 1; i >= 0; i--) {
      const p = G.platforms[i];
      p.x -= effectiveSpeed * dt;
      
      // Remove if off screen
      if (p.x + p.w < -50) {
        if (G.onPlatform === p) G.onPlatform = null;
        G.platforms.splice(i, 1);
      }
    }
    
    // Check if player is on a platform
    const pr = playerRect();
    const playerBottom = pr.y + pr.h;
    
    // If currently on a platform, check if still valid
    if (G.onPlatform) {
      const plat = G.onPlatform;
      const playerCenterX = pr.x + pr.w / 2;
      
      // Still on platform if player center is within platform bounds
      if (playerCenterX >= plat.x && playerCenterX <= plat.x + plat.w) {
        // Stay on platform - move with it
        P.y = plat.y;
        P.vy = 0;
        P.onGround = true;
        G.hasDoubleJumped = false; // Reset while on platform
        G.hasAirDashed = false; // Reset while on platform
        return; // Skip other platform checks
      } else {
        // Fell off platform - start falling
        G.onPlatform = null;
        P.onGround = false;
      }
    }
    
    // Check for landing on new platform
    if (P.vy > 0) { // Only when falling
      for (const plat of G.platforms) {
        const playerCenterX = pr.x + pr.w / 2;
        
        // Check if player center is over platform and feet are near platform top
        if (playerCenterX >= plat.x && playerCenterX <= plat.x + plat.w) {
          if (playerBottom >= plat.y - 10 && playerBottom <= plat.y + 15) {
            // Land on platform
            P.y = plat.y;
            P.vy = 0;
            P.onGround = true;
            G.onPlatform = plat;
            G.hasDoubleJumped = false; // Reset double jump on platform landing
            G.hasAirDashed = false; // Reset air dash on platform landing
            break;
          }
        }
      }
    }
  }

  function drawPlatforms() {
    for (const p of G.platforms) {
      ctx.save();
      
      if (p.type === 'wood') {
        // Wooden platform
        ctx.fillStyle = '#8B4513';
        ctx.fillRect(p.x, p.y, p.w, p.h);
        
        // Wood grain
        ctx.strokeStyle = '#5D2E0C';
        ctx.lineWidth = 1;
        for (let i = 0; i < p.w; i += 20) {
          ctx.beginPath();
          ctx.moveTo(p.x + i, p.y);
          ctx.lineTo(p.x + i, p.y + p.h);
          ctx.stroke();
        }
        
        // Top highlight
        ctx.fillStyle = '#A0522D';
        ctx.fillRect(p.x, p.y, p.w, 3);
        
        // Bottom shadow
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.fillRect(p.x, p.y + p.h, p.w, 5);
      } else {
        // Stone platform
        ctx.fillStyle = '#6B6B6B';
        ctx.fillRect(p.x, p.y, p.w, p.h);
        
        // Stone blocks pattern
        ctx.strokeStyle = '#4A4A4A';
        ctx.lineWidth = 2;
        ctx.strokeRect(p.x, p.y, p.w, p.h);
        
        // Block divisions
        ctx.lineWidth = 1;
        for (let i = 0; i < p.w; i += 25) {
          ctx.beginPath();
          ctx.moveTo(p.x + i, p.y);
          ctx.lineTo(p.x + i, p.y + p.h);
          ctx.stroke();
        }
        
        // Top highlight
        ctx.fillStyle = '#888';
        ctx.fillRect(p.x, p.y, p.w, 2);
        
        // Bottom shadow
        ctx.fillStyle = 'rgba(0,0,0,0.4)';
        ctx.fillRect(p.x, p.y + p.h, p.w, 6);
        
        // Moss/grass on top (random)
        ctx.fillStyle = '#4A7C4E';
        for (let i = 5; i < p.w - 5; i += rand(8, 15)) {
          if (Math.random() < 0.5) {
            ctx.fillRect(p.x + i, p.y - 3, rand(4, 8), 4);
          }
        }
      }
      
      ctx.restore();
    }
  }

  function updateScrolls(dt) {
    // Spawn timer
    G.scrollSpawnTimer -= dt;
    if (G.scrollSpawnTimer <= 0 && !G.bossActive) {
      if (Math.random() < 0.25) { // 25% chance to spawn
        spawnScroll();
      }
      G.scrollSpawnTimer = rand(4, 8); // Every 4-8 seconds
    }

    // Update score multiplier timer
    if (G.scoreMultiplierTimer > 0) {
      G.scoreMultiplierTimer -= dt;
      if (G.scoreMultiplierTimer <= 0) {
        G.scoreMultiplier = 1;
      }
    }

    // Move and check scrolls
    const pr = playerRect();
    for (let i = G.scrolls.length - 1; i >= 0; i--) {
      const s = G.scrolls[i];
      s.x -= G.speed * dt;
      s.bobPhase += dt * 4;

      // Remove if off screen
      if (s.x < -50) {
        G.scrolls.splice(i, 1);
        continue;
      }

      // Collision with player
      const sRect = { x: s.x - s.w/2, y: s.y - s.h/2, w: s.w, h: s.h };
      if (rectsOverlap(pr, sRect)) {
        // Collect scroll
        G.score += 100 * G.scoreMultiplier;

        // Apply effect
        if (s.effect === 'life') {
          if (G.lives < G.maxLives) {
            G.lives++;
          }
        } else if (s.effect === 'ultiBoost') {
          G.ultiDurationMultiplier = 2;
        } else if (s.effect === 'scoreBoost') {
          G.scoreMultiplier = 3;
          G.scoreMultiplierTimer = 5;
        }

        // Collect particles
        for (let k = 0; k < 15; k++) {
          G.particles.push({
            x: s.x,
            y: s.y,
            vx: rand(-150, 150),
            vy: rand(-200, -50),
            life: rand(0.3, 0.6),
            color: s.color
          });
        }

        G.scrolls.splice(i, 1);
      }
    }
  }

  function drawScrolls() {
    for (const s of G.scrolls) {
      const bobY = Math.sin(s.bobPhase) * 5;
      const x = s.x;
      const y = s.y + bobY;

      ctx.save();

      // Glow effect
      ctx.shadowColor = s.color;
      ctx.shadowBlur = 15;

      // Scroll/parchment body
      ctx.fillStyle = '#f5e6d3';
      ctx.beginPath();
      ctx.roundRect(x - s.w/2, y - s.h/2, s.w, s.h, 5);
      ctx.fill();

      // Scroll top roll
      ctx.fillStyle = '#d4b896';
      ctx.beginPath();
      ctx.ellipse(x, y - s.h/2, s.w/2 + 3, 6, 0, 0, Math.PI * 2);
      ctx.fill();

      // Scroll bottom roll
      ctx.beginPath();
      ctx.ellipse(x, y + s.h/2, s.w/2 + 3, 6, 0, 0, Math.PI * 2);
      ctx.fill();

      // Colored seal/ribbon
      ctx.fillStyle = s.color;
      ctx.beginPath();
      ctx.ellipse(x, y, 10, 10, 0, 0, Math.PI * 2);
      ctx.fill();

      // Icon
      ctx.shadowBlur = 0;
      ctx.font = '14px sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(s.label, x, y + 1);

      ctx.restore();
    }
  }

  function drawLivesUI() {
    // Lives bar at top right
    ctx.save();
    
    // Calculate dynamic width based on lives
    const heartWidth = 25;
    const barWidth = Math.max(100, G.maxLives * heartWidth + 10);
    const barX = WORLD_W - barWidth - 10;
    
    // Background
    ctx.fillStyle = 'rgba(0,0,0,0.5)';
    ctx.beginPath();
    ctx.roundRect(barX, 10, barWidth, 30, 8);
    ctx.fill();

    // Hearts - draw from left, starting from bar position
    ctx.font = '18px sans-serif';
    ctx.textAlign = 'left';
    ctx.textBaseline = 'middle';
    for (let i = 0; i < G.maxLives; i++) {
      if (i < G.lives) {
        ctx.fillStyle = '#ef4444';
        ctx.fillText('‚ù§Ô∏è', barX + 5 + i * heartWidth, 25);
      } else {
        ctx.fillStyle = '#666';
        ctx.fillText('üñ§', barX + 5 + i * heartWidth, 25);
      }
    }

    // Score multiplier indicator (position relative to bar)
    if (G.scoreMultiplier > 1) {
      ctx.fillStyle = '#eab308';
      ctx.font = 'bold 14px sans-serif';
      ctx.textAlign = 'right';
      ctx.fillText(`x${G.scoreMultiplier} PUAN!`, WORLD_W - 15, 55);
      
      // Timer bar
      ctx.fillStyle = 'rgba(234,179,8,0.3)';
      ctx.fillRect(barX, 65, barWidth, 4);
      ctx.fillStyle = '#eab308';
      ctx.fillRect(barX, 65, barWidth * (G.scoreMultiplierTimer / 5), 4);
    }

    // Ulti boost indicator
    if (G.ultiDurationMultiplier > 1) {
      ctx.fillStyle = '#ef4444';
      ctx.font = 'bold 12px sans-serif';
      ctx.textAlign = 'right';
      ctx.fillText('‚ö° ULTƒ∞ 2X', WORLD_W - 15, G.scoreMultiplier > 1 ? 82 : 55);
    }

    ctx.restore();
  }

  // ===== SKILLS =====
  function useSkillX() {
    if (!G.running || G.gameOver) return;
    if (G.skillXCooldown > 0) return;

    const char = CHARACTERS[selectedChar];
    const pr = playerRect();

    if (char.skillX.action === 'spearExtend') {
      // Haru: Mƒ±zrak uzatma
      G.projectiles.push({
        type: 'spear',
        x: pr.x + pr.w,
        y: pr.y + pr.h * 0.4,
        w: 120,
        h: 8,
        vx: 0,
        extending: true,
        maxW: 180,
        life: 0.5
      });
    } else if (char.skillX.action === 'shuriken') {
      // Ringo: Shuriken
      G.projectiles.push({
        type: 'shuriken',
        x: pr.x + pr.w,
        y: pr.y + pr.h * 0.4,
        radius: 12,
        vx: 700,
        spin: 0,
        life: 3
      });
    } else if (char.skillX.action === 'waterBall') {
      // Usagi: Su topu
      G.projectiles.push({
        type: 'waterBall',
        x: pr.x + pr.w,
        y: pr.y + pr.h * 0.4,
        radius: 16,
        vx: 600,
        life: 3,
        trail: []
      });
    } else if (char.skillX.action === 'katanaSlash') {
      // Chisa: Katana darbesi - kƒ±sa menzil ama hƒ±zlƒ±
      G.projectiles.push({
        type: 'katanaSlash',
        x: pr.x + pr.w - 10,
        y: pr.y + pr.h * 0.3,
        w: 60,
        h: 50,
        vx: 0,
        life: 0.25,
        slashPhase: 0
      });
    } else if (char.skillX.action === 'punch') {
      // Butsuo: Yumruk - kƒ±sa menzil ama g√º√ßl√º
      G.projectiles.push({
        type: 'punch',
        x: pr.x + pr.w,
        y: pr.y + pr.h * 0.4,
        w: 50,
        h: 40,
        vx: 0,
        life: 0.3,
        punchPhase: 0
      });
    } else if (char.skillX.action === 'poisonShot') {
      // Teki: Zehir mermisi - uzun menzil, tek vuru≈ü
      G.projectiles.push({
        type: 'poisonShot',
        x: pr.x + pr.w,
        y: pr.y + pr.h * 0.35,
        w: 18,
        h: 18,
        vx: 400,
        spin: 0
      });
    } else if (char.skillX.action === 'needleThrow') {
      // Susumu: 5 parlayan iƒüne fƒ±rlatƒ±r
      for (let i = 0; i < 5; i++) {
        G.projectiles.push({
          type: 'needle',
          x: pr.x + pr.w,
          y: pr.y + pr.h * 0.3 + i * 12,
          w: 30,
          h: 3,
          vx: 650 + i * 30,
          vy: (i - 2) * 20,
          life: 2,
          glow: Math.random() * Math.PI * 2
        });
      }
    } else if (char.skillX.action === 'eyeBeam') {
      // Shinji: G√∂z√ºnden √ßƒ±kan ƒ±≈üƒ±n
      G.projectiles.push({
        type: 'eyeBeam',
        x: pr.x + pr.w,
        y: pr.y + pr.h * 0.25,
        w: 200,
        h: 6,
        vx: 800,
        life: 0.8,
        glow: 0
      });
    } else if (char.skillX.action === 'windWave') {
      // Kazuya: Hava dalgasƒ± √ºfler
      G.projectiles.push({
        type: 'windWave',
        x: pr.x + pr.w,
        y: pr.y + pr.h * 0.4,
        w: 40,
        h: 30,
        vx: 500,
        life: 2,
        phase: 0
      });
    } else if (char.skillX.action === 'crowFeather') {
      // Togami: 3 karga t√ºy√º fƒ±rlatƒ±r
      for (let i = 0; i < 3; i++) {
        G.projectiles.push({
          type: 'crowFeather',
          x: pr.x + pr.w,
          y: pr.y + pr.h * 0.3 + i * 18,
          w: 35,
          h: 8,
          vx: 550 + i * 40,
          vy: (i - 1) * 30,
          life: 2.5,
          spin: Math.random() * Math.PI * 2
        });
      }
    } else if (char.skillX.action === 'paperThrow') {
      // Kagi: 4 keskin kaƒüƒ±t fƒ±rlatƒ±r
      for (let i = 0; i < 4; i++) {
        G.projectiles.push({
          type: 'paperThrow',
          x: pr.x + pr.w,
          y: pr.y + pr.h * 0.25 + i * 15,
          w: 30,
          h: 20,
          vx: 600 + i * 30,
          vy: (i - 1.5) * 40,
          life: 2,
          spin: 0
        });
      }
    } else if (char.skillX.action === 'kissThrow') {
      // Akemi: 3 √∂p√ºc√ºk fƒ±rlatƒ±r
      for (let i = 0; i < 3; i++) {
        G.projectiles.push({
          type: 'kissThrow',
          x: pr.x + pr.w,
          y: pr.y + pr.h * 0.3,
          w: 25,
          h: 25,
          vx: 350 + i * 50,
          vy: Math.sin(i * 0.8) * 60 - 30,
          life: 2.5,
          phase: i * Math.PI / 3,
          wobble: 0
        });
      }
    } else if (char.skillX.action === 'illusionKill') {
      // Ryoken: ƒ∞l√ºzyon - tek d√º≈ümanƒ± √∂ld√ºr√ºr
      G.projectiles.push({
        type: 'illusionKill',
        x: pr.x + pr.w,
        y: pr.y + pr.h * 0.3,
        w: 40,
        h: 40,
        vx: 500,
        life: 2,
        phase: 0
      });
    } else if (char.skillX.action === 'arrowShot') {
      // Riku: Ok atar
      G.projectiles.push({
        type: 'arrowShot',
        x: pr.x + pr.w,
        y: pr.y + pr.h * 0.35,
        w: 45,
        h: 6,
        vx: 700,
        life: 2.5
      });
    } else if (char.skillX.action === 'kunaiThrow') {
      // Joaryu: Kunai fƒ±rlatƒ±r
      G.projectiles.push({
        type: 'kunaiThrow',
        x: pr.x + pr.w,
        y: pr.y + pr.h * 0.35,
        w: 35,
        h: 10,
        vx: 650,
        life: 2,
        spin: 0
      });
    }

    // Particles
    for (let i = 0; i < 8; i++) {
      G.particles.push({
        x: pr.x + pr.w,
        y: pr.y + pr.h * 0.4 + rand(-10, 10),
        vx: rand(50, 150),
        vy: rand(-40, 40),
        life: rand(0.2, 0.4),
        color: char.color
      });
    }

    G.skillXCooldown = char.skillX.cooldown;
    updateSkillUI();
  }

  function useSkillF() {
    if (!G.running || G.gameOver) return;
    if (G.skillFCooldown > 0) return;
    if (G.ultActive) return;

    const char = CHARACTERS[selectedChar];
    G.ultActive = true;
    G.ultTimer = char.skillF.duration * G.ultiDurationMultiplier;
    G.ultType = char.skillF.action;
    
    // Reset ulti multiplier after use
    G.ultiDurationMultiplier = 1;

    // Eagle flight: start rising
    if (char.skillF.action === 'eagleFlight') {
      G.eagleY = P.y;
      G.eagleTargetY = G.groundY - 220;
      P.onGround = false;
    }

    // Paper wings: start flying
    if (char.skillF.action === 'paperWings') {
      G.paperWingsY = G.groundY - 180;
      P.onGround = false;
    }

    // Headbutt: start flying forward at ground level
    if (char.skillF.action === 'headbutt') {
      P.onGround = false;
      G.headbuttY = G.groundY - 25;
    }

    // Sword storm: rapid slashes
    if (char.skillF.action === 'swordStorm') {
      G.swordStormTimer = 0;
    }

    // Arrow rain: continuous arrow spawning
    if (char.skillF.action === 'arrowRain') {
      G.arrowRainTimer = 0;
    }

    // Visual feedback
    canvas.classList.add('ult-active');

    // Particles burst
    for (let i = 0; i < 20; i++) {
      G.particles.push({
        x: P.x + P.w / 2 + rand(-30, 30),
        y: P.y - P.h / 2 + rand(-30, 30),
        vx: rand(-200, 200),
        vy: rand(-200, 50),
        life: rand(0.5, 1.0),
        color: char.skillF.action === 'moonlight' ? '#fff' : 
               char.skillF.action === 'eagleFlight' ? '#8b5cf6' : 
               char.skillF.action === 'swordStorm' ? '#e74c3c' :
               char.skillF.action === 'headbutt' ? '#ecf0f1' :
               char.skillF.action === 'poisonArmor' ? '#27ae60' :
               char.skillF.action === 'monkeyFriend' ? '#8B4513' :
               char.skillF.action === 'animalFriends' ? '#ff9f43' :
               char.skillF.action === 'paperWings' ? '#ecf0f1' :
               char.skillF.action === 'illusionStorm' ? '#9b59b6' :
               char.skillF.action === 'windSword' ? '#3498db' :
               char.skillF.action === 'darkAura' ? '#222' :
               char.skillF.action === 'fireDragon' ? '#e74c3c' :
               char.skillF.action === 'mysticLightning' ? '#f1c40f' :
               char.skillF.action === 'arrowRain' ? '#3498db' :
               char.skillF.action === 'shadowClone' ? '#8e44ad' : '#67e8f9'
      });
    }

    G.skillFCooldown = char.skillF.cooldown;
    updateSkillUI();
  }

  function updateSkillUI() {
    const char = CHARACTERS[selectedChar];
    
    // Skill X
    const xPct = Math.max(0, 1 - G.skillXCooldown / char.skillX.cooldown) * 100;
    btnSkillX.querySelector('.cd-bar').style.width = xPct + '%';
    btnSkillX.classList.toggle('cooldown', G.skillXCooldown > 0);
    cdTextX.textContent = G.skillXCooldown > 0 ? Math.ceil(G.skillXCooldown) + 's' : '';

    // Skill F
    const fPct = Math.max(0, 1 - G.skillFCooldown / char.skillF.cooldown) * 100;
    btnSkillF.querySelector('.cd-bar').style.width = fPct + '%';
    btnSkillF.classList.toggle('cooldown', G.skillFCooldown > 0);
    cdTextF.textContent = G.skillFCooldown > 0 ? Math.ceil(G.skillFCooldown) + 's' : '';
  }

  // ===== ACTIONS =====
  function jump() {
    if (G.gameOver) { resetGame(); return; }
    if (!G.running) return;

    // Eagle flight: control height with jump
    if (G.ultActive && G.ultType === 'eagleFlight') {
      // Move up a bit when pressing jump during eagle flight
      G.eagleTargetY = Math.max(100, G.eagleTargetY - 40);
      return;
    }
    
    // Paper wings: control height with jump
    if (G.ultActive && G.ultType === 'paperWings') {
      G.paperWingsY = Math.max(100, G.paperWingsY - 40);
      return;
    }

    if (P.onGround) {
      P.vy = P.jumpVel;
      P.onGround = false;
      G.hasDoubleJumped = false; // Reset double jump when leaving ground
      G.hasAirDashed = false; // Reset air dash when leaving ground
      G.onPlatform = null; // Leave platform
      
      for (let i = 0; i < 8; i++) {
        G.particles.push({
          x: P.x + rand(5, P.w - 5),
          y: G.groundY - rand(2, 8),
          vx: rand(-60, -20),
          vy: rand(-80, -30),
          life: rand(0.2, 0.35),
          color: '#888'
        });
      }
    } else if (G.canDoubleJump && !G.hasDoubleJumped) {
      // Double jump in air!
      P.vy = P.jumpVel * 0.85; // Slightly weaker second jump
      G.hasDoubleJumped = true;
      G.hasAirDashed = false; // Reset air dash on double jump too
      
      // Double jump particles (different color)
      for (let i = 0; i < 10; i++) {
        G.particles.push({
          x: P.x + rand(5, P.w - 5),
          y: P.y - rand(10, 30),
          vx: rand(-50, 50),
          vy: rand(-60, -20),
          life: rand(0.2, 0.4),
          color: '#ffd700'
        });
      }
    }
  }

  function crouch(on) {
    if (G.gameOver) return;
    
    // Eagle flight: control height with crouch
    if (G.ultActive && G.ultType === 'eagleFlight') {
      if (on) {
        G.eagleTargetY = Math.min(G.groundY - 80, G.eagleTargetY + 60);
      }
      return;
    }
    
    // Paper wings: control height with crouch
    if (G.ultActive && G.ultType === 'paperWings') {
      if (on) {
        G.paperWingsY = Math.min(G.groundY - 80, G.paperWingsY + 60);
      }
      return;
    }
    
    P.crouching = on;
    P.h = on ? P.crouchH : P.baseH;
    if (P.onGround) P.y = G.groundY;
  }

  // Air Dash - ƒ∞tici G√º√ß
  function airDash() {
    console.log('airDash called:', {
      gameOver: G.gameOver,
      running: G.running,
      onGround: P.onGround,
      canAirDash: G.canAirDash,
      hasAirDashed: G.hasAirDashed
    });
    
    if (G.gameOver || !G.running) return;
    if (P.onGround) return; // Only works in air
    if (!G.canAirDash) return; // Need to own the ability
    if (G.hasAirDashed) return; // Already used this jump
    
    console.log('AIR DASH ACTIVATED!');
    G.hasAirDashed = true;
    G.airDashTimer = 0.15; // Dash duration
    
    // Dash particles
    for (let i = 0; i < 15; i++) {
      G.particles.push({
        x: P.x - rand(5, 30),
        y: P.y - P.h/2 + rand(-20, 20),
        vx: rand(-200, -100),
        vy: rand(-30, 30),
        life: rand(0.2, 0.4),
        color: '#00bfff'
      });
    }
  }

  // ===== INPUT =====
  function onPointerTap(el, fn) {
    el.addEventListener('pointerdown', (e) => {
      e.preventDefault();
      el.setPointerCapture?.(e.pointerId);
      fn(e);
    });
  }

  onPointerTap(btnJump, () => jump());
  onPointerTap(btnSkillX, () => useSkillX());
  onPointerTap(btnSkillF, () => useSkillF());

  btnCrouch.addEventListener('pointerdown', (e) => {
    e.preventDefault();
    btnCrouch.setPointerCapture?.(e.pointerId);
    crouch(true);
  });
  btnCrouch.addEventListener('pointerup', () => crouch(false));
  btnCrouch.addEventListener('pointercancel', () => crouch(false));
  btnCrouch.addEventListener('pointerleave', () => crouch(false));

  canvas.addEventListener('pointerdown', (e) => {
    e.preventDefault();
    jump();
  });

  btnMenu.addEventListener('click', () => {
    G.running = false;
    canvas.classList.remove('ult-active');
    showScreen('charSelect');
  });

  // Item Shop events
  btnShop.addEventListener('click', () => {
    if (screens.game.classList.contains('active')) {
      openItemShop();
    }
  });
  
  shopClose.addEventListener('click', closeItemShop);
  
  itemShopOverlay.addEventListener('click', (e) => {
    if (e.target === itemShopOverlay) {
      closeItemShop();
    }
  });
  
  // Item slot clicks
  itemSlots.forEach((slot, i) => {
    slot.addEventListener('click', () => useItem(i));
  });

  // Fullscreen toggle
  function toggleFullscreen() {
    const gameWrap = document.querySelector('.game-wrap');
    if (!document.fullscreenElement) {
      if (gameWrap.requestFullscreen) {
        gameWrap.requestFullscreen();
      } else if (gameWrap.webkitRequestFullscreen) {
        gameWrap.webkitRequestFullscreen();
      } else if (gameWrap.msRequestFullscreen) {
        gameWrap.msRequestFullscreen();
      }
      btnFullscreen.textContent = '‚õ∂';
    } else {
      if (document.exitFullscreen) {
        document.exitFullscreen();
      } else if (document.webkitExitFullscreen) {
        document.webkitExitFullscreen();
      }
      btnFullscreen.textContent = '‚õ∂';
    }
  }

  btnFullscreen.addEventListener('click', toggleFullscreen);

  // Music toggle
  function toggleMusic() {
    if (musicPlaying) {
      bgMusic.pause();
      globalMusicBtn.textContent = 'üîá';
      musicPlaying = false;
    } else {
      bgMusic.play().catch(() => {});
      globalMusicBtn.textContent = 'üîä';
      musicPlaying = true;
    }
  }

  globalMusicBtn.addEventListener('click', toggleMusic);

  // Fullscreen deƒüi≈üikliƒüini dinle
  document.addEventListener('fullscreenchange', () => {
    btnFullscreen.textContent = document.fullscreenElement ? '‚õ∂' : '‚õ∂';
    setTimeout(resizeCanvas, 100);
  });

  window.addEventListener('keydown', (e) => {
    if (screens.game.classList.contains('active')) {
      const k = e.key.toLowerCase();
      if (k === ' ' || k === 'arrowup' || k === 'w') { e.preventDefault(); jump(); }
      if (k === 'arrowdown' || k === 's') { e.preventDefault(); crouch(true); }
      if (k === 'x') { e.preventDefault(); useSkillX(); }
      if (k === 'c') { e.preventDefault(); useSkillF(); }
      if (k === 'r') { e.preventDefault(); resetGame(); }
      if (k === 'e') { e.preventDefault(); airDash(); }
      // Item slots 1-2-3
      if (k === '1') { e.preventDefault(); useItem(0); }
      if (k === '2') { e.preventDefault(); useItem(1); }
      if (k === '3') { e.preventDefault(); useItem(2); }
      // Z - Toggle item shop
      if (k === 'z') { 
        e.preventDefault(); 
        if (itemShopOverlay.classList.contains('active')) {
          closeItemShop();
        } else {
          openItemShop();
        }
      }
    }
  });

  window.addEventListener('keyup', (e) => {
    const k = e.key.toLowerCase();
    if (k === 'arrowdown' || k === 's') crouch(false);
  });

  // ===== DRAWING =====
  function drawClouds(dt) {
    const loc = LOCATIONS[selectedLocation];
    ctx.save();
    
    // Draw sky objects based on location
    if (loc.skyObjects === 'moon') {
      // Moon
      ctx.globalAlpha = 0.8;
      ctx.fillStyle = '#f5f5dc';
      ctx.beginPath();
      ctx.arc(400, 80, 35, 0, Math.PI * 2);
      ctx.fill();
      // Moon craters
      ctx.globalAlpha = 0.15;
      ctx.fillStyle = '#aaa';
      ctx.beginPath();
      ctx.arc(390, 70, 8, 0, Math.PI * 2);
      ctx.arc(410, 85, 5, 0, Math.PI * 2);
      ctx.arc(395, 90, 6, 0, Math.PI * 2);
      ctx.fill();
    } else if (loc.skyObjects === 'sun') {
      // Sun
      ctx.globalAlpha = 0.9;
      ctx.fillStyle = '#fff176';
      ctx.shadowColor = '#ffeb3b';
      ctx.shadowBlur = 40;
      ctx.beginPath();
      ctx.arc(380, 70, 40, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;
    } else if (loc.skyObjects === 'sunset') {
      // Sunset sun
      ctx.globalAlpha = 0.9;
      ctx.fillStyle = '#ff5722';
      ctx.shadowColor = '#ff9800';
      ctx.shadowBlur = 60;
      ctx.beginPath();
      ctx.arc(400, 120, 50, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;
    }
    
    // Draw mountains for mountain location
    if (loc.mountains) {
      ctx.globalAlpha = 0.6;
      // Far mountains
      ctx.fillStyle = '#8d6e63';
      ctx.beginPath();
      ctx.moveTo(0, 400);
      ctx.lineTo(80, 280);
      ctx.lineTo(160, 380);
      ctx.lineTo(240, 250);
      ctx.lineTo(320, 350);
      ctx.lineTo(400, 200);
      ctx.lineTo(480, 320);
      ctx.lineTo(480, 400);
      ctx.closePath();
      ctx.fill();
      // Near mountains
      ctx.globalAlpha = 0.8;
      ctx.fillStyle = '#5d4037';
      ctx.beginPath();
      ctx.moveTo(0, 450);
      ctx.lineTo(100, 350);
      ctx.lineTo(180, 420);
      ctx.lineTo(280, 320);
      ctx.lineTo(380, 400);
      ctx.lineTo(480, 300);
      ctx.lineTo(480, 450);
      ctx.closePath();
      ctx.fill();
      // Snow caps
      ctx.fillStyle = '#fff';
      ctx.globalAlpha = 0.7;
      ctx.beginPath();
      ctx.moveTo(240, 250);
      ctx.lineTo(230, 280);
      ctx.lineTo(250, 280);
      ctx.closePath();
      ctx.fill();
      ctx.beginPath();
      ctx.moveTo(400, 200);
      ctx.lineTo(385, 240);
      ctx.lineTo(415, 240);
      ctx.closePath();
      ctx.fill();
    }
    
    // Draw trees for forest location
    if (loc.trees) {
      // Background trees (static, far)
      ctx.globalAlpha = 0.4;
      for (let i = 0; i < 8; i++) {
        const tx = i * 65 + 20;
        const ty = 380;
        const treeH = 80 + (i % 3) * 20;
        // Tree trunk
        ctx.fillStyle = '#3e2723';
        ctx.fillRect(tx - 4, ty - treeH * 0.3, 8, treeH * 0.4);
        // Tree foliage
        ctx.fillStyle = '#1b5e20';
        ctx.beginPath();
        ctx.moveTo(tx, ty - treeH);
        ctx.lineTo(tx - 25, ty - treeH * 0.3);
        ctx.lineTo(tx + 25, ty - treeH * 0.3);
        ctx.closePath();
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(tx, ty - treeH * 0.7);
        ctx.lineTo(tx - 30, ty - treeH * 0.15);
        ctx.lineTo(tx + 30, ty - treeH * 0.15);
        ctx.closePath();
        ctx.fill();
      }
      
      // Foreground bushes
      ctx.globalAlpha = 0.5;
      ctx.fillStyle = '#2e7d32';
      for (let i = 0; i < 6; i++) {
        const bx = i * 90 + 30;
        ctx.beginPath();
        ctx.arc(bx, 490, 25, Math.PI, 0);
        ctx.arc(bx + 20, 490, 20, Math.PI, 0);
        ctx.fill();
      }
    }
    
    // Draw clouds
    for (const c of G.clouds) {
      c.x -= c.v * dt;
      if (c.x < -100) { c.x = WORLD_W + 100; c.y = rand(40, 150); }
      ctx.globalAlpha = loc.cloudAlpha;
      ctx.fillStyle = loc.cloudColor;
      ctx.beginPath();
      ctx.ellipse(c.x, c.y, 24 * c.s, 12 * c.s, 0, 0, Math.PI * 2);
      ctx.ellipse(c.x + 16 * c.s, c.y + 3 * c.s, 20 * c.s, 10 * c.s, 0, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.restore();
  }

  function drawGround() {
    const loc = LOCATIONS[selectedLocation];
    ctx.save();
    
    // Ground fill for forest/mountain
    if (loc.trees || loc.mountains) {
      ctx.fillStyle = loc.trees ? '#1a3d0c' : '#3e2723';
      ctx.fillRect(0, G.groundY, WORLD_W, WORLD_H - G.groundY);
    }
    
    // Main line
    ctx.strokeStyle = loc.groundColor;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(0, G.groundY);
    ctx.lineTo(WORLD_W, G.groundY);
    ctx.stroke();

    // Dashes
    const dashW = 20, gap = 14, total = dashW + gap;
    let x = -(G.groundScroll % total);
    ctx.strokeStyle = loc.dashColor;
    ctx.lineWidth = 5;
    while (x < WORLD_W) {
      ctx.beginPath();
      ctx.moveTo(x, G.groundY + 12);
      ctx.lineTo(x + dashW, G.groundY + 12);
      ctx.stroke();
      x += total;
    }
    ctx.restore();
  }

  function drawPlayer() {
    const pr = playerRect();
    const char = CHARACTERS[selectedChar];

    ctx.save();

    // Shadow
    ctx.globalAlpha = 0.25;
    ctx.fillStyle = '#000';
    ctx.beginPath();
    const shadowScale = P.onGround ? 1 : 0.6;
    ctx.ellipse(pr.x + pr.w / 2, G.groundY + 8, 18 * shadowScale, 6 * shadowScale, 0, 0, Math.PI * 2);
    ctx.fill();

    // Item effect auras
    if (G.activeItem) {
      ctx.globalAlpha = 0.5 + Math.sin(G.t * 8) * 0.2;
      
      if (G.activeItem === 'lightning_armor') {
        // Yellow lightning aura
        const grad = ctx.createRadialGradient(pr.x + pr.w/2, pr.y + pr.h/2, 0, pr.x + pr.w/2, pr.y + pr.h/2, 70);
        grad.addColorStop(0, 'rgba(251, 191, 36, 0.8)');
        grad.addColorStop(0.5, 'rgba(245, 158, 11, 0.4)');
        grad.addColorStop(1, 'rgba(245, 158, 11, 0)');
        ctx.fillStyle = grad;
        ctx.fillRect(pr.x - 40, pr.y - 40, pr.w + 80, pr.h + 80);
        
        // Lightning bolts around player
        ctx.strokeStyle = '#fbbf24';
        ctx.lineWidth = 2;
        for (let i = 0; i < 4; i++) {
          const angle = G.t * 5 + i * Math.PI / 2;
          const dist = 40 + Math.sin(G.t * 10 + i) * 10;
          const lx = pr.x + pr.w/2 + Math.cos(angle) * dist;
          const ly = pr.y + pr.h/2 + Math.sin(angle) * dist * 0.7;
          ctx.beginPath();
          ctx.moveTo(lx, ly - 10);
          ctx.lineTo(lx + 3, ly);
          ctx.lineTo(lx - 3, ly);
          ctx.lineTo(lx, ly + 10);
          ctx.stroke();
        }
      } else if (G.activeItem === 'ishigakure_necklace') {
        // Red aura for rapid fire
        const grad = ctx.createRadialGradient(pr.x + pr.w/2, pr.y + pr.h/2, 0, pr.x + pr.w/2, pr.y + pr.h/2, 60);
        grad.addColorStop(0, 'rgba(239, 68, 68, 0.6)');
        grad.addColorStop(0.6, 'rgba(239, 68, 68, 0.3)');
        grad.addColorStop(1, 'rgba(239, 68, 68, 0)');
        ctx.fillStyle = grad;
        ctx.fillRect(pr.x - 30, pr.y - 30, pr.w + 60, pr.h + 60);
      } else if (G.activeItem === 'viagra') {
        // Green aura for slow enemies
        const grad = ctx.createRadialGradient(pr.x + pr.w/2, pr.y + pr.h/2, 0, pr.x + pr.w/2, pr.y + pr.h/2, 65);
        grad.addColorStop(0, 'rgba(34, 197, 94, 0.6)');
        grad.addColorStop(0.6, 'rgba(34, 197, 94, 0.3)');
        grad.addColorStop(1, 'rgba(34, 197, 94, 0)');
        ctx.fillStyle = grad;
        ctx.fillRect(pr.x - 35, pr.y - 35, pr.w + 70, pr.h + 70);
      }
      
      ctx.globalAlpha = 1;
    }

    // Ultimate effects
    if (G.ultActive) {
      ctx.globalAlpha = 0.4 + Math.sin(G.t * 10) * 0.2;
      if (G.ultType === 'moonlight') {
        // Haru: Glowing aura
        const grad = ctx.createRadialGradient(pr.x + pr.w/2, pr.y + pr.h/2, 0, pr.x + pr.w/2, pr.y + pr.h/2, 60);
        grad.addColorStop(0, 'rgba(255,255,255,0.8)');
        grad.addColorStop(1, 'rgba(255,255,255,0)');
        ctx.fillStyle = grad;
        ctx.fillRect(pr.x - 30, pr.y - 30, pr.w + 60, pr.h + 60);
      } else if (G.ultType === 'eagleFlight') {
        // Ringo: Draw full eagle carrying the ninja
        const eagleCenterX = pr.x + pr.w / 2;
        const eagleCenterY = pr.y + pr.h / 2 - 10;
        const wingFlap = Math.sin(G.eagleWingPhase) * 25;
        
        // Eagle glow
        ctx.globalAlpha = 0.3;
        const eagleGlow = ctx.createRadialGradient(eagleCenterX, eagleCenterY - 20, 0, eagleCenterX, eagleCenterY - 20, 80);
        eagleGlow.addColorStop(0, 'rgba(139, 92, 246, 0.6)');
        eagleGlow.addColorStop(1, 'rgba(139, 92, 246, 0)');
        ctx.fillStyle = eagleGlow;
        ctx.fillRect(eagleCenterX - 100, eagleCenterY - 80, 200, 120);
        
        ctx.globalAlpha = 1;
        
        // Left wing
        ctx.fillStyle = '#5b4a3f';
        ctx.strokeStyle = '#8b7355';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(eagleCenterX - 10, eagleCenterY - 15);
        ctx.quadraticCurveTo(eagleCenterX - 50, eagleCenterY - 50 - wingFlap, eagleCenterX - 90, eagleCenterY - 30 - wingFlap * 0.5);
        ctx.quadraticCurveTo(eagleCenterX - 70, eagleCenterY - 20, eagleCenterX - 40, eagleCenterY - 10);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        
        // Right wing
        ctx.beginPath();
        ctx.moveTo(eagleCenterX + 10, eagleCenterY - 15);
        ctx.quadraticCurveTo(eagleCenterX + 50, eagleCenterY - 50 - wingFlap, eagleCenterX + 90, eagleCenterY - 30 - wingFlap * 0.5);
        ctx.quadraticCurveTo(eagleCenterX + 70, eagleCenterY - 20, eagleCenterX + 40, eagleCenterY - 10);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        
        // Eagle body
        ctx.fillStyle = '#6b5344';
        ctx.beginPath();
        ctx.ellipse(eagleCenterX, eagleCenterY - 20, 22, 16, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        
        // Eagle head
        ctx.fillStyle = '#f5f5dc';
        ctx.beginPath();
        ctx.arc(eagleCenterX + 25, eagleCenterY - 28, 12, 0, Math.PI * 2);
        ctx.fill();
        
        // Beak
        ctx.fillStyle = '#ffa500';
        ctx.beginPath();
        ctx.moveTo(eagleCenterX + 35, eagleCenterY - 28);
        ctx.lineTo(eagleCenterX + 48, eagleCenterY - 26);
        ctx.lineTo(eagleCenterX + 35, eagleCenterY - 24);
        ctx.closePath();
        ctx.fill();
        
        // Eagle eye
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.arc(eagleCenterX + 30, eagleCenterY - 30, 3, 0, Math.PI * 2);
        ctx.fill();
        
        // Tail feathers
        ctx.fillStyle = '#5b4a3f';
        ctx.beginPath();
        ctx.moveTo(eagleCenterX - 20, eagleCenterY - 15);
        ctx.lineTo(eagleCenterX - 45, eagleCenterY - 5);
        ctx.lineTo(eagleCenterX - 40, eagleCenterY - 12);
        ctx.lineTo(eagleCenterX - 50, eagleCenterY - 8);
        ctx.lineTo(eagleCenterX - 25, eagleCenterY - 18);
        ctx.closePath();
        ctx.fill();
        
        // Talons holding ninja
        ctx.strokeStyle = '#ffa500';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(eagleCenterX - 8, eagleCenterY - 5);
        ctx.lineTo(eagleCenterX - 8, eagleCenterY + 15);
        ctx.moveTo(eagleCenterX + 8, eagleCenterY - 5);
        ctx.lineTo(eagleCenterX + 8, eagleCenterY + 15);
        ctx.stroke();
      } else if (G.ultType === 'iceStorm') {
        // Usagi: Ice storm swirling around
        ctx.globalAlpha = 0.6;
        
        // Swirling ice vortex
        for (let i = 0; i < 12; i++) {
          const angle = G.t * 4 + i * Math.PI / 6;
          const dist = 40 + Math.sin(G.t * 8 + i) * 10;
          const iceX = pr.x + pr.w/2 + Math.cos(angle) * dist;
          const iceY = pr.y + pr.h/2 + Math.sin(angle) * dist * 0.6;
          
          // Ice shards
          ctx.save();
          ctx.translate(iceX, iceY);
          ctx.rotate(angle + G.t * 3);
          
          ctx.fillStyle = '#67e8f9';
          ctx.beginPath();
          ctx.moveTo(0, -8);
          ctx.lineTo(4, 0);
          ctx.lineTo(0, 8);
          ctx.lineTo(-4, 0);
          ctx.closePath();
          ctx.fill();
          
          ctx.restore();
        }
        
        // Snowflakes
        ctx.fillStyle = '#fff';
        for (let i = 0; i < 8; i++) {
          const angle = -G.t * 3 + i * Math.PI / 4;
          const dist = 55 + Math.sin(G.t * 6 + i * 2) * 8;
          const flakeX = pr.x + pr.w/2 + Math.cos(angle) * dist;
          const flakeY = pr.y + pr.h/2 + Math.sin(angle) * dist * 0.5;
          ctx.beginPath();
          ctx.arc(flakeX, flakeY, 3 + Math.sin(G.t * 10 + i) * 1.5, 0, Math.PI * 2);
          ctx.fill();
        }
        
        // Cold aura
        const grad = ctx.createRadialGradient(pr.x + pr.w/2, pr.y + pr.h/2, 0, pr.x + pr.w/2, pr.y + pr.h/2, 70);
        grad.addColorStop(0, 'rgba(103, 232, 249, 0.3)');
        grad.addColorStop(0.5, 'rgba(103, 232, 249, 0.15)');
        grad.addColorStop(1, 'rgba(103, 232, 249, 0)');
        ctx.fillStyle = grad;
        ctx.fillRect(pr.x - 50, pr.y - 50, pr.w + 100, pr.h + 100);
      } else if (G.ultType === 'swordStorm') {
        // Chisa: Sword storm aura
        const grad = ctx.createRadialGradient(pr.x + pr.w/2, pr.y + pr.h/2, 0, pr.x + pr.w/2, pr.y + pr.h/2, 50);
        grad.addColorStop(0, 'rgba(231,76,60,0.6)');
        grad.addColorStop(1, 'rgba(231,76,60,0)');
        ctx.fillStyle = grad;
        ctx.fillRect(pr.x - 25, pr.y - 25, pr.w + 50, pr.h + 50);
        // Spinning blades effect
        ctx.strokeStyle = '#e74c3c';
        ctx.lineWidth = 3;
        for (let i = 0; i < 3; i++) {
          const angle = G.t * 8 + i * Math.PI * 2 / 3;
          const dist = 30;
          ctx.beginPath();
          ctx.moveTo(pr.x + pr.w/2 + Math.cos(angle) * dist, pr.y + pr.h/2 + Math.sin(angle) * dist);
          ctx.lineTo(pr.x + pr.w/2 + Math.cos(angle + 0.3) * (dist + 15), pr.y + pr.h/2 + Math.sin(angle + 0.3) * (dist + 15));
          ctx.stroke();
        }
      } else if (G.ultType === 'headbutt') {
        // Butsuo: Head-first flying pose with power aura
        const grad = ctx.createRadialGradient(pr.x + pr.w + 20, pr.y + pr.h/2, 0, pr.x + pr.w + 20, pr.y + pr.h/2, 80);
        grad.addColorStop(0, 'rgba(255,255,255,0.6)');
        grad.addColorStop(0.5, 'rgba(236,240,241,0.3)');
        grad.addColorStop(1, 'rgba(236,240,241,0)');
        ctx.fillStyle = grad;
        ctx.fillRect(pr.x - 20, pr.y - 40, pr.w + 100, pr.h + 80);
        
        // Speed lines behind
        ctx.strokeStyle = 'rgba(255,255,255,0.6)';
        ctx.lineWidth = 3;
        for (let i = 0; i < 6; i++) {
          const lineY = pr.y + pr.h * 0.2 + i * 12;
          const offset = Math.sin(G.t * 15 + i) * 5;
          ctx.beginPath();
          ctx.moveTo(pr.x - 40 + offset, lineY);
          ctx.lineTo(pr.x - 80 + offset, lineY);
          ctx.stroke();
        }
        
        // Impact waves in front of head
        ctx.strokeStyle = 'rgba(255,200,50,0.5)';
        ctx.lineWidth = 4;
        for (let i = 0; i < 3; i++) {
          const waveOffset = (G.t * 10 + i * 0.5) % 1;
          ctx.globalAlpha = 0.5 * (1 - waveOffset);
          ctx.beginPath();
          ctx.arc(pr.x + pr.w + 30, pr.y + 10, 15 + waveOffset * 25, -0.5, 0.5);
          ctx.stroke();
        }
        ctx.globalAlpha = 0.4 + Math.sin(G.t * 10) * 0.2;
      } else if (G.ultType === 'poisonArmor') {
        // Teki: Poison armor shield
        ctx.globalAlpha = 0.5 + Math.sin(G.t * 8) * 0.2;
        const grad = ctx.createRadialGradient(pr.x + pr.w/2, pr.y + pr.h/2, 0, pr.x + pr.w/2, pr.y + pr.h/2, 55);
        grad.addColorStop(0, 'rgba(46, 204, 113, 0.3)');
        grad.addColorStop(0.7, 'rgba(39, 174, 96, 0.5)');
        grad.addColorStop(1, 'rgba(30, 132, 73, 0)');
        ctx.fillStyle = grad;
        ctx.fillRect(pr.x - 30, pr.y - 30, pr.w + 60, pr.h + 60);
        
        // Poison bubbles around
        ctx.fillStyle = '#2ecc71';
        for (let i = 0; i < 6; i++) {
          const angle = G.t * 2 + i * Math.PI / 3;
          const dist = 35 + Math.sin(G.t * 4 + i) * 5;
          const bubbleSize = 4 + Math.sin(G.t * 6 + i * 2) * 2;
          ctx.beginPath();
          ctx.arc(
            pr.x + pr.w/2 + Math.cos(angle) * dist,
            pr.y + pr.h/2 + Math.sin(angle) * dist,
            bubbleSize, 0, Math.PI * 2
          );
          ctx.fill();
        }
      } else if (G.ultType === 'monkeyFriend') {
        // Teki: Monkey friend running alongside
        const monkeyX = pr.x + pr.w + 20;
        const monkeyY = G.groundY;
        const bounce = Math.abs(Math.sin(G.t * 12)) * 15;
        const armSwing = Math.sin(G.t * 15) * 0.4;
        
        ctx.save();
        ctx.translate(monkeyX, monkeyY - bounce);
        
        // Monkey body
        ctx.fillStyle = '#8B4513';
        ctx.beginPath();
        ctx.ellipse(0, -20, 18, 22, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Monkey head
        ctx.beginPath();
        ctx.arc(5, -45, 16, 0, Math.PI * 2);
        ctx.fill();
        
        // Face
        ctx.fillStyle = '#DEB887';
        ctx.beginPath();
        ctx.ellipse(8, -43, 10, 12, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Eyes
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.arc(4, -46, 3, 0, Math.PI * 2);
        ctx.arc(12, -46, 3, 0, Math.PI * 2);
        ctx.fill();
        
        // Mouth
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(8, -40, 5, 0.2, Math.PI - 0.2);
        ctx.stroke();
        
        // Ears
        ctx.fillStyle = '#8B4513';
        ctx.beginPath();
        ctx.arc(-8, -50, 7, 0, Math.PI * 2);
        ctx.arc(20, -50, 7, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#DEB887';
        ctx.beginPath();
        ctx.arc(-8, -50, 4, 0, Math.PI * 2);
        ctx.arc(20, -50, 4, 0, Math.PI * 2);
        ctx.fill();
        
        // Arms swinging
        ctx.fillStyle = '#8B4513';
        ctx.save();
        ctx.translate(-12, -25);
        ctx.rotate(armSwing);
        ctx.fillRect(-4, 0, 8, 25);
        ctx.restore();
        ctx.save();
        ctx.translate(12, -25);
        ctx.rotate(-armSwing);
        ctx.fillRect(-4, 0, 8, 25);
        ctx.restore();
        
        // Legs running
        ctx.save();
        ctx.translate(-8, -5);
        ctx.rotate(-armSwing * 0.8);
        ctx.fillRect(-4, 0, 8, 20);
        ctx.restore();
        ctx.save();
        ctx.translate(8, -5);
        ctx.rotate(armSwing * 0.8);
        ctx.fillRect(-4, 0, 8, 20);
        ctx.restore();
        
        // Tail
        ctx.strokeStyle = '#8B4513';
        ctx.lineWidth = 6;
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(-15, -15);
        ctx.quadraticCurveTo(-35, -25 + Math.sin(G.t * 8) * 10, -40, -40 + Math.sin(G.t * 6) * 15);
        ctx.stroke();
        
        // Dust clouds from running
        ctx.fillStyle = 'rgba(139, 69, 19, 0.3)';
        for (let i = 0; i < 3; i++) {
          const dustX = -30 - i * 20 + Math.sin(G.t * 10 + i) * 5;
          const dustY = 5 + Math.sin(G.t * 8 + i * 2) * 3;
          ctx.beginPath();
          ctx.arc(dustX, dustY, 8 - i * 2, 0, Math.PI * 2);
          ctx.fill();
        }
        
        ctx.restore();
        
        // Store monkey hitbox for collision
        G.monkeyRect = {
          x: monkeyX - 18,
          y: monkeyY - bounce - 60,
          w: 40,
          h: 60
        };
      } else if (G.ultType === 'animalFriends') {
        // Susumu: Bird, dog, and squirrel friends
        const bounce1 = Math.abs(Math.sin(G.t * 10)) * 10;
        const bounce2 = Math.abs(Math.sin(G.t * 12 + 1)) * 12;
        const bounce3 = Math.abs(Math.sin(G.t * 14 + 2)) * 8;
        
        // === DOG (running on ground) ===
        const dogX = pr.x + pr.w + 30;
        const dogY = G.groundY;
        ctx.save();
        ctx.translate(dogX, dogY - bounce1);
        
        // Dog body
        ctx.fillStyle = '#D2691E';
        ctx.beginPath();
        ctx.ellipse(0, -18, 25, 15, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Dog head
        ctx.beginPath();
        ctx.arc(20, -25, 14, 0, Math.PI * 2);
        ctx.fill();
        
        // Snout
        ctx.fillStyle = '#F4A460';
        ctx.beginPath();
        ctx.ellipse(30, -22, 8, 6, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Nose
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.arc(35, -22, 3, 0, Math.PI * 2);
        ctx.fill();
        
        // Eye
        ctx.beginPath();
        ctx.arc(22, -28, 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(21, -29, 1.5, 0, Math.PI * 2);
        ctx.fill();
        
        // Ears
        ctx.fillStyle = '#8B4513';
        ctx.beginPath();
        ctx.ellipse(12, -36, 6, 10, -0.3, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.ellipse(26, -36, 6, 10, 0.3, 0, Math.PI * 2);
        ctx.fill();
        
        // Legs running
        const legSwing = Math.sin(G.t * 15) * 0.5;
        ctx.fillStyle = '#D2691E';
        ctx.save();
        ctx.translate(-15, -5);
        ctx.rotate(legSwing);
        ctx.fillRect(-3, 0, 6, 18);
        ctx.restore();
        ctx.save();
        ctx.translate(-5, -5);
        ctx.rotate(-legSwing);
        ctx.fillRect(-3, 0, 6, 18);
        ctx.restore();
        ctx.save();
        ctx.translate(8, -5);
        ctx.rotate(legSwing);
        ctx.fillRect(-3, 0, 6, 18);
        ctx.restore();
        ctx.save();
        ctx.translate(18, -5);
        ctx.rotate(-legSwing);
        ctx.fillRect(-3, 0, 6, 18);
        ctx.restore();
        
        // Tail wagging
        ctx.strokeStyle = '#D2691E';
        ctx.lineWidth = 6;
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(-22, -20);
        ctx.quadraticCurveTo(-35, -30 + Math.sin(G.t * 12) * 10, -40, -40 + Math.sin(G.t * 10) * 8);
        ctx.stroke();
        
        ctx.restore();
        
        // === SQUIRREL (slightly behind) ===
        const squirrelX = pr.x + pr.w + 80;
        const squirrelY = G.groundY;
        ctx.save();
        ctx.translate(squirrelX, squirrelY - bounce2);
        
        // Squirrel body
        ctx.fillStyle = '#A0522D';
        ctx.beginPath();
        ctx.ellipse(0, -12, 10, 12, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Head
        ctx.beginPath();
        ctx.arc(8, -22, 9, 0, Math.PI * 2);
        ctx.fill();
        
        // Ears
        ctx.beginPath();
        ctx.ellipse(4, -30, 4, 6, -0.3, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.ellipse(12, -30, 4, 6, 0.3, 0, Math.PI * 2);
        ctx.fill();
        
        // Eye
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.arc(12, -23, 3, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(11, -24, 1, 0, Math.PI * 2);
        ctx.fill();
        
        // Nose
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.arc(16, -20, 2, 0, Math.PI * 2);
        ctx.fill();
        
        // Fluffy tail
        ctx.fillStyle = '#8B4513';
        const tailWave = Math.sin(G.t * 8) * 0.3;
        ctx.save();
        ctx.translate(-8, -15);
        ctx.rotate(tailWave);
        ctx.beginPath();
        ctx.ellipse(0, -15, 8, 20, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.ellipse(-3, -30, 6, 10, -0.5, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
        
        // Little paws running
        ctx.fillStyle = '#A0522D';
        const pawSwing = Math.sin(G.t * 18) * 0.4;
        ctx.save();
        ctx.translate(-5, -2);
        ctx.rotate(pawSwing);
        ctx.fillRect(-2, 0, 4, 10);
        ctx.restore();
        ctx.save();
        ctx.translate(5, -2);
        ctx.rotate(-pawSwing);
        ctx.fillRect(-2, 0, 4, 10);
        ctx.restore();
        
        ctx.restore();
        
        // === BIRD (flying above) ===
        const birdX = pr.x + pr.w/2 + 40 + Math.sin(G.t * 3) * 20;
        const birdY = pr.y - 50 + Math.sin(G.t * 5) * 15;
        const wingFlap = Math.sin(G.t * 15) * 0.6;
        
        ctx.save();
        ctx.translate(birdX, birdY);
        
        // Body
        ctx.fillStyle = '#3498db';
        ctx.beginPath();
        ctx.ellipse(0, 0, 12, 8, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Head
        ctx.beginPath();
        ctx.arc(10, -3, 7, 0, Math.PI * 2);
        ctx.fill();
        
        // Beak
        ctx.fillStyle = '#f39c12';
        ctx.beginPath();
        ctx.moveTo(15, -3);
        ctx.lineTo(22, -2);
        ctx.lineTo(15, 0);
        ctx.closePath();
        ctx.fill();
        
        // Eye
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.arc(12, -5, 2, 0, Math.PI * 2);
        ctx.fill();
        
        // Wings flapping
        ctx.fillStyle = '#2980b9';
        ctx.save();
        ctx.rotate(wingFlap);
        ctx.beginPath();
        ctx.ellipse(-5, -8, 15, 6, -0.5, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
        ctx.save();
        ctx.rotate(-wingFlap);
        ctx.beginPath();
        ctx.ellipse(-5, 8, 15, 6, 0.5, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
        
        // Tail feathers
        ctx.fillStyle = '#2980b9';
        ctx.beginPath();
        ctx.moveTo(-10, 0);
        ctx.lineTo(-22, -5);
        ctx.lineTo(-20, 0);
        ctx.lineTo(-22, 5);
        ctx.closePath();
        ctx.fill();
        
        ctx.restore();
        
        // Store animal hitboxes for collision
        G.animalRects = [
          { x: dogX - 25, y: dogY - bounce1 - 40, w: 60, h: 45 },
          { x: squirrelX - 15, y: squirrelY - bounce2 - 35, w: 30, h: 40 },
          { x: birdX - 15, y: birdY - 15, w: 35, h: 25 }
        ];
      } else if (G.ultType === 'illusionStorm') {
        // Shinji: Purple illusion storm
        ctx.globalAlpha = 0.6;
        
        // Swirling purple vortex around player
        for (let i = 0; i < 8; i++) {
          const angle = G.t * 3 + i * Math.PI / 4;
          const dist = 40 + Math.sin(G.t * 5 + i) * 15;
          const size = 15 + Math.sin(G.t * 7 + i * 2) * 5;
          
          // Illusion copies/ghosts
          ctx.fillStyle = `rgba(155, 89, 182, ${0.3 + Math.sin(G.t * 4 + i) * 0.2})`;
          ctx.beginPath();
          ctx.arc(
            pr.x + pr.w/2 + Math.cos(angle) * dist,
            pr.y + pr.h/2 + Math.sin(angle) * dist * 0.7,
            size, 0, Math.PI * 2
          );
          ctx.fill();
        }
        
        // Central eye effect
        ctx.fillStyle = '#9b59b6';
        ctx.shadowColor = '#9b59b6';
        ctx.shadowBlur = 25;
        ctx.beginPath();
        ctx.arc(pr.x + pr.w/2, pr.y + 10, 12 + Math.sin(G.t * 8) * 3, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(pr.x + pr.w/2, pr.y + 10, 5, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
        
        // Spiral lines
        ctx.strokeStyle = 'rgba(155, 89, 182, 0.5)';
        ctx.lineWidth = 3;
        for (let i = 0; i < 3; i++) {
          ctx.beginPath();
          for (let j = 0; j < 20; j++) {
            const a = G.t * 2 + i * Math.PI * 2/3 + j * 0.3;
            const r = 20 + j * 4;
            const x = pr.x + pr.w/2 + Math.cos(a) * r;
            const y = pr.y + pr.h/2 + Math.sin(a) * r * 0.5;
            if (j === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
          }
          ctx.stroke();
        }
      } else if (G.ultType === 'windSword') {
        // Kazuya: Massive wind sword aura
        ctx.globalAlpha = 0.5;
        
        // Wind aura around player
        const grad = ctx.createRadialGradient(pr.x + pr.w/2, pr.y + pr.h/2, 0, pr.x + pr.w/2, pr.y + pr.h/2, 80);
        grad.addColorStop(0, 'rgba(52, 152, 219, 0.2)');
        grad.addColorStop(0.5, 'rgba(52, 152, 219, 0.4)');
        grad.addColorStop(1, 'rgba(52, 152, 219, 0)');
        ctx.fillStyle = grad;
        ctx.fillRect(pr.x - 60, pr.y - 40, pr.w + 200, pr.h + 80);
        
        // Giant wind sword extending forward
        ctx.save();
        ctx.translate(pr.x + pr.w + 20, pr.y + pr.h * 0.4);
        
        // Sword blade made of wind
        const swordWave = Math.sin(G.t * 10) * 5;
        ctx.fillStyle = 'rgba(135, 206, 235, 0.7)';
        ctx.beginPath();
        ctx.moveTo(0, -15 + swordWave);
        ctx.lineTo(120, -8);
        ctx.lineTo(140, 0);
        ctx.lineTo(120, 8);
        ctx.lineTo(0, 15 + swordWave);
        ctx.closePath();
        ctx.fill();
        
        // Wind streaks
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.globalAlpha = 0.6;
        for (let i = 0; i < 5; i++) {
          const yOff = -10 + i * 5;
          const xStart = 10 + Math.sin(G.t * 15 + i) * 10;
          ctx.beginPath();
          ctx.moveTo(xStart, yOff);
          ctx.lineTo(xStart + 60 + Math.random() * 30, yOff + Math.sin(G.t * 8 + i) * 3);
          ctx.stroke();
        }
        
        ctx.restore();
        
        // Cutting waves flying forward
        ctx.strokeStyle = 'rgba(135, 206, 235, 0.8)';
        ctx.lineWidth = 4;
        for (let i = 0; i < 3; i++) {
          const waveX = pr.x + pr.w + 50 + ((G.t * 200 + i * 60) % 150);
          ctx.beginPath();
          ctx.arc(waveX, pr.y + pr.h/2, 20 + i * 5, -0.8, 0.8);
          ctx.stroke();
        }
      } else if (G.ultType === 'darkAura') {
        // Togami: Giant crow flying alongside
        const crowX = pr.x + pr.w + 60;
        const crowY = pr.y - 40;
        const wingFlap = Math.sin(G.t * 8) * 0.4;
        const hover = Math.sin(G.t * 4) * 8;
        
        ctx.save();
        ctx.translate(crowX, crowY + hover);
        
        // Shadow on ground
        ctx.globalAlpha = 0.3;
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.ellipse(0, G.groundY - crowY - hover + 30, 80, 20, 0, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.globalAlpha = 1;
        
        // Left wing
        ctx.save();
        ctx.rotate(wingFlap);
        ctx.fillStyle = '#1a1a1a';
        ctx.beginPath();
        ctx.moveTo(-10, 0);
        ctx.quadraticCurveTo(-80, -30 - wingFlap * 30, -120, 10);
        ctx.quadraticCurveTo(-90, 20, -60, 15);
        ctx.quadraticCurveTo(-40, 10, -10, 5);
        ctx.closePath();
        ctx.fill();
        // Wing feather details
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 2;
        for (let i = 0; i < 5; i++) {
          ctx.beginPath();
          ctx.moveTo(-20 - i * 18, 5 - i * 5);
          ctx.lineTo(-30 - i * 20, -10 - wingFlap * 20 + i * 3);
          ctx.stroke();
        }
        ctx.restore();
        
        // Right wing
        ctx.save();
        ctx.rotate(-wingFlap);
        ctx.fillStyle = '#1a1a1a';
        ctx.beginPath();
        ctx.moveTo(10, 0);
        ctx.quadraticCurveTo(80, -30 + wingFlap * 30, 120, 10);
        ctx.quadraticCurveTo(90, 20, 60, 15);
        ctx.quadraticCurveTo(40, 10, 10, 5);
        ctx.closePath();
        ctx.fill();
        // Wing feather details
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 2;
        for (let i = 0; i < 5; i++) {
          ctx.beginPath();
          ctx.moveTo(20 + i * 18, 5 - i * 5);
          ctx.lineTo(30 + i * 20, -10 + wingFlap * 20 + i * 3);
          ctx.stroke();
        }
        ctx.restore();
        
        // Body
        ctx.fillStyle = '#0a0a0a';
        ctx.beginPath();
        ctx.ellipse(0, 10, 35, 45, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Head
        ctx.beginPath();
        ctx.arc(0, -40, 28, 0, Math.PI * 2);
        ctx.fill();
        
        // Beak
        ctx.fillStyle = '#333';
        ctx.beginPath();
        ctx.moveTo(0, -35);
        ctx.lineTo(25, -45);
        ctx.lineTo(30, -40);
        ctx.lineTo(5, -30);
        ctx.closePath();
        ctx.fill();
        // Beak detail
        ctx.strokeStyle = '#222';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(5, -35);
        ctx.lineTo(25, -42);
        ctx.stroke();
        
        // Eye - glowing red
        ctx.fillStyle = '#e74c3c';
        ctx.shadowColor = '#e74c3c';
        ctx.shadowBlur = 15;
        ctx.beginPath();
        ctx.arc(12, -45, 6, 0, Math.PI * 2);
        ctx.fill();
        // Eye pupil
        ctx.fillStyle = '#000';
        ctx.shadowBlur = 0;
        ctx.beginPath();
        ctx.arc(13, -45, 3, 0, Math.PI * 2);
        ctx.fill();
        // Eye shine
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(10, -47, 2, 0, Math.PI * 2);
        ctx.fill();
        
        // Tail feathers
        ctx.fillStyle = '#1a1a1a';
        ctx.beginPath();
        ctx.moveTo(-15, 50);
        ctx.lineTo(-25, 90);
        ctx.lineTo(-10, 85);
        ctx.lineTo(0, 95);
        ctx.lineTo(10, 85);
        ctx.lineTo(25, 90);
        ctx.lineTo(15, 50);
        ctx.closePath();
        ctx.fill();
        
        // Feathers falling
        ctx.fillStyle = '#1a1a1a';
        for (let i = 0; i < 4; i++) {
          const featherY = ((G.t * 80 + i * 40) % 120);
          const featherX = Math.sin(G.t * 3 + i * 2) * 30 - 50 - i * 20;
          ctx.save();
          ctx.translate(featherX, featherY);
          ctx.rotate(Math.sin(G.t * 4 + i) * 0.5);
          ctx.globalAlpha = 0.7;
          ctx.beginPath();
          ctx.ellipse(0, 0, 12, 4, 0, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        }
        
        ctx.restore();
        
        // Store crow hitbox for collision
        G.crowRect = {
          x: crowX - 100,
          y: crowY + hover - 60,
          w: 200,
          h: 150
        };
      } else if (G.ultType === 'paperWings') {
        // Kagi: Paper wings - she flies with origami wings
        const wingFlap = Math.sin(G.t * 10) * 0.3;
        const centerX = pr.x + pr.w / 2;
        const centerY = pr.y + pr.h / 2;
        
        // Paper particles floating around
        ctx.globalAlpha = 0.6;
        ctx.fillStyle = '#fff';
        for (let i = 0; i < 8; i++) {
          const angle = G.t * 2 + i * Math.PI / 4;
          const dist = 50 + Math.sin(G.t * 3 + i) * 20;
          const px = centerX + Math.cos(angle) * dist;
          const py = centerY + Math.sin(angle) * dist * 0.6;
          ctx.save();
          ctx.translate(px, py);
          ctx.rotate(G.t * 4 + i);
          ctx.fillRect(-6, -4, 12, 8);
          ctx.restore();
        }
        
        ctx.globalAlpha = 1;
        
        // Left paper wing
        ctx.save();
        ctx.translate(centerX - 10, centerY - 5);
        ctx.rotate(-0.2 + wingFlap);
        
        // Wing base layer
        ctx.fillStyle = '#fff';
        ctx.shadowColor = '#fff';
        ctx.shadowBlur = 15;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(-30, -40);
        ctx.lineTo(-60, -30);
        ctx.lineTo(-80, -50);
        ctx.lineTo(-70, -10);
        ctx.lineTo(-90, 10);
        ctx.lineTo(-50, 5);
        ctx.lineTo(-30, 20);
        ctx.lineTo(0, 10);
        ctx.closePath();
        ctx.fill();
        
        // Wing fold lines
        ctx.strokeStyle = '#ddd';
        ctx.lineWidth = 1;
        ctx.shadowBlur = 0;
        ctx.beginPath();
        ctx.moveTo(0, 5);
        ctx.lineTo(-60, -20);
        ctx.moveTo(-20, -10);
        ctx.lineTo(-70, -30);
        ctx.moveTo(-10, 10);
        ctx.lineTo(-60, 0);
        ctx.stroke();
        
        ctx.restore();
        
        // Right paper wing
        ctx.save();
        ctx.translate(centerX + 10, centerY - 5);
        ctx.rotate(0.2 - wingFlap);
        
        ctx.fillStyle = '#fff';
        ctx.shadowColor = '#fff';
        ctx.shadowBlur = 15;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(30, -40);
        ctx.lineTo(60, -30);
        ctx.lineTo(80, -50);
        ctx.lineTo(70, -10);
        ctx.lineTo(90, 10);
        ctx.lineTo(50, 5);
        ctx.lineTo(30, 20);
        ctx.lineTo(0, 10);
        ctx.closePath();
        ctx.fill();
        
        // Wing fold lines
        ctx.strokeStyle = '#ddd';
        ctx.lineWidth = 1;
        ctx.shadowBlur = 0;
        ctx.beginPath();
        ctx.moveTo(0, 5);
        ctx.lineTo(60, -20);
        ctx.moveTo(20, -10);
        ctx.lineTo(70, -30);
        ctx.moveTo(10, 10);
        ctx.lineTo(60, 0);
        ctx.stroke();
        
        ctx.restore();
        
        // Small paper trail
        ctx.fillStyle = '#fff';
        ctx.globalAlpha = 0.5;
        for (let i = 0; i < 5; i++) {
          const trailX = centerX - 40 - i * 25;
          const trailY = centerY + Math.sin(G.t * 6 + i * 2) * 10;
          ctx.save();
          ctx.translate(trailX, trailY);
          ctx.rotate(G.t * 5 + i);
          ctx.beginPath();
          ctx.moveTo(-8, 0);
          ctx.lineTo(0, -5);
          ctx.lineTo(8, 0);
          ctx.lineTo(0, 5);
          ctx.closePath();
          ctx.fill();
          ctx.restore();
        }
      } else if (G.ultType === 'fireDragon') {
        // Akemi: Giant fire dragon flying alongside
        const dragonX = pr.x + pr.w + 80;
        const dragonY = pr.y - 30;
        const wingFlap = Math.sin(G.t * 6) * 0.3;
        const bodyWave = Math.sin(G.t * 4) * 10;
        
        ctx.save();
        ctx.translate(dragonX, dragonY + bodyWave);
        
        // Fire glow around dragon
        ctx.globalAlpha = 0.4;
        const fireGlow = ctx.createRadialGradient(0, 0, 0, 0, 0, 120);
        fireGlow.addColorStop(0, 'rgba(255, 100, 0, 0.8)');
        fireGlow.addColorStop(0.5, 'rgba(255, 50, 0, 0.4)');
        fireGlow.addColorStop(1, 'rgba(255, 0, 0, 0)');
        ctx.fillStyle = fireGlow;
        ctx.fillRect(-120, -80, 240, 160);
        
        ctx.globalAlpha = 1;
        
        // Dragon body (serpentine)
        ctx.fillStyle = '#c0392b';
        ctx.beginPath();
        ctx.ellipse(0, 0, 50, 30, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Dragon scales pattern
        ctx.fillStyle = '#e74c3c';
        for (let i = 0; i < 5; i++) {
          ctx.beginPath();
          ctx.ellipse(-20 + i * 12, Math.sin(i) * 5, 8, 12, 0, 0, Math.PI);
          ctx.fill();
        }
        
        // Dragon head
        ctx.fillStyle = '#c0392b';
        ctx.beginPath();
        ctx.ellipse(55, -10, 35, 25, 0.2, 0, Math.PI * 2);
        ctx.fill();
        
        // Dragon snout
        ctx.beginPath();
        ctx.moveTo(75, -15);
        ctx.lineTo(100, -20);
        ctx.lineTo(95, -5);
        ctx.lineTo(75, 0);
        ctx.closePath();
        ctx.fill();
        
        // Dragon nostrils with fire
        ctx.fillStyle = '#ff6600';
        ctx.beginPath();
        ctx.arc(95, -15, 4, 0, Math.PI * 2);
        ctx.arc(95, -8, 4, 0, Math.PI * 2);
        ctx.fill();
        
        // Dragon eye - fierce
        ctx.fillStyle = '#f1c40f';
        ctx.shadowColor = '#f1c40f';
        ctx.shadowBlur = 10;
        ctx.beginPath();
        ctx.ellipse(65, -18, 10, 8, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#000';
        ctx.shadowBlur = 0;
        ctx.beginPath();
        ctx.ellipse(67, -18, 4, 6, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Dragon horns
        ctx.fillStyle = '#8b0000';
        ctx.beginPath();
        ctx.moveTo(45, -25);
        ctx.lineTo(35, -55);
        ctx.lineTo(50, -30);
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(55, -28);
        ctx.lineTo(50, -50);
        ctx.lineTo(60, -30);
        ctx.fill();
        
        // Dragon wings
        ctx.save();
        ctx.translate(-10, -20);
        ctx.rotate(wingFlap);
        ctx.fillStyle = '#e74c3c';
        ctx.globalAlpha = 0.9;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.quadraticCurveTo(-40, -60 - wingFlap * 40, -80, -30);
        ctx.quadraticCurveTo(-60, -10, -40, 0);
        ctx.quadraticCurveTo(-20, 5, 0, 0);
        ctx.fill();
        // Wing membrane lines
        ctx.strokeStyle = '#c0392b';
        ctx.lineWidth = 2;
        for (let i = 0; i < 4; i++) {
          ctx.beginPath();
          ctx.moveTo(-5 - i * 8, -5);
          ctx.lineTo(-20 - i * 15, -30 - wingFlap * 20);
          ctx.stroke();
        }
        ctx.restore();
        
        ctx.save();
        ctx.translate(-10, 20);
        ctx.rotate(-wingFlap);
        ctx.fillStyle = '#e74c3c';
        ctx.globalAlpha = 0.9;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.quadraticCurveTo(-40, 60 + wingFlap * 40, -80, 30);
        ctx.quadraticCurveTo(-60, 10, -40, 0);
        ctx.quadraticCurveTo(-20, -5, 0, 0);
        ctx.fill();
        ctx.strokeStyle = '#c0392b';
        ctx.lineWidth = 2;
        for (let i = 0; i < 4; i++) {
          ctx.beginPath();
          ctx.moveTo(-5 - i * 8, 5);
          ctx.lineTo(-20 - i * 15, 30 + wingFlap * 20);
          ctx.stroke();
        }
        ctx.restore();
        
        // Dragon tail (wavy)
        ctx.strokeStyle = '#c0392b';
        ctx.lineWidth = 15;
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(-45, 0);
        ctx.quadraticCurveTo(-80, Math.sin(G.t * 5) * 20, -110, Math.sin(G.t * 6) * 30);
        ctx.quadraticCurveTo(-130, Math.sin(G.t * 7) * 25, -150, Math.sin(G.t * 8) * 15);
        ctx.stroke();
        // Tail tip
        ctx.fillStyle = '#e74c3c';
        ctx.beginPath();
        ctx.moveTo(-150, Math.sin(G.t * 8) * 15);
        ctx.lineTo(-170, Math.sin(G.t * 8) * 15 - 15);
        ctx.lineTo(-165, Math.sin(G.t * 8) * 15);
        ctx.lineTo(-170, Math.sin(G.t * 8) * 15 + 15);
        ctx.closePath();
        ctx.fill();
        
        // Fire breath
        ctx.globalAlpha = 0.8;
        for (let i = 0; i < 6; i++) {
          const fireX = 100 + i * 25 + Math.sin(G.t * 10 + i) * 10;
          const fireY = -12 + Math.sin(G.t * 8 + i * 2) * 8;
          const fireSize = 20 - i * 2;
          
          const fireGrad = ctx.createRadialGradient(fireX, fireY, 0, fireX, fireY, fireSize);
          fireGrad.addColorStop(0, '#fff');
          fireGrad.addColorStop(0.3, '#ff0');
          fireGrad.addColorStop(0.6, '#f80');
          fireGrad.addColorStop(1, 'rgba(255, 0, 0, 0)');
          ctx.fillStyle = fireGrad;
          ctx.beginPath();
          ctx.arc(fireX, fireY, fireSize, 0, Math.PI * 2);
          ctx.fill();
        }
        
        ctx.restore();
        
        // Store dragon hitbox for collision
        G.dragonRect = {
          x: dragonX - 80,
          y: dragonY + bodyWave - 50,
          w: 250,
          h: 100
        };
      } else if (G.ultType === 'mysticLightning') {
        // Ryoken: Mystic lightning - arms raised with lightning
        const centerX = pr.x + pr.w / 2;
        const centerY = pr.y + pr.h / 2;
        
        // Big illusion eye above
        ctx.save();
        ctx.translate(centerX, pr.y - 80);
        
        // Eye glow
        ctx.globalAlpha = 0.6 + Math.sin(G.t * 6) * 0.2;
        const eyeGlow = ctx.createRadialGradient(0, 0, 0, 0, 0, 80);
        eyeGlow.addColorStop(0, 'rgba(241, 196, 15, 0.8)');
        eyeGlow.addColorStop(0.5, 'rgba(155, 89, 182, 0.5)');
        eyeGlow.addColorStop(1, 'rgba(155, 89, 182, 0)');
        ctx.fillStyle = eyeGlow;
        ctx.fillRect(-80, -50, 160, 100);
        
        ctx.globalAlpha = 1;
        
        // Giant eye
        ctx.fillStyle = '#9b59b6';
        ctx.beginPath();
        ctx.ellipse(0, 0, 50, 30, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Iris
        ctx.fillStyle = '#f1c40f';
        ctx.shadowColor = '#f1c40f';
        ctx.shadowBlur = 20;
        ctx.beginPath();
        ctx.arc(0, 0, 20, 0, Math.PI * 2);
        ctx.fill();
        
        // Pupil
        ctx.fillStyle = '#000';
        ctx.shadowBlur = 0;
        ctx.beginPath();
        ctx.ellipse(0, 0, 8, 12, 0, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.restore();
        
        // Lightning bolts
        ctx.strokeStyle = '#f1c40f';
        ctx.shadowColor = '#f1c40f';
        ctx.shadowBlur = 15;
        ctx.lineWidth = 3;
        for (let i = 0; i < 6; i++) {
          const angle = G.t * 2 + i * Math.PI / 3;
          const startX = centerX + Math.cos(angle) * 30;
          const startY = pr.y - 60;
          ctx.beginPath();
          ctx.moveTo(startX, startY);
          for (let j = 0; j < 5; j++) {
            const lx = startX + Math.cos(angle + Math.PI/2) * (40 + j * 30) + rand(-15, 15);
            const ly = startY + j * 40 + rand(-10, 10);
            ctx.lineTo(lx, ly);
          }
          ctx.stroke();
        }
        ctx.shadowBlur = 0;
        
        // Store lightning hitbox (large area)
        G.lightningRect = {
          x: centerX - 150,
          y: pr.y - 100,
          w: 300,
          h: 250
        };
      } else if (G.ultType === 'arrowRain') {
        // Riku: Arrow rain - continuous arrows from above
        G.arrowRainTimer = (G.arrowRainTimer || 0) + G.dt;
        
        // Spawn multiple arrows continuously
        if (G.arrowRainTimer > 0.08) {
          G.arrowRainTimer = 0;
          // Spawn 3 arrows at random positions
          for (let i = 0; i < 3; i++) {
            G.projectiles.push({
              type: 'rainArrow',
              x: pr.x + rand(30, 350),
              y: -20 - rand(0, 50),
              w: 40,
              h: 5,
              vx: 0,
              vy: 500 + rand(0, 200),
              life: 3
            });
          }
        }
        
        // Visual effect - bow drawn
        ctx.strokeStyle = '#8B4513';
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.arc(pr.x + pr.w + 20, pr.y + pr.h/2, 25, -Math.PI/2, Math.PI/2);
        ctx.stroke();
        
        // Bow string
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(pr.x + pr.w + 20, pr.y + pr.h/2 - 25);
        ctx.lineTo(pr.x + pr.w + 10, pr.y + pr.h/2);
        ctx.lineTo(pr.x + pr.w + 20, pr.y + pr.h/2 + 25);
        ctx.stroke();
        
        // Glow effect
        ctx.globalAlpha = 0.3;
        ctx.fillStyle = '#3498db';
        ctx.fillRect(pr.x + pr.w + 40, -10, 280, G.groundY + 10);
        ctx.globalAlpha = 1;
      } else if (G.ultType === 'shadowClone') {
        // Joaryu: Shadow clone running alongside
        const cloneX = pr.x + pr.w + 40;
        const cloneY = G.groundY;
        const bounce = Math.abs(Math.sin(G.t * 12)) * 10;
        
        ctx.save();
        ctx.translate(cloneX, cloneY - bounce);
        ctx.globalAlpha = 0.7;
        
        // Clone body (similar to player but purple/shadowy)
        ctx.fillStyle = '#8e44ad';
        ctx.fillRect(-15, -60, 30, 50);
        
        // Clone head
        ctx.fillStyle = '#9b59b6';
        ctx.beginPath();
        ctx.arc(0, -70, 15, 0, Math.PI * 2);
        ctx.fill();
        
        // Clone hair
        ctx.fillStyle = '#9b59b6';
        ctx.fillRect(-18, -85, 36, 15);
        ctx.beginPath();
        ctx.moveTo(-18, -85);
        ctx.lineTo(-22, -95);
        ctx.lineTo(-12, -85);
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(18, -85);
        ctx.lineTo(22, -95);
        ctx.lineTo(12, -85);
        ctx.fill();
        
        // Clone arms (attacking pose)
        ctx.fillStyle = '#8e44ad';
        const armAngle = Math.sin(G.t * 10) * 0.5;
        ctx.save();
        ctx.translate(15, -50);
        ctx.rotate(armAngle - 0.5);
        ctx.fillRect(0, 0, 25, 8);
        // Kunai in hand
        ctx.fillStyle = '#555';
        ctx.beginPath();
        ctx.moveTo(25, 4);
        ctx.lineTo(40, 4);
        ctx.lineTo(35, 0);
        ctx.lineTo(40, 4);
        ctx.lineTo(35, 8);
        ctx.fill();
        ctx.restore();
        
        // Shadow effect
        ctx.globalAlpha = 0.3;
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.ellipse(0, 5, 25, 8, 0, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.restore();
        
        // Store clone hitbox
        G.cloneRect = {
          x: cloneX - 20,
          y: cloneY - bounce - 90,
          w: 70,
          h: 95
        };
      }
    }

    ctx.globalAlpha = 1;

    // Special pose for Butsuo's headbutt - Superman flying pose
    if (G.ultActive && G.ultType === 'headbutt' && selectedChar === 'butsuo') {
      ctx.save();
      
      // Position for horizontal flight
      const centerX = pr.x + pr.w / 2;
      const centerY = pr.y + pr.h / 2;
      const wobble = Math.sin(G.t * 6) * 3;
      
      // Cape effect (flowing behind)
      ctx.fillStyle = '#c41e3a';
      ctx.beginPath();
      ctx.moveTo(centerX - 30, centerY - 10);
      ctx.quadraticCurveTo(centerX - 70 + Math.sin(G.t * 8) * 15, centerY, centerX - 50 + Math.sin(G.t * 10) * 10, centerY + 25);
      ctx.quadraticCurveTo(centerX - 40, centerY + 15, centerX - 30, centerY + 10);
      ctx.closePath();
      ctx.fill();
      
      // Body - horizontal, slightly angled up
      ctx.save();
      ctx.translate(centerX, centerY + wobble);
      ctx.rotate(-0.15); // Slight upward angle
      
      // Torso
      ctx.fillStyle = '#2a2a3a';
      ctx.beginPath();
      ctx.ellipse(0, 0, 35, 22, 0, 0, Math.PI * 2);
      ctx.fill();
      
      // Head leading the charge
      const headX = 45;
      const headY = -8;
      ctx.fillStyle = '#f5deb3';
      ctx.beginPath();
      ctx.arc(headX, headY, 16, 0, Math.PI * 2);
      ctx.fill();
      
      // Determined face
      ctx.fillStyle = '#222';
      // Narrowed eyes
      ctx.fillRect(headX - 8, headY - 3, 6, 3);
      ctx.fillRect(headX + 2, headY - 3, 6, 3);
      // Eyebrows (angry)
      ctx.strokeStyle = '#222';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(headX - 9, headY - 7);
      ctx.lineTo(headX - 3, headY - 5);
      ctx.moveTo(headX + 9, headY - 7);
      ctx.lineTo(headX + 3, headY - 5);
      ctx.stroke();
      // Gritted teeth
      ctx.fillStyle = '#fff';
      ctx.fillRect(headX - 5, headY + 5, 10, 4);
      ctx.strokeStyle = '#666';
      ctx.lineWidth = 1;
      for (let i = 0; i < 4; i++) {
        ctx.beginPath();
        ctx.moveTo(headX - 4 + i * 3, headY + 5);
        ctx.lineTo(headX - 4 + i * 3, headY + 9);
        ctx.stroke();
      }
      
      // Hair (white, swept back)
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.moveTo(headX + 10, headY - 12);
      ctx.quadraticCurveTo(headX - 5, headY - 20, headX - 15, headY - 8);
      ctx.quadraticCurveTo(headX - 10, headY - 5, headX, headY - 10);
      ctx.quadraticCurveTo(headX + 5, headY - 15, headX + 10, headY - 12);
      ctx.fill();
      
      // Arms - Superman style, fists forward
      ctx.fillStyle = '#f5deb3';
      // Right arm stretched forward
      ctx.save();
      ctx.translate(25, -5);
      ctx.rotate(-0.2);
      ctx.fillStyle = '#2a2a3a';
      ctx.fillRect(0, -5, 30, 10);
      ctx.fillStyle = '#f5deb3';
      ctx.beginPath();
      ctx.arc(32, 0, 8, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
      
      // Left arm stretched forward
      ctx.save();
      ctx.translate(25, 5);
      ctx.rotate(0.2);
      ctx.fillStyle = '#2a2a3a';
      ctx.fillRect(0, -5, 30, 10);
      ctx.fillStyle = '#f5deb3';
      ctx.beginPath();
      ctx.arc(32, 0, 8, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
      
      // Legs stretched back
      ctx.fillStyle = '#2a2a3a';
      // Right leg
      ctx.save();
      ctx.translate(-25, -8);
      ctx.rotate(0.1);
      ctx.fillRect(-35, -6, 40, 12);
      // Foot
      ctx.fillStyle = '#1a1a2a';
      ctx.fillRect(-40, -5, 8, 10);
      ctx.restore();
      
      // Left leg
      ctx.save();
      ctx.translate(-25, 8);
      ctx.rotate(-0.1);
      ctx.fillStyle = '#2a2a3a';
      ctx.fillRect(-35, -6, 40, 12);
      // Foot
      ctx.fillStyle = '#1a1a2a';
      ctx.fillRect(-40, -5, 8, 10);
      ctx.restore();
      
      ctx.restore(); // End rotation
      
      // Wind/speed effects
      ctx.strokeStyle = 'rgba(255,255,255,0.5)';
      ctx.lineWidth = 2;
      for (let i = 0; i < 8; i++) {
        const lineX = centerX - 50 - i * 15;
        const lineY = centerY - 20 + i * 5 + Math.sin(G.t * 10 + i) * 5;
        ctx.beginPath();
        ctx.moveTo(lineX, lineY);
        ctx.lineTo(lineX - 25, lineY);
        ctx.stroke();
      }
      
      ctx.restore();
      ctx.restore();
      return; // Skip normal drawing
    }

    // Body
    ctx.fillStyle = '#2a2a3a';
    roundRect(pr.x, pr.y, pr.w, pr.h, 8);
    ctx.fill();

    // Head
    const headY = pr.y - 4;
    const headSize = selectedChar === 'chisa' ? 14 : (selectedChar === 'butsuo' ? 24 : 18);
    // Skin color - Chisa has purple skin
    ctx.fillStyle = char.skinColor || '#f5deb3';
    ctx.beginPath();
    ctx.arc(pr.x + pr.w / 2, headY + headSize / 2 + 8, headSize / 2, 0, Math.PI * 2);
    ctx.fill();

    // Hair
    ctx.fillStyle = char.hairColor;
    ctx.beginPath();
    if (selectedChar === 'usagi') {
      // Usagi: Long golden hair
      ctx.ellipse(pr.x + pr.w / 2, headY + 10, 14, 10, 0, Math.PI, 0);
      ctx.fill();
      ctx.fillRect(pr.x + pr.w / 2 - 14, headY + 10, 6, 40);
      ctx.fillRect(pr.x + pr.w / 2 + 8, headY + 10, 6, 40);
    } else if (selectedChar === 'haru') {
      // Haru: White hair parted to two sides, long
      // Top of head
      ctx.ellipse(pr.x + pr.w / 2, headY + 8, 13, 9, 0, Math.PI, 0);
      ctx.fill();
      // Left side - long flowing hair
      ctx.fillRect(pr.x + pr.w / 2 - 16, headY + 6, 5, 45);
      ctx.beginPath();
      ctx.moveTo(pr.x + pr.w / 2 - 16, headY + 51);
      ctx.quadraticCurveTo(pr.x + pr.w / 2 - 20, headY + 56, pr.x + pr.w / 2 - 14, headY + 60);
      ctx.lineTo(pr.x + pr.w / 2 - 11, headY + 51);
      ctx.fill();
      // Right side - long flowing hair
      ctx.fillRect(pr.x + pr.w / 2 + 11, headY + 6, 5, 45);
      ctx.beginPath();
      ctx.moveTo(pr.x + pr.w / 2 + 11, headY + 51);
      ctx.quadraticCurveTo(pr.x + pr.w / 2 + 20, headY + 56, pr.x + pr.w / 2 + 14, headY + 60);
      ctx.lineTo(pr.x + pr.w / 2 + 16, headY + 51);
      ctx.fill();
    } else if (selectedChar === 'ringo') {
      // Ringo: Spiky blue hair
      ctx.fillStyle = char.hairColor;
      // Base hair
      ctx.ellipse(pr.x + pr.w / 2, headY + 6, 11, 7, 0, Math.PI, 0);
      ctx.fill();
      // Spikes
      ctx.beginPath();
      ctx.moveTo(pr.x + pr.w / 2 - 10, headY + 6);
      ctx.lineTo(pr.x + pr.w / 2 - 14, headY - 8);
      ctx.lineTo(pr.x + pr.w / 2 - 6, headY + 4);
      ctx.fill();
      ctx.beginPath();
      ctx.moveTo(pr.x + pr.w / 2 - 4, headY + 4);
      ctx.lineTo(pr.x + pr.w / 2 - 2, headY - 14);
      ctx.lineTo(pr.x + pr.w / 2 + 2, headY + 3);
      ctx.fill();
      ctx.beginPath();
      ctx.moveTo(pr.x + pr.w / 2 + 2, headY + 4);
      ctx.lineTo(pr.x + pr.w / 2 + 6, headY - 10);
      ctx.lineTo(pr.x + pr.w / 2 + 10, headY + 5);
      ctx.fill();
      ctx.beginPath();
      ctx.moveTo(pr.x + pr.w / 2 + 8, headY + 6);
      ctx.lineTo(pr.x + pr.w / 2 + 16, headY - 4);
      ctx.lineTo(pr.x + pr.w / 2 + 12, headY + 8);
      ctx.fill();
    } else if (selectedChar === 'chisa') {
      // Chisa: Golden/blonde twin tails (short, cute)
      ctx.fillStyle = char.hairColor;
      // Top hair
      ctx.ellipse(pr.x + pr.w / 2, headY + 6, 10, 7, 0, Math.PI, 0);
      ctx.fill();
      // Twin tails
      ctx.beginPath();
      ctx.ellipse(pr.x + pr.w / 2 - 10, headY + 18, 4, 12, -0.3, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.ellipse(pr.x + pr.w / 2 + 10, headY + 18, 4, 12, 0.3, 0, Math.PI * 2);
      ctx.fill();
      // Hair accessories (red ribbons)
      ctx.fillStyle = '#e74c3c';
      ctx.beginPath();
      ctx.arc(pr.x + pr.w / 2 - 10, headY + 10, 3, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(pr.x + pr.w / 2 + 10, headY + 10, 3, 0, Math.PI * 2);
      ctx.fill();
    } else if (selectedChar === 'butsuo') {
      // Butsuo: Short white/silver spiky hair (more mature look)
      ctx.fillStyle = char.hairColor;
      // Base
      ctx.ellipse(pr.x + pr.w / 2, headY + 6, 16, 10, 0, Math.PI, 0);
      ctx.fill();
      // Short spikes pointing backward
      ctx.beginPath();
      ctx.moveTo(pr.x + pr.w / 2 - 12, headY + 4);
      ctx.lineTo(pr.x + pr.w / 2 - 18, headY - 4);
      ctx.lineTo(pr.x + pr.w / 2 - 8, headY + 2);
      ctx.fill();
      ctx.beginPath();
      ctx.moveTo(pr.x + pr.w / 2 - 4, headY + 2);
      ctx.lineTo(pr.x + pr.w / 2 - 4, headY - 10);
      ctx.lineTo(pr.x + pr.w / 2 + 4, headY + 2);
      ctx.fill();
      ctx.beginPath();
      ctx.moveTo(pr.x + pr.w / 2 + 8, headY + 2);
      ctx.lineTo(pr.x + pr.w / 2 + 18, headY - 4);
      ctx.lineTo(pr.x + pr.w / 2 + 12, headY + 4);
      ctx.fill();
    } else if (selectedChar === 'teki') {
      // Teki: Short wavy white hair
      ctx.fillStyle = char.hairColor;
      // Top wavy hair
      ctx.beginPath();
      ctx.moveTo(pr.x + pr.w / 2 - 12, headY + 10);
      ctx.quadraticCurveTo(pr.x + pr.w / 2 - 8, headY - 2, pr.x + pr.w / 2 - 3, headY + 4);
      ctx.quadraticCurveTo(pr.x + pr.w / 2, headY - 4, pr.x + pr.w / 2 + 3, headY + 4);
      ctx.quadraticCurveTo(pr.x + pr.w / 2 + 8, headY - 2, pr.x + pr.w / 2 + 12, headY + 10);
      ctx.lineTo(pr.x + pr.w / 2 + 10, headY + 14);
      ctx.lineTo(pr.x + pr.w / 2 - 10, headY + 14);
      ctx.closePath();
      ctx.fill();
      // Side waves
      ctx.beginPath();
      ctx.moveTo(pr.x + pr.w / 2 - 12, headY + 10);
      ctx.quadraticCurveTo(pr.x + pr.w / 2 - 16, headY + 16, pr.x + pr.w / 2 - 13, headY + 22);
      ctx.quadraticCurveTo(pr.x + pr.w / 2 - 10, headY + 18, pr.x + pr.w / 2 - 10, headY + 14);
      ctx.fill();
      ctx.beginPath();
      ctx.moveTo(pr.x + pr.w / 2 + 12, headY + 10);
      ctx.quadraticCurveTo(pr.x + pr.w / 2 + 16, headY + 16, pr.x + pr.w / 2 + 13, headY + 22);
      ctx.quadraticCurveTo(pr.x + pr.w / 2 + 10, headY + 18, pr.x + pr.w / 2 + 10, headY + 14);
      ctx.fill();
    } else if (selectedChar === 'susumu') {
      // Susumu: Long white hair
      ctx.fillStyle = char.hairColor;
      // Top hair
      ctx.beginPath();
      ctx.ellipse(pr.x + pr.w / 2, headY + 6, 14, 10, 0, Math.PI, 0);
      ctx.fill();
      // Long flowing hair on both sides
      ctx.beginPath();
      ctx.moveTo(pr.x + pr.w / 2 - 14, headY + 8);
      ctx.quadraticCurveTo(pr.x + pr.w / 2 - 18, headY + 45, pr.x + pr.w / 2 - 14, headY + 75);
      ctx.lineTo(pr.x + pr.w / 2 - 8, headY + 70);
      ctx.quadraticCurveTo(pr.x + pr.w / 2 - 10, headY + 40, pr.x + pr.w / 2 - 9, headY + 10);
      ctx.fill();
      ctx.beginPath();
      ctx.moveTo(pr.x + pr.w / 2 + 14, headY + 8);
      ctx.quadraticCurveTo(pr.x + pr.w / 2 + 18, headY + 45, pr.x + pr.w / 2 + 14, headY + 75);
      ctx.lineTo(pr.x + pr.w / 2 + 8, headY + 70);
      ctx.quadraticCurveTo(pr.x + pr.w / 2 + 10, headY + 40, pr.x + pr.w / 2 + 9, headY + 10);
      ctx.fill();
      // Hair shine
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.ellipse(pr.x + pr.w / 2 - 5, headY + 4, 2, 4, -0.3, 0, Math.PI * 2);
      ctx.fill();
    } else if (selectedChar === 'shinji') {
      // Shinji: Long black-white mixed hair (tall)
      // Left side - black
      ctx.fillStyle = '#222';
      ctx.fillRect(pr.x + pr.w / 2 - 16, headY + 4, 8, 55);
      ctx.beginPath();
      ctx.moveTo(pr.x + pr.w / 2 - 16, headY + 59);
      ctx.quadraticCurveTo(pr.x + pr.w / 2 - 20, headY + 65, pr.x + pr.w / 2 - 12, headY + 70);
      ctx.lineTo(pr.x + pr.w / 2 - 8, headY + 59);
      ctx.fill();
      // Right side - white
      ctx.fillStyle = '#ddd';
      ctx.fillRect(pr.x + pr.w / 2 + 8, headY + 4, 8, 55);
      ctx.beginPath();
      ctx.moveTo(pr.x + pr.w / 2 + 8, headY + 59);
      ctx.quadraticCurveTo(pr.x + pr.w / 2 + 20, headY + 65, pr.x + pr.w / 2 + 12, headY + 70);
      ctx.lineTo(pr.x + pr.w / 2 + 16, headY + 59);
      ctx.fill();
      // Top hair - split color
      ctx.fillStyle = '#222';
      ctx.beginPath();
      ctx.ellipse(pr.x + pr.w / 2 - 4, headY + 6, 10, 8, 0, Math.PI, 0);
      ctx.fill();
      ctx.fillStyle = '#ddd';
      ctx.beginPath();
      ctx.ellipse(pr.x + pr.w / 2 + 4, headY + 6, 10, 8, 0, Math.PI, 0);
      ctx.fill();
    } else if (selectedChar === 'kazuya') {
      // Kazuya: Medium purple spiky hair
      ctx.fillStyle = char.hairColor;
      // Base hair
      ctx.beginPath();
      ctx.ellipse(pr.x + pr.w / 2, headY + 8, 14, 10, 0, Math.PI, 0);
      ctx.fill();
      // Spiky top
      ctx.beginPath();
      ctx.moveTo(pr.x + pr.w / 2 - 12, headY + 8);
      ctx.lineTo(pr.x + pr.w / 2 - 16, headY - 6);
      ctx.lineTo(pr.x + pr.w / 2 - 8, headY + 4);
      ctx.fill();
      ctx.beginPath();
      ctx.moveTo(pr.x + pr.w / 2 - 5, headY + 5);
      ctx.lineTo(pr.x + pr.w / 2 - 3, headY - 12);
      ctx.lineTo(pr.x + pr.w / 2 + 3, headY + 4);
      ctx.fill();
      ctx.beginPath();
      ctx.moveTo(pr.x + pr.w / 2 + 5, headY + 5);
      ctx.lineTo(pr.x + pr.w / 2 + 8, headY - 10);
      ctx.lineTo(pr.x + pr.w / 2 + 12, headY + 6);
      ctx.fill();
      // Side hair
      ctx.fillRect(pr.x + pr.w / 2 - 14, headY + 8, 5, 18);
      ctx.fillRect(pr.x + pr.w / 2 + 9, headY + 8, 5, 18);
    } else if (selectedChar === 'togami') {
      // Togami: Blue-white mixed hair
      // Left side - blue
      ctx.fillStyle = '#3498db';
      ctx.beginPath();
      ctx.ellipse(pr.x + pr.w / 2 - 5, headY + 8, 10, 8, 0, Math.PI, 0);
      ctx.fill();
      ctx.fillRect(pr.x + pr.w / 2 - 14, headY + 8, 6, 25);
      // Right side - white
      ctx.fillStyle = '#ecf0f1';
      ctx.beginPath();
      ctx.ellipse(pr.x + pr.w / 2 + 5, headY + 8, 10, 8, 0, Math.PI, 0);
      ctx.fill();
      ctx.fillRect(pr.x + pr.w / 2 + 8, headY + 8, 6, 25);
      // Front bangs mixed
      ctx.fillStyle = '#3498db';
      ctx.beginPath();
      ctx.moveTo(pr.x + pr.w / 2 - 8, headY + 12);
      ctx.lineTo(pr.x + pr.w / 2 - 5, headY + 2);
      ctx.lineTo(pr.x + pr.w / 2, headY + 10);
      ctx.fill();
      ctx.fillStyle = '#ecf0f1';
      ctx.beginPath();
      ctx.moveTo(pr.x + pr.w / 2, headY + 10);
      ctx.lineTo(pr.x + pr.w / 2 + 5, headY + 2);
      ctx.lineTo(pr.x + pr.w / 2 + 8, headY + 12);
      ctx.fill();
    } else if (selectedChar === 'kagi') {
      // Kagi: Long flowing black hair
      ctx.fillStyle = '#000';
      // Top hair
      ctx.beginPath();
      ctx.ellipse(pr.x + pr.w / 2, headY + 6, 12, 8, 0, Math.PI, 0);
      ctx.fill();
      // Long flowing hair on both sides
      ctx.beginPath();
      ctx.moveTo(pr.x + pr.w / 2 - 12, headY + 8);
      ctx.quadraticCurveTo(pr.x + pr.w / 2 - 18, headY + 35, pr.x + pr.w / 2 - 14, headY + 55);
      ctx.lineTo(pr.x + pr.w / 2 - 8, headY + 50);
      ctx.quadraticCurveTo(pr.x + pr.w / 2 - 10, headY + 30, pr.x + pr.w / 2 - 8, headY + 10);
      ctx.fill();
      ctx.beginPath();
      ctx.moveTo(pr.x + pr.w / 2 + 12, headY + 8);
      ctx.quadraticCurveTo(pr.x + pr.w / 2 + 18, headY + 35, pr.x + pr.w / 2 + 14, headY + 55);
      ctx.lineTo(pr.x + pr.w / 2 + 8, headY + 50);
      ctx.quadraticCurveTo(pr.x + pr.w / 2 + 10, headY + 30, pr.x + pr.w / 2 + 8, headY + 10);
      ctx.fill();
      // Front bangs
      ctx.beginPath();
      ctx.moveTo(pr.x + pr.w / 2 - 8, headY + 12);
      ctx.lineTo(pr.x + pr.w / 2 - 4, headY + 4);
      ctx.lineTo(pr.x + pr.w / 2, headY + 10);
      ctx.lineTo(pr.x + pr.w / 2 + 4, headY + 4);
      ctx.lineTo(pr.x + pr.w / 2 + 8, headY + 12);
      ctx.fill();
    } else if (selectedChar === 'akemi') {
      // Akemi: Long flowing golden/blonde hair
      ctx.fillStyle = '#f1c40f';
      // Top hair
      ctx.beginPath();
      ctx.ellipse(pr.x + pr.w / 2, headY + 6, 13, 9, 0, Math.PI, 0);
      ctx.fill();
      // Long wavy hair on both sides
      ctx.beginPath();
      ctx.moveTo(pr.x + pr.w / 2 - 13, headY + 8);
      ctx.quadraticCurveTo(pr.x + pr.w / 2 - 20, headY + 30, pr.x + pr.w / 2 - 16, headY + 55);
      ctx.quadraticCurveTo(pr.x + pr.w / 2 - 14, headY + 60, pr.x + pr.w / 2 - 12, headY + 65);
      ctx.lineTo(pr.x + pr.w / 2 - 8, headY + 55);
      ctx.quadraticCurveTo(pr.x + pr.w / 2 - 10, headY + 30, pr.x + pr.w / 2 - 8, headY + 10);
      ctx.fill();
      ctx.beginPath();
      ctx.moveTo(pr.x + pr.w / 2 + 13, headY + 8);
      ctx.quadraticCurveTo(pr.x + pr.w / 2 + 20, headY + 30, pr.x + pr.w / 2 + 16, headY + 55);
      ctx.quadraticCurveTo(pr.x + pr.w / 2 + 14, headY + 60, pr.x + pr.w / 2 + 12, headY + 65);
      ctx.lineTo(pr.x + pr.w / 2 + 8, headY + 55);
      ctx.quadraticCurveTo(pr.x + pr.w / 2 + 10, headY + 30, pr.x + pr.w / 2 + 8, headY + 10);
      ctx.fill();
      // Front wavy bangs
      ctx.beginPath();
      ctx.moveTo(pr.x + pr.w / 2 - 10, headY + 12);
      ctx.quadraticCurveTo(pr.x + pr.w / 2 - 6, headY + 2, pr.x + pr.w / 2 - 2, headY + 8);
      ctx.quadraticCurveTo(pr.x + pr.w / 2, headY + 0, pr.x + pr.w / 2 + 2, headY + 8);
      ctx.quadraticCurveTo(pr.x + pr.w / 2 + 6, headY + 2, pr.x + pr.w / 2 + 10, headY + 12);
      ctx.fill();
      // Hair shine
      ctx.fillStyle = '#f9e079';
      ctx.beginPath();
      ctx.ellipse(pr.x + pr.w / 2 - 5, headY + 4, 3, 5, -0.3, 0, Math.PI * 2);
      ctx.fill();
    } else if (selectedChar === 'ryoken') {
      // Ryoken: Blonde spiky hair
      ctx.fillStyle = '#f1c40f';
      // Base hair
      ctx.beginPath();
      ctx.ellipse(pr.x + pr.w / 2, headY + 8, 14, 10, 0, Math.PI, 0);
      ctx.fill();
      // Spiky top
      ctx.beginPath();
      ctx.moveTo(pr.x + pr.w / 2 - 12, headY + 8);
      ctx.lineTo(pr.x + pr.w / 2 - 18, headY - 8);
      ctx.lineTo(pr.x + pr.w / 2 - 8, headY + 4);
      ctx.fill();
      ctx.beginPath();
      ctx.moveTo(pr.x + pr.w / 2 - 5, headY + 5);
      ctx.lineTo(pr.x + pr.w / 2 - 2, headY - 15);
      ctx.lineTo(pr.x + pr.w / 2 + 4, headY + 4);
      ctx.fill();
      ctx.beginPath();
      ctx.moveTo(pr.x + pr.w / 2 + 6, headY + 5);
      ctx.lineTo(pr.x + pr.w / 2 + 10, headY - 12);
      ctx.lineTo(pr.x + pr.w / 2 + 14, headY + 6);
      ctx.fill();
      // Side hair
      ctx.fillRect(pr.x + pr.w / 2 - 14, headY + 8, 5, 16);
      ctx.fillRect(pr.x + pr.w / 2 + 9, headY + 8, 5, 16);
      // Hair shine
      ctx.fillStyle = '#f9e079';
      ctx.beginPath();
      ctx.ellipse(pr.x + pr.w / 2 - 3, headY + 2, 2, 4, -0.3, 0, Math.PI * 2);
      ctx.fill();
    } else if (selectedChar === 'riku') {
      // Riku: Short white messy hair (small character)
      ctx.fillStyle = '#fff';
      // Base hair
      ctx.beginPath();
      ctx.ellipse(pr.x + pr.w / 2, headY + 5, 10, 7, 0, Math.PI, 0);
      ctx.fill();
      // Messy spikes
      ctx.beginPath();
      ctx.moveTo(pr.x + pr.w / 2 - 8, headY + 5);
      ctx.lineTo(pr.x + pr.w / 2 - 10, headY - 3);
      ctx.lineTo(pr.x + pr.w / 2 - 4, headY + 3);
      ctx.fill();
      ctx.beginPath();
      ctx.moveTo(pr.x + pr.w / 2 - 2, headY + 3);
      ctx.lineTo(pr.x + pr.w / 2, headY - 8);
      ctx.lineTo(pr.x + pr.w / 2 + 3, headY + 3);
      ctx.fill();
      ctx.beginPath();
      ctx.moveTo(pr.x + pr.w / 2 + 4, headY + 4);
      ctx.lineTo(pr.x + pr.w / 2 + 8, headY - 4);
      ctx.lineTo(pr.x + pr.w / 2 + 10, headY + 5);
      ctx.fill();
      // Side tufts
      ctx.fillRect(pr.x + pr.w / 2 - 11, headY + 5, 4, 10);
      ctx.fillRect(pr.x + pr.w / 2 + 7, headY + 5, 4, 10);
    } else if (selectedChar === 'joaryu') {
      // Joaryu: Medium purple hair (tall character)
      ctx.fillStyle = '#9b59b6';
      // Top hair
      ctx.beginPath();
      ctx.ellipse(pr.x + pr.w / 2, headY + 6, 14, 10, 0, Math.PI, 0);
      ctx.fill();
      // Medium length hair on both sides
      ctx.beginPath();
      ctx.moveTo(pr.x + pr.w / 2 - 14, headY + 8);
      ctx.quadraticCurveTo(pr.x + pr.w / 2 - 16, headY + 25, pr.x + pr.w / 2 - 13, headY + 40);
      ctx.lineTo(pr.x + pr.w / 2 - 8, headY + 38);
      ctx.quadraticCurveTo(pr.x + pr.w / 2 - 9, headY + 22, pr.x + pr.w / 2 - 9, headY + 10);
      ctx.fill();
      ctx.beginPath();
      ctx.moveTo(pr.x + pr.w / 2 + 14, headY + 8);
      ctx.quadraticCurveTo(pr.x + pr.w / 2 + 16, headY + 25, pr.x + pr.w / 2 + 13, headY + 40);
      ctx.lineTo(pr.x + pr.w / 2 + 8, headY + 38);
      ctx.quadraticCurveTo(pr.x + pr.w / 2 + 9, headY + 22, pr.x + pr.w / 2 + 9, headY + 10);
      ctx.fill();
      // Front bangs - sleek
      ctx.beginPath();
      ctx.moveTo(pr.x + pr.w / 2 - 10, headY + 12);
      ctx.lineTo(pr.x + pr.w / 2 - 5, headY + 2);
      ctx.lineTo(pr.x + pr.w / 2, headY + 8);
      ctx.lineTo(pr.x + pr.w / 2 + 5, headY + 2);
      ctx.lineTo(pr.x + pr.w / 2 + 10, headY + 12);
      ctx.fill();
      // Hair shine
      ctx.fillStyle = '#b388eb';
      ctx.beginPath();
      ctx.ellipse(pr.x + pr.w / 2 - 5, headY + 4, 2, 4, -0.3, 0, Math.PI * 2);
      ctx.fill();
    }

    // Headband (alƒ±n bandƒ±) - ninja style - scale for character size
    const bandScale = selectedChar === 'chisa' ? 0.75 : (selectedChar === 'butsuo' ? 1.3 : (selectedChar === 'teki' ? 0.9 : (selectedChar === 'riku' ? 0.8 : (selectedChar === 'joaryu' ? 1.2 : 1))));
    const bandWidth = 24 * bandScale;
    const bandHeight = 4 * bandScale;
    ctx.fillStyle = selectedChar === 'chisa' ? '#9b59b6' : 
                     selectedChar === 'teki' ? '#27ae60' : 
                     selectedChar === 'susumu' ? '#e74c3c' : 
                     selectedChar === 'shinji' ? '#9b59b6' :
                     selectedChar === 'kazuya' ? '#8e44ad' :
                     selectedChar === 'togami' ? '#555' :
                     selectedChar === 'kagi' ? '#ecf0f1' :
                     selectedChar === 'akemi' ? '#ff69b4' :
                     selectedChar === 'ryoken' ? '#9b59b6' :
                     selectedChar === 'riku' ? '#3498db' :
                     selectedChar === 'joaryu' ? '#8e44ad' : '#c41e3a';
    ctx.fillRect(pr.x + pr.w / 2 - bandWidth/2, headY + 6, bandWidth, bandHeight);
    // Headband knot/tail on the side
    ctx.beginPath();
    ctx.moveTo(pr.x + pr.w / 2 + bandWidth/2, headY + 6);
    ctx.lineTo(pr.x + pr.w / 2 + bandWidth/2 + 8 * bandScale, headY + 10);
    ctx.lineTo(pr.x + pr.w / 2 + bandWidth/2 + 6 * bandScale, headY + 14);
    ctx.lineTo(pr.x + pr.w / 2 + bandWidth/2, headY + 10);
    ctx.fill();
    // Metal plate on headband
    ctx.fillStyle = '#888';
    const plateWidth = 10 * bandScale;
    const plateHeight = 5 * bandScale;
    ctx.fillRect(pr.x + pr.w / 2 - plateWidth/2, headY + 5, plateWidth, plateHeight);
    ctx.strokeStyle = '#666';
    ctx.lineWidth = 1;
    ctx.strokeRect(pr.x + pr.w / 2 - plateWidth/2, headY + 5, plateWidth, plateHeight);

    // Eyes - character specific
    if (selectedChar === 'haru') {
      // Haru: Red glowing eyes
      ctx.fillStyle = '#ff0000';
      ctx.shadowColor = '#ff0000';
      ctx.shadowBlur = 6;
      ctx.fillRect(pr.x + pr.w / 2 - 7, headY + 13, 5, 4);
      ctx.fillRect(pr.x + pr.w / 2 + 2, headY + 13, 5, 4);
      // Eye shine
      ctx.fillStyle = '#ff6666';
      ctx.fillRect(pr.x + pr.w / 2 - 6, headY + 13, 2, 2);
      ctx.fillRect(pr.x + pr.w / 2 + 3, headY + 13, 2, 2);
      ctx.shadowBlur = 0;
    } else if (selectedChar === 'ringo') {
      // Ringo: One purple eye, one normal
      // Left eye - purple (special)
      ctx.fillStyle = '#9333ea';
      ctx.shadowColor = '#9333ea';
      ctx.shadowBlur = 5;
      ctx.fillRect(pr.x + pr.w / 2 - 7, headY + 13, 5, 4);
      ctx.fillStyle = '#c084fc';
      ctx.fillRect(pr.x + pr.w / 2 - 6, headY + 13, 2, 2);
      ctx.shadowBlur = 0;
      // Right eye - normal white
      ctx.fillStyle = '#fff';
      ctx.fillRect(pr.x + pr.w / 2 + 2, headY + 13, 5, 4);
      ctx.fillStyle = '#333';
      ctx.fillRect(pr.x + pr.w / 2 + 4, headY + 14, 2, 2);
    } else if (selectedChar === 'chisa') {
      // Chisa: Big golden/amber eyes (cute anime style)
      const eyeY = headY + 12;
      ctx.fillStyle = '#fbbf24';
      ctx.beginPath();
      ctx.ellipse(pr.x + pr.w / 2 - 5, eyeY, 3, 4, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.ellipse(pr.x + pr.w / 2 + 5, eyeY, 3, 4, 0, 0, Math.PI * 2);
      ctx.fill();
      // Pupils
      ctx.fillStyle = '#000';
      ctx.beginPath();
      ctx.arc(pr.x + pr.w / 2 - 5, eyeY, 1.5, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(pr.x + pr.w / 2 + 5, eyeY, 1.5, 0, Math.PI * 2);
      ctx.fill();
      // Eye shine
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(pr.x + pr.w / 2 - 6, eyeY - 1, 1, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(pr.x + pr.w / 2 + 4, eyeY - 1, 1, 0, Math.PI * 2);
      ctx.fill();
    } else if (selectedChar === 'butsuo') {
      // Butsuo: Stern eyes (narrow, serious)
      const eyeY = headY + 14;
      ctx.fillStyle = '#222';
      ctx.fillRect(pr.x + pr.w / 2 - 10, eyeY, 7, 4);
      ctx.fillRect(pr.x + pr.w / 2 + 3, eyeY, 7, 4);
      // Pupils
      ctx.fillStyle = '#555';
      ctx.fillRect(pr.x + pr.w / 2 - 8, eyeY + 1, 3, 2);
      ctx.fillRect(pr.x + pr.w / 2 + 5, eyeY + 1, 3, 2);
    } else if (selectedChar === 'teki') {
      // Teki: Glowing green poison eyes
      ctx.fillStyle = '#2ecc71';
      ctx.shadowColor = '#27ae60';
      ctx.shadowBlur = 8;
      ctx.fillRect(pr.x + pr.w / 2 - 7, headY + 13, 5, 4);
      ctx.fillRect(pr.x + pr.w / 2 + 2, headY + 13, 5, 4);
      // Eye shine
      ctx.fillStyle = '#82e0aa';
      ctx.fillRect(pr.x + pr.w / 2 - 6, headY + 13, 2, 2);
      ctx.fillRect(pr.x + pr.w / 2 + 3, headY + 13, 2, 2);
      ctx.shadowBlur = 0;
    } else if (selectedChar === 'susumu') {
      // Susumu: Calm focused eyes
      ctx.fillStyle = '#8B4513';
      ctx.fillRect(pr.x + pr.w / 2 - 7, headY + 13, 5, 4);
      ctx.fillRect(pr.x + pr.w / 2 + 2, headY + 13, 5, 4);
      // Eye shine
      ctx.fillStyle = '#D2691E';
      ctx.fillRect(pr.x + pr.w / 2 - 6, headY + 13, 2, 2);
      ctx.fillRect(pr.x + pr.w / 2 + 3, headY + 13, 2, 2);
    } else if (selectedChar === 'shinji') {
      // Shinji: Glowing purple illusion eyes
      ctx.fillStyle = '#9b59b6';
      ctx.shadowColor = '#9b59b6';
      ctx.shadowBlur = 10;
      ctx.fillRect(pr.x + pr.w / 2 - 7, headY + 13, 5, 4);
      ctx.fillRect(pr.x + pr.w / 2 + 2, headY + 13, 5, 4);
      // Eye glow center
      ctx.fillStyle = '#fff';
      ctx.fillRect(pr.x + pr.w / 2 - 6, headY + 14, 3, 2);
      ctx.fillRect(pr.x + pr.w / 2 + 3, headY + 14, 3, 2);
      ctx.shadowBlur = 0;
    } else if (selectedChar === 'kazuya') {
      // Kazuya: Sharp blue-purple eyes
      ctx.fillStyle = '#3498db';
      ctx.fillRect(pr.x + pr.w / 2 - 7, headY + 13, 5, 4);
      ctx.fillRect(pr.x + pr.w / 2 + 2, headY + 13, 5, 4);
      // Eye shine
      ctx.fillStyle = '#87ceeb';
      ctx.fillRect(pr.x + pr.w / 2 - 6, headY + 13, 2, 2);
      ctx.fillRect(pr.x + pr.w / 2 + 3, headY + 13, 2, 2);
    } else if (selectedChar === 'togami') {
      // Togami: Dark mysterious eyes with slight glow
      ctx.fillStyle = '#222';
      ctx.shadowColor = '#3498db';
      ctx.shadowBlur = 5;
      ctx.fillRect(pr.x + pr.w / 2 - 7, headY + 13, 5, 4);
      ctx.fillRect(pr.x + pr.w / 2 + 2, headY + 13, 5, 4);
      // Eye shine - blue hint
      ctx.fillStyle = '#3498db';
      ctx.fillRect(pr.x + pr.w / 2 - 6, headY + 13, 2, 2);
      ctx.fillRect(pr.x + pr.w / 2 + 3, headY + 13, 2, 2);
      ctx.shadowBlur = 0;
    } else if (selectedChar === 'kagi') {
      // Kagi: Soft gray eyes with paper-like shine
      ctx.fillStyle = '#666';
      ctx.fillRect(pr.x + pr.w / 2 - 7, headY + 13, 5, 4);
      ctx.fillRect(pr.x + pr.w / 2 + 2, headY + 13, 5, 4);
      // Eye shine - white like paper
      ctx.fillStyle = '#fff';
      ctx.fillRect(pr.x + pr.w / 2 - 6, headY + 13, 2, 2);
      ctx.fillRect(pr.x + pr.w / 2 + 3, headY + 13, 2, 2);
    } else if (selectedChar === 'akemi') {
      // Akemi: Beautiful pink/magenta eyes with sparkle
      const eyeY = headY + 12;
      ctx.fillStyle = '#ff1493';
      ctx.shadowColor = '#ff69b4';
      ctx.shadowBlur = 6;
      ctx.beginPath();
      ctx.ellipse(pr.x + pr.w / 2 - 5, eyeY, 3, 4, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.ellipse(pr.x + pr.w / 2 + 5, eyeY, 3, 4, 0, 0, Math.PI * 2);
      ctx.fill();
      // Pupils
      ctx.fillStyle = '#000';
      ctx.shadowBlur = 0;
      ctx.beginPath();
      ctx.arc(pr.x + pr.w / 2 - 5, eyeY, 1.5, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(pr.x + pr.w / 2 + 5, eyeY, 1.5, 0, Math.PI * 2);
      ctx.fill();
      // Eye sparkles
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(pr.x + pr.w / 2 - 6, eyeY - 1, 1.2, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(pr.x + pr.w / 2 + 4, eyeY - 1, 1.2, 0, Math.PI * 2);
      ctx.fill();
    } else if (selectedChar === 'ryoken') {
      // Ryoken: Glowing purple illusion eyes
      ctx.fillStyle = '#9b59b6';
      ctx.shadowColor = '#9b59b6';
      ctx.shadowBlur = 10;
      ctx.fillRect(pr.x + pr.w / 2 - 7, headY + 13, 5, 4);
      ctx.fillRect(pr.x + pr.w / 2 + 2, headY + 13, 5, 4);
      // Yellow glow center (like his hair color)
      ctx.fillStyle = '#f1c40f';
      ctx.fillRect(pr.x + pr.w / 2 - 6, headY + 14, 3, 2);
      ctx.fillRect(pr.x + pr.w / 2 + 3, headY + 14, 3, 2);
      ctx.shadowBlur = 0;
    } else if (selectedChar === 'riku') {
      // Riku: Sharp blue archer eyes
      const eyeY = headY + 11;
      ctx.fillStyle = '#3498db';
      ctx.beginPath();
      ctx.ellipse(pr.x + pr.w / 2 - 4, eyeY, 2.5, 3, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.ellipse(pr.x + pr.w / 2 + 4, eyeY, 2.5, 3, 0, 0, Math.PI * 2);
      ctx.fill();
      // Pupils
      ctx.fillStyle = '#000';
      ctx.beginPath();
      ctx.arc(pr.x + pr.w / 2 - 4, eyeY, 1, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(pr.x + pr.w / 2 + 4, eyeY, 1, 0, Math.PI * 2);
      ctx.fill();
      // Eye shine
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(pr.x + pr.w / 2 - 5, eyeY - 1, 0.8, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(pr.x + pr.w / 2 + 3, eyeY - 1, 0.8, 0, Math.PI * 2);
      ctx.fill();
    } else if (selectedChar === 'joaryu') {
      // Joaryu: Dark purple mysterious eyes
      ctx.fillStyle = '#8e44ad';
      ctx.shadowColor = '#9b59b6';
      ctx.shadowBlur = 6;
      ctx.fillRect(pr.x + pr.w / 2 - 7, headY + 13, 5, 4);
      ctx.fillRect(pr.x + pr.w / 2 + 2, headY + 13, 5, 4);
      // Eye shine
      ctx.fillStyle = '#b388eb';
      ctx.fillRect(pr.x + pr.w / 2 - 6, headY + 13, 2, 2);
      ctx.fillRect(pr.x + pr.w / 2 + 3, headY + 13, 2, 2);
      ctx.shadowBlur = 0;
    } else {
      // Usagi: Normal blue eyes
      ctx.fillStyle = '#67e8f9';
      ctx.fillRect(pr.x + pr.w / 2 - 7, headY + 13, 5, 4);
      ctx.fillRect(pr.x + pr.w / 2 + 2, headY + 13, 5, 4);
      ctx.fillStyle = '#fff';
      ctx.fillRect(pr.x + pr.w / 2 - 6, headY + 13, 2, 2);
      ctx.fillRect(pr.x + pr.w / 2 + 3, headY + 13, 2, 2);
    }

    // Mouth
    ctx.fillStyle = char.skinColor === '#9b59b6' ? '#7c3aed' : '#a0522d';
    ctx.beginPath();
    const mouthY = selectedChar === 'butsuo' ? headY + 24 : (selectedChar === 'chisa' ? headY + 18 : headY + 21);
    const mouthSize = selectedChar === 'butsuo' ? 4 : (selectedChar === 'chisa' ? 2 : 3);
    ctx.arc(pr.x + pr.w / 2, mouthY, mouthSize, 0, Math.PI);
    ctx.fill();

    ctx.restore();
  }

  function drawObstacle(o) {
    ctx.save();
    if (o.type === 'enemy') {
      // Enemy ninja
      ctx.fillStyle = o.color;
      roundRect(o.x, o.y - o.h, o.w, o.h, 6);
      ctx.fill();
      
      // Head
      ctx.fillStyle = '#444';
      ctx.beginPath();
      ctx.arc(o.x + o.w / 2, o.y - o.h - 8, 10, 0, Math.PI * 2);
      ctx.fill();
      
      // Eyes
      ctx.fillStyle = '#f00';
      ctx.fillRect(o.x + o.w / 2 - 6, o.y - o.h - 10, 4, 2);
      ctx.fillRect(o.x + o.w / 2 + 2, o.y - o.h - 10, 4, 2);
    } else {
      // Flying kunai
      o.phase += G.dt * 6;
      const bob = Math.sin(o.phase) * 4;
      
      ctx.fillStyle = 'rgba(255,255,255,0.15)';
      ctx.strokeStyle = 'rgba(255,255,255,0.5)';
      ctx.lineWidth = 2;
      
      ctx.beginPath();
      ctx.moveTo(o.x, o.y + bob);
      ctx.lineTo(o.x + o.w, o.y + bob - o.h / 2);
      ctx.lineTo(o.x + o.w, o.y + bob + o.h / 2);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
    }
    ctx.restore();
  }

  function drawProjectile(p) {
    ctx.save();
    if (p.type === 'spear') {
      ctx.fillStyle = '#e0e0e0';
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 2;
      roundRect(p.x, p.y - p.h / 2, p.w, p.h, 3);
      ctx.fill();
      ctx.stroke();
      
      // Spear tip
      ctx.beginPath();
      ctx.moveTo(p.x + p.w, p.y);
      ctx.lineTo(p.x + p.w + 15, p.y);
      ctx.strokeStyle = '#ccc';
      ctx.lineWidth = 4;
      ctx.stroke();
    } else if (p.type === 'shuriken') {
      p.spin += G.dt * 20;
      ctx.translate(p.x, p.y);
      ctx.rotate(p.spin);
      ctx.fillStyle = '#666';
      ctx.strokeStyle = '#aaa';
      ctx.lineWidth = 2;
      for (let i = 0; i < 4; i++) {
        ctx.rotate(Math.PI / 2);
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(p.radius, -4);
        ctx.lineTo(p.radius + 6, 0);
        ctx.lineTo(p.radius, 4);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
      }
    } else if (p.type === 'waterBall') {
      // Trail
      for (let i = 0; i < p.trail.length; i++) {
        const t = p.trail[i];
        ctx.globalAlpha = (i / p.trail.length) * 0.4;
        ctx.fillStyle = '#67e8f9';
        ctx.beginPath();
        ctx.arc(t.x, t.y, p.radius * (i / p.trail.length) * 0.7, 0, Math.PI * 2);
        ctx.fill();
      }
      
      // Main ball
      ctx.globalAlpha = 0.8;
      const grad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.radius);
      grad.addColorStop(0, '#fff');
      grad.addColorStop(0.4, '#67e8f9');
      grad.addColorStop(1, '#0ea5e9');
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
      ctx.fill();
    } else if (p.type === 'katanaSlash') {
      // Chisa: Katana slash with real sword
      p.slashPhase += G.dt * 20;
      const swingAngle = Math.sin(p.slashPhase * 2) * 0.8;
      
      ctx.translate(p.x + 20, p.y);
      ctx.rotate(swingAngle - 0.3);
      
      // Katana blade
      ctx.fillStyle = '#e8e8e8';
      ctx.strokeStyle = '#ccc';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(55, -4);
      ctx.lineTo(65, 0);
      ctx.lineTo(55, 4);
      ctx.lineTo(0, 0);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      
      // Blade edge shine
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(5, -1);
      ctx.lineTo(50, -3);
      ctx.stroke();
      
      // Katana handle (tsuka)
      ctx.fillStyle = '#2c1810';
      ctx.fillRect(-18, -4, 20, 8);
      
      // Handle wrap pattern
      ctx.strokeStyle = '#e74c3c';
      ctx.lineWidth = 2;
      for (let i = 0; i < 4; i++) {
        ctx.beginPath();
        ctx.moveTo(-16 + i * 5, -4);
        ctx.lineTo(-14 + i * 5, 4);
        ctx.stroke();
      }
      
      // Guard (tsuba)
      ctx.fillStyle = '#444';
      ctx.beginPath();
      ctx.ellipse(0, 0, 3, 8, 0, 0, Math.PI * 2);
      ctx.fill();
      
      // Slash trail effect
      ctx.globalAlpha = 0.4;
      ctx.strokeStyle = '#e74c3c';
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.arc(0, 0, 50, -0.8 - swingAngle, 0.5 - swingAngle);
      ctx.stroke();
    } else if (p.type === 'punch') {
      // Butsuo: Powerful punch effect
      p.punchPhase += G.dt * 15;
      const extend = Math.min(1, p.punchPhase / 3) * 40;
      const shake = Math.sin(p.punchPhase * 30) * 2;
      
      ctx.translate(p.x, p.y + shake);
      
      // Arm
      ctx.fillStyle = '#2a2a3a';
      ctx.fillRect(-15, -8, 35 + extend * 0.5, 16);
      
      // Fist
      ctx.fillStyle = '#f5deb3';
      ctx.beginPath();
      ctx.arc(20 + extend, 0, 20, 0, Math.PI * 2);
      ctx.fill();
      
      // Knuckles
      ctx.fillStyle = '#deb887';
      ctx.beginPath();
      ctx.arc(32 + extend, -6, 5, 0, Math.PI * 2);
      ctx.arc(38 + extend, -2, 5, 0, Math.PI * 2);
      ctx.arc(38 + extend, 4, 5, 0, Math.PI * 2);
      ctx.arc(32 + extend, 8, 4, 0, Math.PI * 2);
      ctx.fill();
      
      // Impact burst
      if (extend > 30) {
        ctx.globalAlpha = 0.8;
        ctx.strokeStyle = '#ffd700';
        ctx.lineWidth = 4;
        for (let i = 0; i < 8; i++) {
          const angle = (i / 8) * Math.PI - Math.PI / 2;
          const len = 15 + Math.random() * 20;
          ctx.beginPath();
          ctx.moveTo(45 + extend, 0);
          ctx.lineTo(45 + extend + Math.cos(angle) * len, Math.sin(angle) * len);
          ctx.stroke();
        }
        
        // Shockwave circles
        ctx.strokeStyle = 'rgba(255,255,255,0.6)';
        ctx.lineWidth = 3;
        const wave = (p.punchPhase * 3) % 1;
        ctx.beginPath();
        ctx.arc(50 + extend, 0, 10 + wave * 30, 0, Math.PI * 2);
        ctx.stroke();
      }
      
      // "POW" text effect
      if (extend > 35) {
        ctx.globalAlpha = 0.9;
        ctx.fillStyle = '#ff4444';
        ctx.font = 'bold 24px system-ui';
        ctx.fillText('POW!', 55 + extend, -15);
      }
    } else if (p.type === 'poisonShot') {
      // Teki: Poison projectile
      p.spin = (p.spin || 0) + G.dt * 12;
      ctx.translate(p.x + p.w / 2, p.y);
      ctx.rotate(p.spin);
      
      // Poison ball glow
      ctx.shadowColor = '#27ae60';
      ctx.shadowBlur = 15;
      
      // Main poison ball
      const grad = ctx.createRadialGradient(0, 0, 0, 0, 0, p.w / 2);
      grad.addColorStop(0, '#2ecc71');
      grad.addColorStop(0.6, '#27ae60');
      grad.addColorStop(1, '#1e8449');
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.arc(0, 0, p.w / 2, 0, Math.PI * 2);
      ctx.fill();
      
      // Skull symbol
      ctx.shadowBlur = 0;
      ctx.fillStyle = '#145a32';
      ctx.beginPath();
      ctx.arc(-3, -2, 3, 0, Math.PI * 2);
      ctx.arc(3, -2, 3, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.moveTo(-2, 3);
      ctx.lineTo(0, 5);
      ctx.lineTo(2, 3);
      ctx.stroke();
    } else if (p.type === 'needle') {
      // Susumu: Glowing medical needle
      p.glow += G.dt * 8;
      
      // Glow effect
      ctx.shadowColor = '#e74c3c';
      ctx.shadowBlur = 10 + Math.sin(p.glow) * 5;
      
      // Needle body
      ctx.fillStyle = '#e8e8e8';
      ctx.strokeStyle = '#ccc';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(p.x, p.y);
      ctx.lineTo(p.x + p.w - 5, p.y - 1);
      ctx.lineTo(p.x + p.w, p.y);
      ctx.lineTo(p.x + p.w - 5, p.y + 1);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      
      // Needle tip glow
      ctx.fillStyle = '#e74c3c';
      ctx.beginPath();
      ctx.arc(p.x + p.w, p.y, 2, 0, Math.PI * 2);
      ctx.fill();
      
      // Handle
      ctx.fillStyle = '#e74c3c';
      ctx.fillRect(p.x - 8, p.y - 3, 10, 6);
      
      ctx.shadowBlur = 0;
    } else if (p.type === 'eyeBeam') {
      // Shinji: Eye beam - purple laser
      p.glow += G.dt * 15;
      
      // Outer glow
      ctx.shadowColor = '#9b59b6';
      ctx.shadowBlur = 20;
      
      // Beam gradient
      const grad = ctx.createLinearGradient(p.x, p.y, p.x + p.w, p.y);
      grad.addColorStop(0, 'rgba(155, 89, 182, 0.9)');
      grad.addColorStop(0.5, 'rgba(142, 68, 173, 1)');
      grad.addColorStop(1, 'rgba(155, 89, 182, 0.5)');
      ctx.fillStyle = grad;
      
      // Main beam
      const waveHeight = Math.sin(p.glow) * 2;
      ctx.beginPath();
      ctx.moveTo(p.x, p.y - p.h/2 + waveHeight);
      ctx.lineTo(p.x + p.w, p.y - p.h/4);
      ctx.lineTo(p.x + p.w + 20, p.y);
      ctx.lineTo(p.x + p.w, p.y + p.h/4);
      ctx.lineTo(p.x, p.y + p.h/2 + waveHeight);
      ctx.closePath();
      ctx.fill();
      
      // Core beam (brighter center)
      ctx.fillStyle = '#fff';
      ctx.globalAlpha = 0.6;
      ctx.beginPath();
      ctx.moveTo(p.x, p.y - 1);
      ctx.lineTo(p.x + p.w, p.y);
      ctx.lineTo(p.x, p.y + 1);
      ctx.closePath();
      ctx.fill();
      
      // Eye source
      ctx.globalAlpha = 1;
      ctx.fillStyle = '#9b59b6';
      ctx.beginPath();
      ctx.arc(p.x - 5, p.y, 8, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(p.x - 5, p.y, 4, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.shadowBlur = 0;
    } else if (p.type === 'windWave') {
      // Kazuya: Wind wave - swirling air
      p.phase += G.dt * 10;
      
      ctx.translate(p.x + p.w/2, p.y);
      
      // Multiple arc layers for wind effect
      for (let i = 0; i < 4; i++) {
        const offset = Math.sin(p.phase + i * 0.5) * 5;
        const alpha = 0.7 - i * 0.15;
        ctx.globalAlpha = alpha;
        ctx.strokeStyle = i === 0 ? '#fff' : '#87ceeb';
        ctx.lineWidth = 4 - i;
        
        ctx.beginPath();
        ctx.arc(offset, 0, 15 + i * 8, -Math.PI * 0.6, Math.PI * 0.6);
        ctx.stroke();
      }
      
      // Swirl particles
      ctx.fillStyle = '#87ceeb';
      ctx.globalAlpha = 0.6;
      for (let i = 0; i < 5; i++) {
        const angle = p.phase * 2 + i * Math.PI * 0.4;
        const dist = 10 + i * 5;
        ctx.beginPath();
        ctx.arc(Math.cos(angle) * dist, Math.sin(angle) * dist * 0.6, 3 - i * 0.4, 0, Math.PI * 2);
        ctx.fill();
      }
    } else if (p.type === 'crowFeather') {
      // Togami: Crow feather projectile
      p.spin += G.dt * 6;
      
      ctx.translate(p.x + p.w/2, p.y);
      ctx.rotate(p.spin * 0.5);
      
      // Feather shadow/glow
      ctx.shadowColor = '#000';
      ctx.shadowBlur = 8;
      
      // Feather body
      ctx.fillStyle = '#1a1a1a';
      ctx.beginPath();
      ctx.moveTo(-p.w/2, 0);
      ctx.quadraticCurveTo(-p.w/4, -p.h/2, p.w/2, -2);
      ctx.lineTo(p.w/2 + 5, 0);
      ctx.lineTo(p.w/2, 2);
      ctx.quadraticCurveTo(-p.w/4, p.h/2, -p.w/2, 0);
      ctx.fill();
      
      // Feather spine
      ctx.strokeStyle = '#333';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(-p.w/2, 0);
      ctx.lineTo(p.w/2, 0);
      ctx.stroke();
      
      // Feather details
      ctx.strokeStyle = '#2a2a2a';
      ctx.lineWidth = 0.5;
      for (let i = 0; i < 5; i++) {
        const fx = -p.w/3 + i * (p.w/4);
        ctx.beginPath();
        ctx.moveTo(fx, 0);
        ctx.lineTo(fx + 3, -p.h/3);
        ctx.moveTo(fx, 0);
        ctx.lineTo(fx + 3, p.h/3);
        ctx.stroke();
      }
      
      ctx.shadowBlur = 0;
    } else if (p.type === 'paperThrow') {
      // Kagi: Sharp paper projectile
      p.spin += G.dt * 12;
      
      ctx.translate(p.x + p.w/2, p.y);
      ctx.rotate(p.spin);
      
      // Paper glow
      ctx.shadowColor = '#fff';
      ctx.shadowBlur = 10;
      
      // Paper body - folded origami style
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.moveTo(-p.w/2, 0);
      ctx.lineTo(0, -p.h/2);
      ctx.lineTo(p.w/2, 0);
      ctx.lineTo(0, p.h/2);
      ctx.closePath();
      ctx.fill();
      
      // Paper fold lines
      ctx.strokeStyle = '#ccc';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(-p.w/2, 0);
      ctx.lineTo(p.w/2, 0);
      ctx.moveTo(0, -p.h/2);
      ctx.lineTo(0, p.h/2);
      ctx.stroke();
      
      // Sharp edges highlight
      ctx.strokeStyle = '#e74c3c';
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(-p.w/2 - 2, 0);
      ctx.lineTo(0, -p.h/2 - 2);
      ctx.lineTo(p.w/2 + 2, 0);
      ctx.stroke();
      
      ctx.shadowBlur = 0;
    } else if (p.type === 'kissThrow') {
      // Akemi: Flying kiss - heart shaped with sparkles
      p.wobble += G.dt * 8;
      p.phase += G.dt * 4;
      
      const wobbleY = Math.sin(p.wobble) * 8;
      
      ctx.translate(p.x + p.w/2, p.y + wobbleY);
      ctx.rotate(Math.sin(p.phase) * 0.2);
      
      // Pink glow
      ctx.shadowColor = '#ff69b4';
      ctx.shadowBlur = 15;
      
      // Heart shape
      ctx.fillStyle = '#ff1493';
      ctx.beginPath();
      ctx.moveTo(0, p.h * 0.3);
      ctx.bezierCurveTo(-p.w/2, -p.h * 0.1, -p.w/2, -p.h * 0.5, 0, -p.h * 0.2);
      ctx.bezierCurveTo(p.w/2, -p.h * 0.5, p.w/2, -p.h * 0.1, 0, p.h * 0.3);
      ctx.fill();
      
      // Heart highlight
      ctx.fillStyle = '#ff69b4';
      ctx.beginPath();
      ctx.ellipse(-p.w * 0.15, -p.h * 0.15, 3, 4, -0.3, 0, Math.PI * 2);
      ctx.fill();
      
      // Sparkles around
      ctx.fillStyle = '#fff';
      for (let i = 0; i < 4; i++) {
        const sparkAngle = p.phase * 2 + i * Math.PI / 2;
        const sparkDist = 18 + Math.sin(p.wobble + i) * 3;
        const sx = Math.cos(sparkAngle) * sparkDist;
        const sy = Math.sin(sparkAngle) * sparkDist * 0.6;
        const sparkSize = 2 + Math.sin(p.wobble * 2 + i) * 1;
        ctx.globalAlpha = 0.7 + Math.sin(p.wobble + i) * 0.3;
        ctx.beginPath();
        ctx.arc(sx, sy, sparkSize, 0, Math.PI * 2);
        ctx.fill();
      }
      
      ctx.shadowBlur = 0;
    } else if (p.type === 'illusionKill') {
      // Ryoken: Illusion eye projectile
      p.phase += G.dt * 6;
      
      ctx.translate(p.x + p.w/2, p.y);
      ctx.rotate(Math.sin(p.phase) * 0.1);
      
      // Purple glow
      ctx.shadowColor = '#9b59b6';
      ctx.shadowBlur = 20;
      
      // Eye shape
      ctx.fillStyle = '#9b59b6';
      ctx.beginPath();
      ctx.ellipse(0, 0, p.w/2, p.h/3, 0, 0, Math.PI * 2);
      ctx.fill();
      
      // Pupil
      ctx.fillStyle = '#f1c40f';
      ctx.beginPath();
      ctx.arc(0, 0, 8, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#000';
      ctx.beginPath();
      ctx.ellipse(0, 0, 4, 6, 0, 0, Math.PI * 2);
      ctx.fill();
      
      // Swirling effect
      ctx.strokeStyle = 'rgba(155, 89, 182, 0.5)';
      ctx.lineWidth = 2;
      for (let i = 0; i < 3; i++) {
        const angle = p.phase + i * Math.PI * 2/3;
        ctx.beginPath();
        ctx.arc(0, 0, 25 + i * 5, angle, angle + 1);
        ctx.stroke();
      }
      
      ctx.shadowBlur = 0;
    } else if (p.type === 'arrowShot') {
      // Riku: Arrow projectile
      ctx.translate(p.x, p.y);
      
      // Arrow shaft
      ctx.fillStyle = '#8B4513';
      ctx.fillRect(0, -2, p.w - 10, 4);
      
      // Arrow head
      ctx.fillStyle = '#666';
      ctx.beginPath();
      ctx.moveTo(p.w - 10, -5);
      ctx.lineTo(p.w, 0);
      ctx.lineTo(p.w - 10, 5);
      ctx.closePath();
      ctx.fill();
      
      // Fletching (feathers)
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(-8, -6);
      ctx.lineTo(5, 0);
      ctx.lineTo(-8, 6);
      ctx.closePath();
      ctx.fill();
    } else if (p.type === 'kunaiThrow') {
      // Joaryu: Kunai projectile
      p.spin += G.dt * 15;
      
      ctx.translate(p.x + p.w/2, p.y);
      ctx.rotate(p.spin);
      
      // Kunai blade
      ctx.fillStyle = '#555';
      ctx.beginPath();
      ctx.moveTo(-p.w/2, 0);
      ctx.lineTo(0, -4);
      ctx.lineTo(p.w/2, 0);
      ctx.lineTo(0, 4);
      ctx.closePath();
      ctx.fill();
      
      // Handle ring
      ctx.strokeStyle = '#8e44ad';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(-p.w/2 - 5, 0, 5, 0, Math.PI * 2);
      ctx.stroke();
      
      // Blade shine
      ctx.strokeStyle = '#888';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(-p.w/4, -1);
      ctx.lineTo(p.w/4, -1);
      ctx.stroke();
    } else if (p.type === 'rainArrow') {
      // Riku: Arrow falling from above
      ctx.translate(p.x, p.y);
      ctx.rotate(Math.PI / 2); // Point downward
      
      // Arrow shaft
      ctx.fillStyle = '#8B4513';
      ctx.fillRect(-15, -2, 25, 4);
      
      // Arrow head
      ctx.fillStyle = '#666';
      ctx.beginPath();
      ctx.moveTo(10, -5);
      ctx.lineTo(18, 0);
      ctx.lineTo(10, 5);
      ctx.closePath();
      ctx.fill();
      
      // Fletching
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.moveTo(-15, 0);
      ctx.lineTo(-22, -5);
      ctx.lineTo(-10, 0);
      ctx.lineTo(-22, 5);
      ctx.closePath();
      ctx.fill();
      
      // Motion blur trail
      ctx.globalAlpha = 0.3;
      ctx.fillStyle = '#8B4513';
      ctx.fillRect(-15, -1, 25, 2);
      ctx.translate(0, -10);
      ctx.globalAlpha = 0.15;
      ctx.fillRect(-15, -1, 25, 2);
    } else if (p.type === 'rasengan') {
      // Rasengan - glowing blue sphere
      ctx.translate(p.x, p.y);
      
      // Outer glow
      ctx.shadowColor = '#3b82f6';
      ctx.shadowBlur = 30;
      
      // Spinning effect
      const spinAngle = G.t * 15;
      
      // Main sphere gradient
      const grad = ctx.createRadialGradient(0, 0, 0, 0, 0, p.radius);
      grad.addColorStop(0, '#fff');
      grad.addColorStop(0.3, '#93c5fd');
      grad.addColorStop(0.7, '#3b82f6');
      grad.addColorStop(1, '#1d4ed8');
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.arc(0, 0, p.radius, 0, Math.PI * 2);
      ctx.fill();
      
      // Inner spinning lines
      ctx.strokeStyle = 'rgba(255,255,255,0.7)';
      ctx.lineWidth = 2;
      for (let i = 0; i < 6; i++) {
        const angle = spinAngle + i * Math.PI / 3;
        ctx.beginPath();
        ctx.arc(0, 0, p.radius * 0.7, angle, angle + 0.5);
        ctx.stroke();
      }
      
      // Core
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(0, 0, 8, 0, Math.PI * 2);
      ctx.fill();
      
      // Sparkles
      ctx.fillStyle = '#bfdbfe';
      for (let i = 0; i < 8; i++) {
        const sparkAngle = spinAngle * 2 + i * Math.PI / 4;
        const sparkDist = p.radius + 5 + Math.sin(G.t * 10 + i) * 5;
        const sx = Math.cos(sparkAngle) * sparkDist;
        const sy = Math.sin(sparkAngle) * sparkDist;
        ctx.beginPath();
        ctx.arc(sx, sy, 3, 0, Math.PI * 2);
        ctx.fill();
      }
      
      ctx.shadowBlur = 0;
    }
    ctx.restore();
  }

  function drawParticles(dt) {
    ctx.save();
    for (let i = G.particles.length - 1; i >= 0; i--) {
      const p = G.particles[i];
      p.life -= dt;
      if (p.life <= 0) { G.particles.splice(i, 1); continue; }
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.vy += 600 * dt;
      
      ctx.globalAlpha = clamp(p.life * 2.5, 0, 0.6);
      ctx.fillStyle = p.color || '#fff';
      ctx.fillRect(p.x, p.y, 3, 3);
    }
    ctx.restore();
  }

  function roundRect(x, y, w, h, r) {
    r = Math.min(r, w / 2, h / 2);
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
  }

  function drawUI() {
    if (!G.running && !G.gameOver) {
      ctx.save();
      ctx.fillStyle = 'rgba(255,255,255,0.9)';
      ctx.font = '900 36px system-ui';
      ctx.textAlign = 'center';
      ctx.fillText('RPGTurk Ninja Runner v1.0', WORLD_W / 2, WORLD_H / 2 - 40);
      ctx.font = '600 16px system-ui';
      ctx.globalAlpha = 0.7;
      ctx.fillText('Zƒ±pla ile ba≈üla', WORLD_W / 2, WORLD_H / 2);
      ctx.restore();
    }

    if (G.gameOver) {
      ctx.save();
      ctx.fillStyle = 'rgba(0,0,0,0.5)';
      ctx.fillRect(0, 0, WORLD_W, WORLD_H);
      
      ctx.fillStyle = '#ff6b6b';
      ctx.font = '900 42px system-ui';
      ctx.textAlign = 'center';
      ctx.fillText('Geberdin.', WORLD_W / 2, WORLD_H / 2 - 30);
      
      ctx.fillStyle = '#fff';
      ctx.font = '700 22px system-ui';
      ctx.fillText(`Skor: ${Math.floor(G.score)}`, WORLD_W / 2, WORLD_H / 2 + 10);
      
      ctx.font = '500 14px system-ui';
      ctx.globalAlpha = 0.7;
      ctx.fillText('Zƒ±pla ile tekrar dene', WORLD_W / 2, WORLD_H / 2 + 45);
      ctx.restore();
    }

    // Ult active indicator
    if (G.ultActive) {
      ctx.save();
      ctx.fillStyle = '#a855f7';
      ctx.font = '700 14px system-ui';
      ctx.textAlign = 'center';
      ctx.fillText(`‚ú® ${CHARACTERS[selectedChar].skillF.name} - ${G.ultTimer.toFixed(1)}s ‚ú®`, WORLD_W / 2, 30);
      ctx.restore();
    }
    
    // Active item effect indicator
    if (G.activeItem && G.activeItemTimer > 0) {
      ctx.save();
      const item = SPECIAL_ITEMS.find(i => i.id === G.activeItem);
      if (item) {
        const itemColor = G.activeItem === 'lightning_armor' ? '#fbbf24' :
                          G.activeItem === 'ishigakure_necklace' ? '#ef4444' :
                          G.activeItem === 'viagra' ? '#22c55e' : '#fff';
        ctx.fillStyle = itemColor;
        ctx.font = '700 14px system-ui';
        ctx.textAlign = 'center';
        const yPos = G.ultActive ? 50 : 30;
        ctx.fillText(`${item.icon} ${item.name} - ${G.activeItemTimer.toFixed(1)}s`, WORLD_W / 2, yPos);
      }
      ctx.restore();
    }
  }

  // ===== UPDATE =====
  function update(dt) {
    G.t += dt;
    G.dt = dt;
    
    if (!G.running) return;

    // Apply slow effect from Viagra item
    const speedMod = G.activeItem === 'viagra' ? 0.5 : 1;
    const effectiveSpeed = G.speed * speedMod;
    
    G.speed = Math.min(G.speedMax, G.speed + G.speedAccel * dt);
    G.score += dt * (G.speed / 100) * G.scoreMultiplier;
    
    // Earn coins based on score (1 coin per 10 points)
    const newCoins = Math.floor(G.score / 10) - Math.floor((G.score - dt * (G.speed / 100) * G.scoreMultiplier) / 10);
    if (newCoins > 0) G.coins += newCoins;
    
    G.groundScroll += effectiveSpeed * dt;

    // Update item effects
    updateItemEffects(dt);
    
    // Update puppet
    updatePuppet(dt);
    
    // Update metal rain (Iori's Katana)
    updateMetalRain(dt);

    // Cooldowns - Ishigakure Necklace effect
    const skillXReduction = G.activeItem === 'ishigakure_necklace' ? 4 : 1;
    if (G.skillXCooldown > 0) G.skillXCooldown = Math.max(0, G.skillXCooldown - dt * skillXReduction);
    if (G.skillFCooldown > 0) G.skillFCooldown = Math.max(0, G.skillFCooldown - dt);
    updateSkillUI();

    // Ultimate timer
    if (G.ultActive) {
      G.ultTimer -= dt;
      
      // Eagle flight: fly high
      if (G.ultType === 'eagleFlight') {
        G.eagleWingPhase += dt * 8;
        // Smoothly rise to target height
        const targetY = G.eagleTargetY + Math.sin(G.t * 2) * 20; // Gentle bobbing
        P.y += (targetY - P.y) * 4 * dt;
        P.vy = 0;
        P.onGround = false;
        
        // Eagle particles
        if (Math.random() < 0.3) {
          G.particles.push({
            x: P.x + rand(-20, P.w + 20),
            y: P.y + rand(0, 20),
            vx: rand(-100, -50),
            vy: rand(-30, 30),
            life: rand(0.3, 0.5),
            color: '#c4b5fd'
          });
        }
      }
      
      // Headbutt: fly forward through enemies at ground level
      if (G.ultType === 'headbutt') {
        const targetY = G.headbuttY + Math.sin(G.t * 6) * 5; // Very slight bobbing
        P.y += (targetY - P.y) * 8 * dt;
        P.vy = 0;
        P.onGround = false;
        
        // Ground dust particles
        if (Math.random() < 0.5) {
          G.particles.push({
            x: P.x - rand(10, 40),
            y: G.groundY + rand(-5, 5),
            vx: rand(-100, -50),
            vy: rand(-40, -10),
            life: rand(0.2, 0.4),
            color: '#8b7355'
          });
        }
        
        // Headbutt particles
        if (Math.random() < 0.4) {
          G.particles.push({
            x: P.x + P.w + rand(0, 20),
            y: P.y - P.h / 2 + rand(-20, 20),
            vx: rand(-150, -80),
            vy: rand(-30, 30),
            life: rand(0.2, 0.4),
            color: '#ecf0f1'
          });
        }
      }
      
      // Sword storm: rapid slashes that destroy everything
      if (G.ultType === 'swordStorm') {
        G.swordStormTimer += dt;
        // Create slash every 0.4 seconds (10 slashes in 4 seconds)
        if (G.swordStormTimer >= 0.4) {
          G.swordStormTimer = 0;
          const pr = playerRect();
          G.projectiles.push({
            type: 'katanaSlash',
            x: pr.x + pr.w - 10,
            y: pr.y + pr.h * 0.3 + rand(-20, 20),
            w: 80,
            h: 60,
            vx: 0,
            life: 0.35,
            slashPhase: rand(0, 3)
          });
          // Slash particles
          for (let i = 0; i < 5; i++) {
            G.particles.push({
              x: pr.x + pr.w + rand(0, 30),
              y: pr.y + pr.h * 0.3 + rand(-15, 15),
              vx: rand(80, 200),
              vy: rand(-50, 50),
              life: rand(0.2, 0.35),
              color: '#e74c3c'
            });
          }
        }
      }
      
      // Poison armor: green aura particles
      if (G.ultType === 'poisonArmor') {
        if (Math.random() < 0.5) {
          const angle = Math.random() * Math.PI * 2;
          G.particles.push({
            x: P.x + P.w / 2 + Math.cos(angle) * rand(20, 35),
            y: P.y - P.h / 2 + Math.sin(angle) * rand(20, 35),
            vx: Math.cos(angle) * rand(20, 50),
            vy: Math.sin(angle) * rand(20, 50) - 30,
            life: rand(0.3, 0.5),
            color: '#27ae60'
          });
        }
      }
      
      // Ice storm: swirling ice particles
      if (G.ultType === 'iceStorm') {
        if (Math.random() < 0.6) {
          const angle = Math.random() * Math.PI * 2;
          const dist = rand(30, 60);
          G.particles.push({
            x: P.x + P.w / 2 + Math.cos(angle) * dist,
            y: P.y - P.h / 2 + Math.sin(angle) * dist * 0.6,
            vx: Math.cos(angle + Math.PI / 2) * rand(50, 100),
            vy: Math.sin(angle + Math.PI / 2) * rand(30, 60) - 20,
            life: rand(0.3, 0.5),
            color: Math.random() > 0.5 ? '#67e8f9' : '#fff'
          });
        }
      }
      
      if (G.ultTimer <= 0) {
        G.ultActive = false;
        G.ultType = null;
        G.monkeyRect = null;
        canvas.classList.remove('ult-active');
      }
    }

    // Physics
    if (G.ultActive && (G.ultType === 'eagleFlight' || G.ultType === 'headbutt' || G.ultType === 'poisonArmor' || G.ultType === 'paperWings')) {
      // Eagle/headbutt/poison armor/paper wings controls the position, skip normal physics for flying ones
      if (G.ultType === 'poisonArmor') {
        // Poison armor still uses normal physics, just passes through enemies
        if (!P.onGround) {
          P.vy += G.gravity * dt;
          P.y += P.vy * dt;
          if (P.y >= G.groundY) {
            P.y = G.groundY;
            P.vy = 0;
            P.onGround = true;
          }
        } else {
          P.y = G.groundY;
        }
      } else if (G.ultType === 'paperWings') {
        // Paper wings flight - smooth up/down control
        P.y += (G.paperWingsY - P.y) * 8 * dt;
        P.vy = 0;
        P.onGround = false;
      }
    } else if (!P.onGround) {
      // Air Dash - ƒ∞tici G√º√ß
      if (G.airDashTimer > 0) {
        G.airDashTimer -= dt;
        P.x += 800 * dt; // Dash forward!
        P.vy = 0; // Freeze vertical movement during dash
        // Keep player in bounds
        if (P.x > 300) P.x = 300;
      } else {
        P.vy += G.gravity * dt;
        P.y += P.vy * dt;
        
        // Smoothly return to normal position after dash
        if (P.x > 100) {
          P.x -= 400 * dt;
          if (P.x < 100) P.x = 100;
        }
      }
      
      // Check ground collision
      if (P.y >= G.groundY) {
        P.y = G.groundY;
        P.vy = 0;
        P.onGround = true;
        G.onPlatform = null;
        G.hasDoubleJumped = false; // Reset double jump on landing
        G.hasAirDashed = false; // Reset air dash on landing
        console.log('LANDED - hasAirDashed reset to false');
      }
    } else {
      // On ground - stay at current Y (could be platform or ground)
      if (G.onPlatform) {
        P.y = G.onPlatform.y;
      } else {
        P.y = G.groundY;
      }
      G.hasDoubleJumped = false; // Reset double jump while on ground
      G.hasAirDashed = false; // Reset air dash while on ground
    }

    // Spawn obstacles (only when boss is not active)
    if (!G.bossActive) {
      G.spawnTimer -= dt;
      if (G.spawnTimer <= 0) {
        spawnObstacle();
        const speedFactor = clamp((G.speed - 280) / 320, 0, 1);
        G.spawnTimer = rand(
          Math.max(0.45, G.spawnMin - speedFactor * 0.15),
          Math.max(0.75, G.spawnMax - speedFactor * 0.20)
        );
      }
    }

    // Boss spawn at 500 points (Riaru) and 1500 points (MAXDOWN)
    if (!G.bossActive && G.score >= 500) {
      if (!G.riaru1Defeated && G.score >= 500) {
        spawnBoss('riaru');
      } else if (G.riaru1Defeated && !G.maxdownDefeated && G.score >= 1500) {
        spawnBoss('maxdown');
      }
    }

    // Update boss
    if (G.bossActive && G.boss) {
      updateBoss(dt);
    }

    // Update scrolls/parchments
    updateScrolls(dt);
    
    // Update platforms
    updatePlatforms(dt);

    // Update projectiles
    const pr = playerRect();
    for (let i = G.projectiles.length - 1; i >= 0; i--) {
      const p = G.projectiles[i];
      p.life -= dt;
      
      if (p.type === 'spear' && p.extending) {
        p.w = Math.min(p.maxW, p.w + 400 * dt);
      } else if (p.type === 'rainArrow') {
        // Rain arrows fall down
        p.y += p.vy * dt;
        if (p.y > G.groundY) {
          G.projectiles.splice(i, 1);
          continue;
        }
      } else if (p.vx) {
        p.x += p.vx * dt;
        if (p.vy) p.y += p.vy * dt;
      }
      
      if (p.trail) {
        p.trail.push({ x: p.x, y: p.y });
        if (p.trail.length > 10) p.trail.shift();
      }
      
      if (p.life <= 0 || p.x > WORLD_W + 50) {
        G.projectiles.splice(i, 1);
        continue;
      }

      // Collision with obstacles
      const pRect = p.type === 'spear' 
        ? { x: p.x, y: p.y - p.h / 2, w: p.w, h: p.h }
        : p.type === 'rainArrow'
        ? { x: p.x - 10, y: p.y - 20, w: 20, h: 40 }
        : { x: p.x - (p.radius || 12), y: p.y - (p.radius || 12), w: (p.radius || 12) * 2, h: (p.radius || 12) * 2 };
      
      for (let j = G.obstacles.length - 1; j >= 0; j--) {
        const o = G.obstacles[j];
        const oRect = obstacleRect(o);
        if (rectsOverlap(pRect, oRect)) {
          // Destroy obstacle
          for (let k = 0; k < 12; k++) {
            G.particles.push({
              x: o.x + o.w / 2 + rand(-15, 15),
              y: o.y - o.h / 2 + rand(-15, 15),
              vx: rand(-150, 150),
              vy: rand(-200, -50),
              life: rand(0.3, 0.5),
              color: o.color || '#888'
            });
          }
          G.obstacles.splice(j, 1);
          G.score += 15;
          
          // Spear and rasengan don't get destroyed, shuriken/water ball do
          if (p.type !== 'spear' && p.type !== 'rasengan') {
            G.projectiles.splice(i, 1);
          }
          
          // Rasengan clears all enemies
          if (p.type === 'rasengan' && !p.cleared) {
            p.cleared = true;
            // Clear all obstacles
            for (let k = G.obstacles.length - 1; k >= 0; k--) {
              const obs = G.obstacles[k];
              for (let m = 0; m < 8; m++) {
                G.particles.push({
                  x: obs.x + obs.w / 2,
                  y: obs.y - obs.h / 2,
                  vx: rand(-200, 200),
                  vy: rand(-200, -50),
                  life: rand(0.3, 0.5),
                  color: '#3b82f6'
                });
              }
              G.score += 10;
            }
            G.obstacles = [];
            
            // If boss is active, deal half of max HP damage
            if (G.bossActive && G.boss) {
              const rasenganDamage = Math.ceil(G.boss.maxHp / 2);
              G.boss.hp -= rasenganDamage;
              // Boss hit particles
              for (let m = 0; m < 30; m++) {
                G.particles.push({
                  x: G.boss.x + rand(0, G.boss.w),
                  y: G.boss.y - G.boss.h / 2 + rand(-30, 30),
                  vx: rand(-200, -50),
                  vy: rand(-150, 150),
                  life: rand(0.5, 0.8),
                  color: '#3b82f6'
                });
              }
              if (G.boss.hp <= 0) {
                defeatBoss();
              }
            }
          }
          break;
        }
      }
      
      // Rasengan direct boss collision check (when no obstacles to hit)
      if (p.type === 'rasengan' && !p.cleared && G.bossActive && G.boss) {
        const rasenganRect = { x: p.x - p.radius, y: p.y - p.radius, w: p.radius * 2, h: p.radius * 2 };
        const bossRect = { x: G.boss.x, y: G.boss.y - G.boss.h, w: G.boss.w, h: G.boss.h };
        
        if (rectsOverlap(rasenganRect, bossRect)) {
          p.cleared = true;
          
          // Deal half of max HP damage
          const rasenganDamage = Math.ceil(G.boss.maxHp / 2);
          G.boss.hp -= rasenganDamage;
          
          // Clear all obstacles too
          for (let k = G.obstacles.length - 1; k >= 0; k--) {
            const obs = G.obstacles[k];
            for (let m = 0; m < 8; m++) {
              G.particles.push({
                x: obs.x + obs.w / 2,
                y: obs.y - obs.h / 2,
                vx: rand(-200, 200),
                vy: rand(-200, -50),
                life: rand(0.3, 0.5),
                color: '#3b82f6'
              });
            }
            G.score += 10;
          }
          G.obstacles = [];
          
          // Boss hit particles
          for (let m = 0; m < 30; m++) {
            G.particles.push({
              x: G.boss.x + rand(0, G.boss.w),
              y: G.boss.y - G.boss.h / 2 + rand(-30, 30),
              vx: rand(-200, -50),
              vy: rand(-150, 150),
              life: rand(0.5, 0.8),
              color: '#3b82f6'
            });
          }
          
          // Remove rasengan after hitting boss
          G.projectiles.splice(i, 1);
          
          if (G.boss.hp <= 0) {
            defeatBoss();
          }
        }
      }
    }

    // Update obstacles
    for (let i = G.obstacles.length - 1; i >= 0; i--) {
      const o = G.obstacles[i];
      o.x -= effectiveSpeed * dt;

      if (o.x < -100) {
        G.obstacles.splice(i, 1);
        continue;
      }

      // Puppet collision - puppet blocks obstacles as a shield (doesn't take damage)
      if (G.puppet) {
        const puppetR = puppetRect();
        const obstRect = obstacleRect(o);
        if (rectsOverlap(puppetR, obstRect)) {
          // Puppet blocks the obstacle - destroy it with particles
          for (let k = 0; k < 15; k++) {
            G.particles.push({
              x: o.x + o.w / 2,
              y: o.y - o.h / 2,
              vx: rand(-150, 150),
              vy: rand(-200, -50),
              life: rand(0.4, 0.7),
              color: k % 2 === 0 ? '#a855f7' : CHARACTERS[G.puppet.charKey].color
            });
          }
          
          // Destroy obstacle
          G.obstacles.splice(i, 1);
          G.score += 5;
          
          continue; // Skip player collision check for this obstacle
        }
      }

      // Collision with player
      const oRect = obstacleRect(o);
      const pad = o.hitPad || 0;
      const a = { x: pr.x + 6, y: pr.y + 6, w: pr.w - 12, h: pr.h - 12 };
      const b = { x: oRect.x + pad, y: oRect.y + pad, w: oRect.w - pad * 2, h: oRect.h - pad * 2 };

      if (rectsOverlap(a, b)) {
        // Ultimate effects
        if (G.ultActive) {
          if (G.ultType === 'moonlight' || G.ultType === 'iceStorm') {
            // Destroy on contact
            for (let k = 0; k < 15; k++) {
              G.particles.push({
                x: o.x + o.w / 2,
                y: o.y - o.h / 2,
                vx: rand(-180, 180),
                vy: rand(-220, -40),
                life: rand(0.4, 0.7),
                color: G.ultType === 'moonlight' ? '#fff' : '#67e8f9'
              });
            }
            G.obstacles.splice(i, 1);
            G.score += 10;
          } else if (G.ultType === 'eagleFlight') {
            // Pass through
            continue;
          } else if (G.ultType === 'headbutt') {
            // Headbutt destroys enemies on contact
            for (let k = 0; k < 20; k++) {
              G.particles.push({
                x: o.x + o.w / 2,
                y: o.y - o.h / 2,
                vx: rand(-200, 200),
                vy: rand(-250, -80),
                life: rand(0.4, 0.7),
                color: '#ffd700'
              });
            }
            G.obstacles.splice(i, 1);
            G.score += 20;
            continue;
          } else if (G.ultType === 'poisonArmor') {
            // Poison armor passes through and poisons enemies
            for (let k = 0; k < 15; k++) {
              G.particles.push({
                x: o.x + o.w / 2,
                y: o.y - o.h / 2,
                vx: rand(-150, 150),
                vy: rand(-180, -40),
                life: rand(0.4, 0.6),
                color: '#27ae60'
              });
            }
            G.obstacles.splice(i, 1);
            G.score += 10;
            continue;
          } else if (G.ultType === 'monkeyFriend') {
            // Monkey friend makes player invincible, but monkey handles the crushing
            continue;
          } else if (G.ultType === 'illusionStorm') {
            // Shinji: Illusion storm stuns/destroys enemies
            for (let k = 0; k < 15; k++) {
              G.particles.push({
                x: o.x + o.w / 2,
                y: o.y - o.h / 2,
                vx: rand(-150, 150),
                vy: rand(-180, -40),
                life: rand(0.4, 0.6),
                color: '#9b59b6'
              });
            }
            G.obstacles.splice(i, 1);
            G.score += 12;
            continue;
          } else if (G.ultType === 'windSword') {
            // Kazuya: Wind sword cuts all enemies
            for (let k = 0; k < 18; k++) {
              G.particles.push({
                x: o.x + o.w / 2,
                y: o.y - o.h / 2,
                vx: rand(-200, 200),
                vy: rand(-220, -60),
                life: rand(0.4, 0.7),
                color: '#87ceeb'
              });
            }
            G.obstacles.splice(i, 1);
            G.score += 15;
            continue;
          } else if (G.ultType === 'darkAura') {
            // Togami: Dark aura crushes enemies
            for (let k = 0; k < 20; k++) {
              G.particles.push({
                x: o.x + o.w / 2,
                y: o.y - o.h / 2,
                vx: rand(-180, 180),
                vy: rand(-200, -50),
                life: rand(0.4, 0.7),
                color: k % 3 === 0 ? '#3498db' : '#1a1a1a'
              });
            }
            G.obstacles.splice(i, 1);
            G.score += 18;
            continue;
          } else if (G.ultType === 'paperWings') {
            // Kagi: Paper wings slice through enemies
            for (let k = 0; k < 18; k++) {
              G.particles.push({
                x: o.x + o.w / 2,
                y: o.y - o.h / 2,
                vx: rand(-200, 200),
                vy: rand(-200, -50),
                life: rand(0.4, 0.7),
                color: k % 2 === 0 ? '#fff' : '#ddd'
              });
            }
            G.obstacles.splice(i, 1);
            G.score += 16;
            continue;
          }
        } else {
          // Check for Lightning Armor invincibility
          const isInvincible = G.activeItem === 'lightning_armor';
          
          if (isInvincible) {
            // Pass through enemies, destroy them
            for (let k = 0; k < 15; k++) {
              G.particles.push({
                x: o.x + o.w / 2,
                y: o.y - o.h / 2,
                vx: rand(-180, 180),
                vy: rand(-200, -50),
                life: rand(0.4, 0.7),
                color: '#fbbf24'
              });
            }
            G.obstacles.splice(i, 1);
            G.score += 10;
            continue;
          }
          
          // Player hit - check lives
          G.lives--;
          
          if (G.lives <= 0) {
            // Game over
            G.gameOver = true;
            G.running = false;
            canvas.classList.remove('ult-active');
            // Show leaderboard after a short delay
            setTimeout(() => {
              showLeaderboard(G.score);
            }, 500);
          } else {
            // Lost a life but survived - destroy obstacle and brief invincibility effect
            for (let k = 0; k < 15; k++) {
              G.particles.push({
                x: o.x + o.w / 2,
                y: o.y - o.h / 2,
                vx: rand(-200, 200),
                vy: rand(-200, -50),
                life: rand(0.4, 0.7),
                color: '#ef4444'
              });
            }
            G.obstacles.splice(i, 1);
          }
        }
      }
      
      // Monkey friend collision - monkey crushes enemies
      if (G.ultActive && G.ultType === 'monkeyFriend' && G.monkeyRect) {
        const mRect = G.monkeyRect;
        if (rectsOverlap(mRect, oRect)) {
          // Monkey crushes the enemy
          for (let k = 0; k < 18; k++) {
            G.particles.push({
              x: o.x + o.w / 2,
              y: o.y - o.h / 2,
              vx: rand(-200, 200),
              vy: rand(-250, -80),
              life: rand(0.4, 0.7),
              color: '#8B4513'
            });
          }
          G.obstacles.splice(i, 1);
          G.score += 15;
          continue;
        }
      }
      
      // Animal friends collision - animals attack enemies
      if (G.ultActive && G.ultType === 'animalFriends' && G.animalRects) {
        let hit = false;
        for (const aRect of G.animalRects) {
          if (rectsOverlap(aRect, oRect)) {
            hit = true;
            break;
          }
        }
        if (hit) {
          // Animals attack the enemy with mixed particles
          const colors = ['#D2691E', '#A0522D', '#3498db'];
          for (let k = 0; k < 20; k++) {
            G.particles.push({
              x: o.x + o.w / 2,
              y: o.y - o.h / 2,
              vx: rand(-200, 200),
              vy: rand(-250, -80),
              life: rand(0.4, 0.7),
              color: colors[Math.floor(Math.random() * colors.length)]
            });
          }
          G.obstacles.splice(i, 1);
          G.score += 18;
          continue;
        }
      }
      
      // Fire dragon collision - dragon burns enemies
      if (G.ultActive && G.ultType === 'fireDragon' && G.dragonRect) {
        if (rectsOverlap(G.dragonRect, oRect)) {
          // Dragon burns the enemy with fire particles
          for (let k = 0; k < 25; k++) {
            G.particles.push({
              x: o.x + o.w / 2,
              y: o.y - o.h / 2,
              vx: rand(-200, 200),
              vy: rand(-300, -100),
              life: rand(0.5, 0.9),
              color: k % 3 === 0 ? '#ff0' : (k % 3 === 1 ? '#f80' : '#f00')
            });
          }
          G.obstacles.splice(i, 1);
          G.score += 20;
          continue;
        }
      }
      
      // Giant crow collision - crow attacks enemies
      if (G.ultActive && G.ultType === 'giantCrow' && G.crowRect) {
        if (rectsOverlap(G.crowRect, oRect)) {
          // Crow attacks with feather/dark particles
          for (let k = 0; k < 22; k++) {
            G.particles.push({
              x: o.x + o.w / 2,
              y: o.y - o.h / 2,
              vx: rand(-200, 200),
              vy: rand(-280, -80),
              life: rand(0.5, 0.8),
              color: k % 3 === 0 ? '#3498db' : '#1a1a1a'
            });
          }
          G.obstacles.splice(i, 1);
          G.score += 18;
          continue;
        }
      }
      
      // Mystic lightning collision - lightning strikes enemies
      if (G.ultActive && G.ultType === 'mysticLightning' && G.lightningRect) {
        if (rectsOverlap(G.lightningRect, oRect)) {
          // Lightning electrocutes enemies with purple/white particles
          for (let k = 0; k < 25; k++) {
            G.particles.push({
              x: o.x + o.w / 2,
              y: o.y - o.h / 2,
              vx: rand(-250, 250),
              vy: rand(-300, -100),
              life: rand(0.4, 0.8),
              color: k % 3 === 0 ? '#fff' : (k % 3 === 1 ? '#9b59b6' : '#f1c40f')
            });
          }
          G.obstacles.splice(i, 1);
          G.score += 20;
          continue;
        }
      }
      
      // Shadow clone collision - clone attacks enemies
      if (G.ultActive && G.ultType === 'shadowClone' && G.cloneRect) {
        if (rectsOverlap(G.cloneRect, oRect)) {
          // Clone slashes with purple particles
          for (let k = 0; k < 20; k++) {
            G.particles.push({
              x: o.x + o.w / 2,
              y: o.y - o.h / 2,
              vx: rand(-200, 200),
              vy: rand(-250, -80),
              life: rand(0.4, 0.7),
              color: k % 2 === 0 ? '#8e44ad' : '#9b59b6'
            });
          }
          G.obstacles.splice(i, 1);
          G.score += 16;
          continue;
        }
      }
    }

    // Random particles
    if (Math.random() < 0.04) {
      G.particles.push({
        x: rand(0, WORLD_W),
        y: rand(G.groundY + 5, G.groundY + 15),
        vx: -rand(20, 60),
        vy: -rand(20, 60),
        life: rand(0.1, 0.25),
        color: '#555'
      });
    }
  }

  // ===== RENDER =====
  function render() {
    ctx.save();
    ctx.scale(G.scaleX, G.scaleY);
    ctx.clearRect(0, 0, WORLD_W, WORLD_H);

    drawClouds(G.dt || 0);
    drawGround();
    drawParticles(G.dt || 0);
    
    // Draw platforms
    drawPlatforms();

    for (const o of G.obstacles) drawObstacle(o);
    for (const p of G.projectiles) drawProjectile(p);
    
    // Draw scrolls/parchments
    drawScrolls();
    
    // Draw boss
    if (G.bossActive && G.boss) {
      if (G.currentBossType === 'maxdown') {
        drawMaxdown();
        drawLaserWarning();
        drawLaser();
      } else {
        drawBoss();
      }
    }
    
    // Draw metal rain (Iori's Katana)
    drawMetalRain();
    
    drawPlayer();
    
    // Draw Iori's Katana in player hand
    drawIoriKatana();
    
    // Draw puppet (slave character)
    drawPuppet();
    
    drawUI();
    
    // Draw lives UI
    drawLivesUI();
    
    // Draw boss HP bar
    if (G.bossActive && G.boss) {
      drawBossUI();
    }

    ctx.restore();

    scorePill.textContent = `Skor: ${Math.floor(G.score)}`;
    coinPill.textContent = `ü™ô ${G.coins}`;
  }

  // ===== BOSS DRAWING =====
  function drawBoss() {
    const boss = G.boss;
    const x = boss.x;
    const y = boss.y;
    const w = boss.w;
    const h = boss.h;
    
    ctx.save();
    
    // Shadow
    ctx.fillStyle = 'rgba(0,0,0,0.3)';
    ctx.beginPath();
    ctx.ellipse(x + w/2, y + 5, w/2 + 10, 12, 0, 0, Math.PI * 2);
    ctx.fill();
    
    // Legs (armored boots)
    ctx.fillStyle = '#4a4a4a';
    ctx.fillRect(x + 15, y - 35, 18, 35);
    ctx.fillRect(x + w - 33, y - 35, 18, 35);
    
    // Boot details
    ctx.fillStyle = '#666';
    ctx.fillRect(x + 12, y - 10, 24, 12);
    ctx.fillRect(x + w - 36, y - 10, 24, 12);
    
    // Body (heavy armor)
    ctx.fillStyle = '#5c5c5c';
    ctx.fillRect(x + 8, y - 85, w - 16, 55);
    
    // Armor plates
    ctx.fillStyle = '#6b6b6b';
    ctx.fillRect(x + 5, y - 80, 12, 45);
    ctx.fillRect(x + w - 17, y - 80, 12, 45);
    
    // Chest emblem (lightning symbol)
    ctx.fillStyle = '#fbbf24';
    ctx.beginPath();
    ctx.moveTo(x + w/2 - 8, y - 75);
    ctx.lineTo(x + w/2 + 2, y - 75);
    ctx.lineTo(x + w/2 - 3, y - 60);
    ctx.lineTo(x + w/2 + 8, y - 60);
    ctx.lineTo(x + w/2 - 5, y - 40);
    ctx.lineTo(x + w/2, y - 55);
    ctx.lineTo(x + w/2 - 10, y - 55);
    ctx.fill();
    
    // Shoulders (big armor plates)
    ctx.fillStyle = '#4a4a4a';
    ctx.beginPath();
    ctx.ellipse(x - 5, y - 80, 18, 12, -0.3, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.ellipse(x + w + 5, y - 80, 18, 12, 0.3, 0, Math.PI * 2);
    ctx.fill();
    
    // Head
    const headY = y - h + 20;
    ctx.fillStyle = '#d4a574'; // Skin
    ctx.beginPath();
    ctx.ellipse(x + w/2, headY + 15, 22, 24, 0, 0, Math.PI * 2);
    ctx.fill();
    
    // One eye (right eye missing - scar)
    ctx.fillStyle = '#222';
    ctx.beginPath();
    ctx.ellipse(x + w/2 - 8, headY + 12, 4, 5, 0, 0, Math.PI * 2);
    ctx.fill();
    
    // Eye glow
    ctx.fillStyle = '#ef4444';
    ctx.beginPath();
    ctx.ellipse(x + w/2 - 8, headY + 11, 2, 2, 0, 0, Math.PI * 2);
    ctx.fill();
    
    // Scar over right eye
    ctx.strokeStyle = '#8b5a5a';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(x + w/2 + 3, headY + 2);
    ctx.lineTo(x + w/2 + 12, headY + 22);
    ctx.stroke();
    
    // Eyepatch
    ctx.fillStyle = '#222';
    ctx.beginPath();
    ctx.ellipse(x + w/2 + 8, headY + 12, 7, 8, 0, 0, Math.PI * 2);
    ctx.fill();
    
    // Eyepatch strap
    ctx.strokeStyle = '#333';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(x + w/2 + 14, headY + 10);
    ctx.quadraticCurveTo(x + w/2 + 25, headY + 5, x + w/2 + 20, headY - 5);
    ctx.stroke();
    
    // Red medium-long hair
    ctx.fillStyle = '#dc2626';
    // Main hair - flowing style
    ctx.beginPath();
    ctx.moveTo(x + w/2 - 28, headY + 5);
    ctx.quadraticCurveTo(x + w/2 - 30, headY - 15, x + w/2 - 22, headY - 25);
    ctx.quadraticCurveTo(x + w/2 - 10, headY - 32, x + w/2, headY - 28);
    ctx.quadraticCurveTo(x + w/2 + 10, headY - 32, x + w/2 + 22, headY - 25);
    ctx.quadraticCurveTo(x + w/2 + 30, headY - 15, x + w/2 + 28, headY + 5);
    ctx.closePath();
    ctx.fill();
    
    // Hair strands flowing down (left side)
    ctx.beginPath();
    ctx.moveTo(x + w/2 - 28, headY + 5);
    ctx.quadraticCurveTo(x + w/2 - 35, headY + 25, x + w/2 - 30, headY + 45);
    ctx.quadraticCurveTo(x + w/2 - 25, headY + 50, x + w/2 - 20, headY + 40);
    ctx.quadraticCurveTo(x + w/2 - 22, headY + 20, x + w/2 - 20, headY + 5);
    ctx.closePath();
    ctx.fill();
    
    // Hair strands flowing down (right side)
    ctx.beginPath();
    ctx.moveTo(x + w/2 + 28, headY + 5);
    ctx.quadraticCurveTo(x + w/2 + 35, headY + 25, x + w/2 + 30, headY + 45);
    ctx.quadraticCurveTo(x + w/2 + 25, headY + 50, x + w/2 + 20, headY + 40);
    ctx.quadraticCurveTo(x + w/2 + 22, headY + 20, x + w/2 + 20, headY + 5);
    ctx.closePath();
    ctx.fill();
    
    // Hair shine
    ctx.fillStyle = '#f87171';
    ctx.beginPath();
    ctx.moveTo(x + w/2 - 10, headY - 10);
    ctx.quadraticCurveTo(x + w/2 - 5, headY - 22, x + w/2 + 5, headY - 10);
    ctx.quadraticCurveTo(x + w/2, headY - 15, x + w/2 - 10, headY - 10);
    ctx.closePath();
    ctx.fill();
    
    // Mouth (angry expression)
    ctx.strokeStyle = '#333';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(x + w/2 - 10, headY + 28);
    ctx.lineTo(x + w/2 + 10, headY + 28);
    ctx.stroke();
    
    // Spear (electric)
    const spearBob = Math.sin(boss.phase) * 2;
    const spearX = x - 80; // Spear extends to the left
    const spearY = y - 60 + spearBob;
    
    // Store spear tip position for lightning
    boss.spearTipX = spearX - 30;
    boss.spearTipY = spearY;
    
    // Spear shaft (horizontal)
    ctx.fillStyle = '#5c4033';
    ctx.save();
    ctx.translate(x + 10, spearY);
    ctx.fillRect(-100, -4, 110, 8);
    
    // Shaft decoration rings
    ctx.fillStyle = '#8B7355';
    ctx.fillRect(-80, -5, 5, 10);
    ctx.fillRect(-50, -5, 5, 10);
    ctx.restore();
    
    // Spear blade (triangular blade)
    ctx.fillStyle = '#c0c0c0';
    ctx.beginPath();
    ctx.moveTo(spearX - 30, spearY); // Tip
    ctx.lineTo(spearX + 10, spearY - 12); // Top edge
    ctx.lineTo(spearX + 15, spearY - 10); // Top notch
    ctx.lineTo(spearX + 10, spearY); // Center back
    ctx.lineTo(spearX + 15, spearY + 10); // Bottom notch
    ctx.lineTo(spearX + 10, spearY + 12); // Bottom edge
    ctx.closePath();
    ctx.fill();
    
    // Blade edge highlight
    ctx.fillStyle = '#e8e8e8';
    ctx.beginPath();
    ctx.moveTo(spearX - 30, spearY);
    ctx.lineTo(spearX + 5, spearY - 9);
    ctx.lineTo(spearX + 5, spearY);
    ctx.closePath();
    ctx.fill();
    
    // Blade edge (sharp)
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(spearX - 30, spearY);
    ctx.lineTo(spearX + 10, spearY - 12);
    ctx.stroke();
    
    // Electric effect on blade
    ctx.strokeStyle = '#67e8f9';
    ctx.lineWidth = 2;
    ctx.shadowColor = '#67e8f9';
    ctx.shadowBlur = 10;
    const sparkPhase = Math.floor(boss.phase * 5) % 3;
    
    // Lightning arcs on blade
    for (let i = 0; i < 2; i++) {
      const arcX = spearX - 15 + i * 12;
      const sparkOffset = ((i + sparkPhase) % 2 === 0) ? 6 : -6;
      ctx.beginPath();
      ctx.moveTo(arcX, spearY - 5);
      ctx.lineTo(arcX + sparkOffset, spearY);
      ctx.lineTo(arcX, spearY + 5);
      ctx.stroke();
    }
    
    // Glowing tip
    ctx.fillStyle = '#fbbf24';
    ctx.shadowColor = '#fbbf24';
    ctx.shadowBlur = 12;
    ctx.beginPath();
    ctx.arc(spearX - 27, spearY, 4, 0, Math.PI * 2);
    ctx.fill();
    ctx.shadowBlur = 0;
    
    // Attack animation
    if (boss.attacking) {
      // Electric burst
      ctx.strokeStyle = '#67e8f9';
      ctx.lineWidth = 3;
      ctx.shadowColor = '#67e8f9';
      ctx.shadowBlur = 15;
      for (let i = 0; i < 5; i++) {
        const offsetY = ((i * 17) % 40) - 20;
        const offsetX = 30 + (i * 13) % 30;
        ctx.beginPath();
        ctx.moveTo(x - 20, y - 60 + offsetY);
        ctx.lineTo(x - 60 - offsetX, y - 60 + offsetY * 1.5);
        ctx.stroke();
      }
      ctx.shadowBlur = 0;
    }
    
    ctx.restore();
    
    // Draw boss projectiles
    for (const p of G.bossProjectiles) {
      drawBossProjectile(p);
    }
  }

  function drawMaxdown() {
    const boss = G.boss;
    const x = boss.x;
    const y = boss.y;
    const w = boss.w;
    const h = boss.h;
    
    ctx.save();
    
    // Shadow
    ctx.fillStyle = 'rgba(0,0,0,0.4)';
    ctx.beginPath();
    ctx.ellipse(x + w/2, y + 5, w/2 + 15, 15, 0, 0, Math.PI * 2);
    ctx.fill();
    
    // Glow effect
    const glowIntensity = 0.3 + Math.sin(boss.eyeGlow || 0) * 0.2;
    ctx.shadowColor = '#ff0000';
    ctx.shadowBlur = 30 * glowIntensity;
    
    // Legs (mechanical)
    ctx.fillStyle = '#2a2a2a';
    ctx.fillRect(x + 20, y - 50, 25, 50);
    ctx.fillRect(x + w - 45, y - 50, 25, 50);
    
    // Leg joints (glowing red)
    ctx.fillStyle = '#ff3333';
    ctx.beginPath();
    ctx.arc(x + 32, y - 25, 8, 0, Math.PI * 2);
    ctx.arc(x + w - 32, y - 25, 8, 0, Math.PI * 2);
    ctx.fill();
    
    // Feet (heavy mechanical)
    ctx.fillStyle = '#1a1a1a';
    ctx.fillRect(x + 15, y - 12, 35, 14);
    ctx.fillRect(x + w - 50, y - 12, 35, 14);
    
    // Body (bulky mechanical torso)
    ctx.fillStyle = '#333';
    ctx.fillRect(x + 5, y - 120, w - 10, 75);
    
    // Chest plate
    ctx.fillStyle = '#444';
    ctx.fillRect(x + 15, y - 115, w - 30, 65);
    
    // Red core in chest
    ctx.fillStyle = '#ff0000';
    ctx.shadowColor = '#ff0000';
    ctx.shadowBlur = 20;
    ctx.beginPath();
    ctx.arc(x + w/2, y - 85, 18, 0, Math.PI * 2);
    ctx.fill();
    
    // Core inner glow
    ctx.fillStyle = '#ff6666';
    ctx.beginPath();
    ctx.arc(x + w/2, y - 85, 10, 0, Math.PI * 2);
    ctx.fill();
    
    // Shoulder cannons
    ctx.fillStyle = '#2a2a2a';
    ctx.fillRect(x - 20, y - 130, 30, 25);
    ctx.fillRect(x + w - 10, y - 130, 30, 25);
    
    // Cannon barrels
    ctx.fillStyle = '#1a1a1a';
    ctx.fillRect(x - 25, y - 125, 15, 15);
    ctx.fillRect(x + w + 10, y - 125, 15, 15);
    
    // Arms (mechanical with red accents)
    ctx.fillStyle = '#2a2a2a';
    ctx.fillRect(x - 15, y - 100, 20, 55);
    ctx.fillRect(x + w - 5, y - 100, 20, 55);
    
    // Arm joints
    ctx.fillStyle = '#ff3333';
    ctx.beginPath();
    ctx.arc(x - 5, y - 75, 6, 0, Math.PI * 2);
    ctx.arc(x + w + 5, y - 75, 6, 0, Math.PI * 2);
    ctx.fill();
    
    // Hands (claws)
    ctx.fillStyle = '#1a1a1a';
    ctx.fillRect(x - 20, y - 50, 25, 15);
    ctx.fillRect(x + w - 5, y - 50, 25, 15);
    
    // Head (robotic alien)
    const headY = y - h + 25;
    
    // Neck
    ctx.fillStyle = '#333';
    ctx.fillRect(x + w/2 - 12, y - 135, 24, 20);
    
    // Head base (elongated alien shape)
    ctx.fillStyle = '#2a2a2a';
    ctx.beginPath();
    ctx.ellipse(x + w/2, headY + 5, 30, 25, 0, 0, Math.PI * 2);
    ctx.fill();
    
    // Head dome
    ctx.fillStyle = '#333';
    ctx.beginPath();
    ctx.ellipse(x + w/2, headY - 10, 25, 20, 0, Math.PI, Math.PI * 2);
    ctx.fill();
    
    // Single large eye (visor style)
    ctx.fillStyle = '#ff0000';
    ctx.shadowColor = '#ff0000';
    ctx.shadowBlur = 25;
    ctx.beginPath();
    ctx.ellipse(x + w/2, headY + 8, 22, 8, 0, 0, Math.PI * 2);
    ctx.fill();
    
    // Eye scanner line (moving)
    const scanPos = Math.sin(boss.eyeGlow * 2) * 15;
    ctx.fillStyle = '#ffffff';
    ctx.globalAlpha = 0.8;
    ctx.fillRect(x + w/2 - 20 + scanPos, headY + 5, 4, 6);
    ctx.globalAlpha = 1;
    
    // Antennae
    ctx.strokeStyle = '#444';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(x + w/2 - 15, headY - 25);
    ctx.lineTo(x + w/2 - 25, headY - 45);
    ctx.moveTo(x + w/2 + 15, headY - 25);
    ctx.lineTo(x + w/2 + 25, headY - 45);
    ctx.stroke();
    
    // Antenna tips (glowing)
    ctx.fillStyle = '#ff3333';
    ctx.beginPath();
    ctx.arc(x + w/2 - 25, headY - 45, 5, 0, Math.PI * 2);
    ctx.arc(x + w/2 + 25, headY - 45, 5, 0, Math.PI * 2);
    ctx.fill();
    
    // Name tag
    ctx.shadowBlur = 0;
    ctx.fillStyle = '#ff0000';
    ctx.font = 'bold 14px monospace';
    ctx.textAlign = 'center';
    ctx.fillText('MAXDOWN', x + w/2, headY - 55);
    
    ctx.restore();
  }

  function drawLaserWarning() {
    if (!G.laserWarning || !G.boss) return;
    
    const boss = G.boss;
    ctx.save();
    
    // Big flashing warning text
    const flash = Math.sin(Date.now() / 80) > 0;
    
    if (flash) {
      // Warning text at top
      ctx.fillStyle = '#ff0000';
      ctx.font = 'bold 32px sans-serif';
      ctx.textAlign = 'center';
      ctx.shadowColor = '#ff0000';
      ctx.shadowBlur = 20;
      ctx.fillText('‚ö†Ô∏è LAZER GELƒ∞YOR! ‚ö†Ô∏è', WORLD_W / 2, 100);
      
      // Warning line where laser will hit
      ctx.strokeStyle = 'rgba(255, 0, 0, 0.8)';
      ctx.lineWidth = 4;
      ctx.setLineDash([15, 15]);
      ctx.beginPath();
      ctx.moveTo(0, G.groundY - 40);
      ctx.lineTo(boss.x + boss.w/2, G.groundY - 40);
      ctx.stroke();
      ctx.setLineDash([]);
      
      // Target zone highlight
      ctx.fillStyle = 'rgba(255, 0, 0, 0.2)';
      ctx.fillRect(0, G.groundY - 60, boss.x + boss.w/2, 40);
    }
    
    // Arrow pointing to safe zone (jump!)
    ctx.fillStyle = '#00ff00';
    ctx.font = 'bold 20px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('‚Üë ZIPLA! ‚Üë', 100, G.groundY - 100);
    
    ctx.restore();
  }

  function drawLaser() {
    if (!G.laserActive || !G.boss) return;
    
    const boss = G.boss;
    ctx.save();
    
    // Laser warning line first
    const laserProgress = 1 - (G.laserTimer / BOSS_MAXDOWN.laserDuration);
    
    // Main laser beam
    const gradient = ctx.createLinearGradient(0, G.laserY - 20, 0, G.laserY + 20);
    gradient.addColorStop(0, 'rgba(255, 0, 0, 0)');
    gradient.addColorStop(0.3, 'rgba(255, 0, 0, 0.8)');
    gradient.addColorStop(0.5, 'rgba(255, 255, 255, 1)');
    gradient.addColorStop(0.7, 'rgba(255, 0, 0, 0.8)');
    gradient.addColorStop(1, 'rgba(255, 0, 0, 0)');
    
    ctx.fillStyle = gradient;
    ctx.shadowColor = '#ff0000';
    ctx.shadowBlur = 30;
    ctx.fillRect(0, G.laserY - 15, boss.x + 20, 30);
    
    // Core beam (brighter)
    ctx.fillStyle = 'rgba(255, 200, 200, 0.9)';
    ctx.fillRect(0, G.laserY - 5, boss.x + 20, 10);
    
    // Laser source at boss eye
    ctx.fillStyle = '#ffffff';
    ctx.shadowColor = '#ff0000';
    ctx.shadowBlur = 40;
    ctx.beginPath();
    ctx.arc(boss.x + 20, G.laserY, 15, 0, Math.PI * 2);
    ctx.fill();
    
    // Particles along laser
    for (let i = 0; i < 3; i++) {
      const px = rand(0, boss.x);
      G.particles.push({
        x: px,
        y: G.laserY + rand(-20, 20),
        vx: rand(-50, 50),
        vy: rand(-80, -30),
        life: rand(0.1, 0.3),
        color: '#ff4444'
      });
    }
    
    ctx.restore();
  }

  function drawBossProjectile(p) {
    ctx.save();
    
    if (p.type === 'shockwave') {
      // Electric shockwave - different color for low attacks
      const mainColor = p.isLow ? '#fbbf24' : '#67e8f9';
      const sparkColor = p.isLow ? '#fde68a' : '#a5f3fc';
      
      ctx.strokeStyle = mainColor;
      ctx.lineWidth = 4;
      ctx.shadowColor = mainColor;
      ctx.shadowBlur = 15;
      
      // Main wave
      ctx.beginPath();
      ctx.moveTo(p.x, p.y - 15);
      for (let i = 0; i < 80; i += 10) {
        ctx.lineTo(p.x - i, p.y + (i % 20 === 0 ? -15 : 15));
      }
      ctx.stroke();
      
      // Core
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.ellipse(p.x, p.y, 12, 8, 0, 0, Math.PI * 2);
      ctx.fill();
      
      // Electric sparks (deterministic pattern)
      ctx.strokeStyle = sparkColor;
      ctx.lineWidth = 2;
      for (let i = 0; i < 4; i++) {
        const sparkY = (i % 2 === 0) ? 15 : -15;
        const sparkX = (i % 2 === 0) ? 8 : -8;
        ctx.beginPath();
        ctx.moveTo(p.x - i * 15, p.y);
        ctx.lineTo(p.x - i * 15 + sparkX, p.y + sparkY);
        ctx.stroke();
      }
      
      ctx.shadowBlur = 0;
    } else if (p.type === 'plasma') {
      // MAXDOWN plasma orb
      ctx.shadowColor = '#ff0000';
      ctx.shadowBlur = 20;
      
      // Outer glow
      ctx.fillStyle = 'rgba(255, 0, 0, 0.5)';
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size + 8, 0, Math.PI * 2);
      ctx.fill();
      
      // Main orb
      ctx.fillStyle = '#ff3333';
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
      ctx.fill();
      
      // Inner core
      ctx.fillStyle = '#ffaaaa';
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size * 0.5, 0, Math.PI * 2);
      ctx.fill();
      
      // Highlight
      ctx.fillStyle = '#ffffff';
      ctx.beginPath();
      ctx.arc(p.x - p.size * 0.3, p.y - p.size * 0.3, p.size * 0.2, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.shadowBlur = 0;
    }
    
    ctx.restore();
  }

  function drawBossUI() {
    const boss = G.boss;
    
    // Boss name
    const bossName = G.currentBossType === 'maxdown' ? 'ü§ñ MAXDOWN ü§ñ' : '‚ö° KLON RIARU ‚ö°';
    const nameColor = G.currentBossType === 'maxdown' ? '#ff3333' : '#fff';
    ctx.fillStyle = nameColor;
    ctx.font = 'bold 16px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText(bossName, WORLD_W / 2, 30);
    
    // HP bar background
    ctx.fillStyle = 'rgba(0,0,0,0.5)';
    ctx.fillRect(WORLD_W / 2 - 100, 40, 200, 16);
    
    // HP bar
    const hpPercent = boss.hp / boss.maxHp;
    const hpColor = G.currentBossType === 'maxdown' 
      ? (hpPercent > 0.5 ? '#ff3333' : hpPercent > 0.25 ? '#ff6600' : '#ff0000')
      : (hpPercent > 0.5 ? '#22c55e' : hpPercent > 0.25 ? '#eab308' : '#ef4444');
    ctx.fillStyle = hpColor;
    ctx.fillRect(WORLD_W / 2 - 98, 42, 196 * hpPercent, 12);
    
    // HP bar border
    ctx.strokeStyle = G.currentBossType === 'maxdown' ? '#ff3333' : '#fff';
    ctx.lineWidth = 2;
    ctx.strokeRect(WORLD_W / 2 - 100, 40, 200, 16);
    
    // HP text
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 10px sans-serif';
    ctx.fillText(`${Math.ceil(boss.hp)} / ${boss.maxHp}`, WORLD_W / 2, 52);
  }

  // ===== GAME LOOP =====
  function gameLoop(ts) {
    if (!G.last) G.last = ts;
    const dt = clamp((ts - G.last) / 1000, 0, 0.033);
    G.last = ts;

    if (screens.game.classList.contains('active')) {
      update(dt);
      render();
    }

    requestAnimationFrame(gameLoop);
  }

  // ===== INIT =====
  // Generate character avatars
  generateAllAvatars();
  
  // Check for saved nickname
  const savedNick = sessionStorage.getItem('ninja_nick');
  if (savedNick) {
    nickname = savedNick;
    nickInput.value = savedNick;
    nickBtn.disabled = false;
  }
})();
</script>
</body>
</html>
